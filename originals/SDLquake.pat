diff -ruN WinQuake/COPYING sdlquake-1.0.9/COPYING
--- WinQuake/COPYING	Wed Dec 31 16:00:00 1969
+++ sdlquake-1.0.9/COPYING	Sat Dec 25 04:24:29 1999
@@ -0,0 +1,87 @@
+GNU GENERAL PUBLIC LICENSE
+Version 2, June 1991 
+
+Copyright (C) 1989, 1991 Free Software Foundation, Inc.  
+59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
+
+Everyone is permitted to copy and distribute verbatim copies
+of this license document, but changing it is not allowed.
+Preamble
+The licenses for most software are designed to take away your freedom to share and change it. By contrast, the GNU General Public License is intended to guarantee your freedom to share and change free software--to make sure the software is free for all its users. This General Public License applies to most of the Free Software Foundation's software and to any other program whose authors commit to using it. (Some other Free Software Foundation software is covered by the GNU Library General Public License instead.) You can apply it to your programs, too. 
+
+When we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for this service if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs; and that you know you can do these things. 
+
+To protect your rights, we need to make restrictions that forbid anyone to deny you these rights or to ask you to surrender the rights. These restrictions translate to certain responsibilities for you if you distribute copies of the software, or if you modify it. 
+
+For example, if you distribute copies of such a program, whether gratis or for a fee, you must give the recipients all the rights that you have. You must make sure that they, too, receive or can get the source code. And you must show them these terms so they know their rights. 
+
+We protect your rights with two steps: (1) copyright the software, and (2) offer you this license which gives you legal permission to copy, distribute and/or modify the software. 
+
+Also, for each author's protection and ours, we want to make certain that everyone understands that there is no warranty for this free software. If the software is modified by someone else and passed on, we want its recipients to know that what they have is not the original, so that any problems introduced by others will not reflect on the original authors' reputations. 
+
+Finally, any free program is threatened constantly by software patents. We wish to avoid the danger that redistributors of a free program will individually obtain patent licenses, in effect making the program proprietary. To prevent this, we have made it clear that any patent must be licensed for everyone's free use or not licensed at all. 
+
+The precise terms and conditions for copying, distribution and modification follow. 
+
+TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+0. This License applies to any program or other work which contains a notice placed by the copyright holder saying it may be distributed under the terms of this General Public License. The "Program", below, refers to any such program or work, and a "work based on the Program" means either the Program or any derivative work under copyright law: that is to say, a work containing the Program or a portion of it, either verbatim or with modifications and/or translated into another language. (Hereinafter, translation is included without limitation in the term "modification".) Each licensee is addressed as "you". 
+
+Activities other than copying, distribution and modification are not covered by this License; they are outside its scope. The act of running the Program is not restricted, and the output from the Program is covered only if its contents constitute a work based on the Program (independent of having been made by running the Program). Whether that is true depends on what the Program does. 
+
+1. You may copy and distribute verbatim copies of the Program's source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice and disclaimer of warranty; keep intact all the notices that refer to this License and to the absence of any warranty; and give any other recipients of the Program a copy of this License along with the Program. 
+
+You may charge a fee for the physical act of transferring a copy, and you may at your option offer warranty protection in exchange for a fee. 
+
+2. You may modify your copy or copies of the Program or any portion of it, thus forming a work based on the Program, and copy and distribute such modifications or work under the terms of Section 1 above, provided that you also meet all of these conditions: 
+
+
+a) You must cause the modified files to carry prominent notices stating that you changed the files and the date of any change. 
+
+b) You must cause any work that you distribute or publish, that in whole or in part contains or is derived from the Program or any part thereof, to be licensed as a whole at no charge to all third parties under the terms of this License. 
+
+c) If the modified program normally reads commands interactively when run, you must cause it, when started running for such interactive use in the most ordinary way, to print or display an announcement including an appropriate copyright notice and a notice that there is no warranty (or else, saying that you provide a warranty) and that users may redistribute the program under these conditions, and telling the user how to view a copy of this License. (Exception: if the Program itself is interactive but does not normally print such an announcement, your work based on the Program is not required to print an announcement.) 
+These requirements apply to the modified work as a whole. If identifiable sections of that work are not derived from the Program, and can be reasonably considered independent and separate works in themselves, then this License, and its terms, do not apply to those sections when you distribute them as separate works. But when you distribute the same sections as part of a whole which is a work based on the Program, the distribution of the whole must be on the terms of this License, whose permissions for other licensees extend to the entire whole, and thus to each and every part regardless of who wrote it. 
+Thus, it is not the intent of this section to claim rights or contest your rights to work written entirely by you; rather, the intent is to exercise the right to control the distribution of derivative or collective works based on the Program. 
+
+In addition, mere aggregation of another work not based on the Program with the Program (or with a work based on the Program) on a volume of a storage or distribution medium does not bring the other work under the scope of this License. 
+
+3. You may copy and distribute the Program (or a work based on it, under Section 2) in object code or executable form under the terms of Sections 1 and 2 above provided that you also do one of the following: 
+
+a) Accompany it with the complete corresponding machine-readable source code, which must be distributed under the terms of Sections 1 and 2 above on a medium customarily used for software interchange; or, 
+
+b) Accompany it with a written offer, valid for at least three years, to give any third party, for a charge no more than your cost of physically performing source distribution, a complete machine-readable copy of the corresponding source code, to be distributed under the terms of Sections 1 and 2 above on a medium customarily used for software interchange; or, 
+
+c) Accompany it with the information you received as to the offer to distribute corresponding source code. (This alternative is allowed only for noncommercial distribution and only if you received the program in object code or executable form with such an offer, in accord with Subsection b above.) 
+The source code for a work means the preferred form of the work for making modifications to it. For an executable work, complete source code means all the source code for all modules it contains, plus any associated interface definition files, plus the scripts used to control compilation and installation of the executable. However, as a special exception, the source code distributed need not include anything that is normally distributed (in either source or binary form) with the major components (compiler, kernel, and so on) of the operating system on which the executable runs, unless that component itself accompanies the executable. 
+If distribution of executable or object code is made by offering access to copy from a designated place, then offering equivalent access to copy the source code from the same place counts as distribution of the source code, even though third parties are not compelled to copy the source along with the object code. 
+
+4. You may not copy, modify, sublicense, or distribute the Program except as expressly provided under this License. Any attempt otherwise to copy, modify, sublicense or distribute the Program is void, and will automatically terminate your rights under this License. However, parties who have received copies, or rights, from you under this License will not have their licenses terminated so long as such parties remain in full compliance. 
+
+5. You are not required to accept this License, since you have not signed it. However, nothing else grants you permission to modify or distribute the Program or its derivative works. These actions are prohibited by law if you do not accept this License. Therefore, by modifying or distributing the Program (or any work based on the Program), you indicate your acceptance of this License to do so, and all its terms and conditions for copying, distributing or modifying the Program or works based on it. 
+
+6. Each time you redistribute the Program (or any work based on the Program), the recipient automatically receives a license from the original licensor to copy, distribute or modify the Program subject to these terms and conditions. You may not impose any further restrictions on the recipients' exercise of the rights granted herein. You are not responsible for enforcing compliance by third parties to this License. 
+
+7. If, as a consequence of a court judgment or allegation of patent infringement or for any other reason (not limited to patent issues), conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot distribute so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not distribute the Program at all. For example, if a patent license would not permit royalty-free redistribution of the Program by all those who receive copies directly or indirectly through you, then the only way you could satisfy both it and this License would be to refrain entirely from distribution of the Program. 
+
+If any portion of this section is held invalid or unenforceable under any particular circumstance, the balance of the section is intended to apply and the section as a whole is intended to apply in other circumstances. 
+
+It is not the purpose of this section to induce you to infringe any patents or other property right claims or to contest validity of any such claims; this section has the sole purpose of protecting the integrity of the free software distribution system, which is implemented by public license practices. Many people have made generous contributions to the wide range of software distributed through that system in reliance on consistent application of that system; it is up to the author/donor to decide if he or she is willing to distribute software through any other system and a licensee cannot impose that choice. 
+
+This section is intended to make thoroughly clear what is believed to be a consequence of the rest of this License. 
+
+8. If the distribution and/or use of the Program is restricted in certain countries either by patents or by copyrighted interfaces, the original copyright holder who places the Program under this License may add an explicit geographical distribution limitation excluding those countries, so that distribution is permitted only in or among countries not thus excluded. In such case, this License incorporates the limitation as if written in the body of this License. 
+
+9. The Free Software Foundation may publish revised and/or new versions of the General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. 
+
+Each version is given a distinguishing version number. If the Program specifies a version number of this License which applies to it and "any later version", you have the option of following the terms and conditions either of that version or of any later version published by the Free Software Foundation. If the Program does not specify a version number of this License, you may choose any version ever published by the Free Software Foundation. 
+
+10. If you wish to incorporate parts of the Program into other free programs whose distribution conditions are different, write to the author to ask for permission. For software which is copyrighted by the Free Software Foundation, write to the Free Software Foundation; we sometimes make exceptions for this. Our decision will be guided by the two goals of preserving the free status of all derivatives of our free software and of promoting the sharing and reuse of software generally. 
+
+NO WARRANTY
+
+11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION. 
+
+12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. 
+
+
+END OF TERMS AND CONDITIONS
diff -ruN WinQuake/Makefile.am sdlquake-1.0.9/Makefile.am
--- WinQuake/Makefile.am	Wed Dec 31 16:00:00 1969
+++ sdlquake-1.0.9/Makefile.am	Tue Dec 28 10:44:48 1999
@@ -0,0 +1,292 @@
+
+bin_PROGRAMS = sdlquake
+
+sdlquake_LDADD = @MATHLIB@ @INETLIB@
+
+sdlquake_SOURCES =		\
+	adivtab.h		\
+	anorm_dots.h		\
+	anorms.h		\
+	asm_draw.h		\
+	asm_i386.h		\
+	block16.h		\
+	block8.h		\
+	bspfile.h		\
+	cd_sdl.c		\
+	cdaudio.h		\
+	chase.c			\
+	cl_demo.c		\
+	cl_input.c		\
+	cl_main.c		\
+	cl_parse.c		\
+	cl_tent.c		\
+	clean.bat		\
+	client.h		\
+	cmd.c			\
+	cmd.h			\
+	common.c		\
+	common.h		\
+	conproc.h		\
+	console.c		\
+	console.h		\
+	crc.c			\
+	crc.h			\
+	cvar.c			\
+	cvar.h			\
+	d_copy.S		\
+	d_edge.c		\
+	d_fill.c		\
+	d_iface.h		\
+	d_ifacea.h		\
+	d_init.c		\
+	d_local.h		\
+	d_modech.c		\
+	d_part.c		\
+	d_polyse.c		\
+	d_scan.c		\
+	d_sky.c			\
+	d_sprite.c		\
+	d_surf.c		\
+	d_zpoint.c		\
+	dosasm.S		\
+	dosisms.h		\
+	draw.c			\
+	draw.h			\
+	host.c			\
+	host_cmd.c		\
+	input.h			\
+	keys.c			\
+	keys.h			\
+	mathlib.c		\
+	mathlib.h		\
+	menu.c			\
+	menu.h			\
+	model.c			\
+	model.h			\
+	modelgen.h		\
+	mpdosock.h		\
+	net.h			\
+	net_bsd.c		\
+	net_bw.h		\
+	net_dgrm.c		\
+	net_dgrm.h		\
+	net_loop.c		\
+	net_loop.h		\
+	net_main.c		\
+	net_udp.c		\
+	net_udp.h		\
+	net_vcr.c		\
+	net_vcr.h		\
+	net_wso.c		\
+	pr_cmds.c		\
+	pr_comp.h		\
+	pr_edict.c		\
+	pr_exec.c		\
+	progdefs.h		\
+	progs.h			\
+	protocol.h		\
+	quakeasm.h		\
+	quakedef.h		\
+	r_aclip.c		\
+	r_alias.c		\
+	r_bsp.c			\
+	r_draw.c		\
+	r_edge.c		\
+	r_efrag.c		\
+	r_light.c		\
+	r_local.h		\
+	r_main.c		\
+	r_misc.c		\
+	r_part.c		\
+	r_shared.h		\
+	r_sky.c			\
+	r_sprite.c		\
+	r_surf.c		\
+	r_vars.c		\
+	r_varsa.S		\
+	render.h		\
+	resource.h		\
+	sbar.c			\
+	sbar.h			\
+	scitech			\
+	screen.c		\
+	screen.h		\
+	server.h		\
+	snd_dma.c		\
+	snd_mem.c		\
+	snd_mix.c		\
+	snd_sdl.c		\
+	sound.h			\
+	spritegn.h		\
+	sv_main.c		\
+	sv_move.c		\
+	sv_phys.c		\
+	sv_user.c		\
+	sys.h			\
+	sys_sdl.c		\
+	vgamodes.h		\
+	vid.h			\
+	vid_sdl.c		\
+	view.c			\
+	view.h			\
+	wad.c			\
+	wad.h			\
+	winquake.h		\
+	world.c			\
+	world.h			\
+	zone.c			\
+	zone.h			\
+	$(X86_SRCS) $(NONX86_SRCS)
+
+X86_SRCS =			\
+	snd_mixa.S		\
+	sys_dosa.S		\
+	d_draw.S		\
+	d_draw16.S		\
+	d_parta.S		\
+	d_polysa.S		\
+	d_scana.S		\
+	d_spr8.S		\
+	d_varsa.S		\
+	math.S			\
+	r_aclipa.S		\
+	r_aliasa.S		\
+	r_drawa.S		\
+	r_edgea.S		\
+	surf16.S		\
+	surf8.S			\
+	worlda.S
+
+NONX86_SRCS =			\
+	d_vars.c		\
+	nonintel.c
+
+
+NULL_SRCS =			\
+	cd_null.c		\
+	in_null.c		\
+	net_none.c		\
+	snd_null.c		\
+	sys_null.c		\
+	vid_null.c
+
+DOS_SRCS =			\
+	cd_audio.c		\
+	dos_v2.c		\
+	in_dos.c		\
+	mplib.c			\
+	mplpc.c			\
+	net_bw.c		\
+	net_comx.c		\
+	net_dos.c		\
+	net_ipx.c		\
+	net_ipx.h		\
+	net_ser.c		\
+	net_ser.h		\
+	snd_dos.c		\
+	snd_gus.c		\
+	sys_dos.c		\
+	vid_dos.c		\
+	vid_dos.h		\
+	vid_ext.c		\
+	vid_vga.c		\
+	vregset.c		\
+	vregset.h
+
+WIN_SRCS =			\
+	cd_win.c		\
+	conproc.c		\
+	in_win.c		\
+	net_mp.c		\
+	net_mp.h		\
+	net_win.c		\
+	net_wins.c		\
+	net_wins.h		\
+	net_wipx.c		\
+	net_wipx.h		\
+	snd_win.c		\
+	sys_win.c		\
+	sys_wina.S		\
+	sys_wind.c		\
+	vid_win.c
+
+LNX_SRCS =			\
+	cd_linux.c		\
+	snd_linux.c		\
+	sys_linux.c		\
+	vid_svgalib.c		\
+	vid_x.c
+
+SUN_SRCS =			\
+	snd_sun.c		\
+	in_sun.c		\
+	sys_sun.c		\
+	vid_sunx.c		\
+	vid_sunxil.c
+
+NEXT_SRCS =			\
+	snd_next.c
+
+GL_SRCS =			\
+	gl_draw.c		\
+	gl_mesh.c		\
+	gl_model.c		\
+	gl_model.h		\
+	gl_refrag.c		\
+	gl_rlight.c		\
+	gl_rmain.c		\
+	gl_rmisc.c		\
+	gl_rsurf.c		\
+	gl_screen.c		\
+	gl_test.c		\
+	gl_vidlinux.c		\
+	gl_vidlinuxglx.c	\
+	gl_vidnt.c		\
+	gl_warp.c		\
+	gl_warp_sin.h		\
+	glquake.h		\
+	glquake2.h
+
+EXTRA_DIST =			\
+	README.SDL		\
+	3dfx.txt		\
+	Makefile.Solaris	\
+	Makefile.linuxi386	\
+	README.Solaris		\
+	WinQuake.dsp		\
+	WinQuake.dsw		\
+	WinQuake.mdp		\
+	WinQuake.ncb		\
+	WinQuake.opt		\
+	WinQuake.plg		\
+	cwsdpmi.exe		\
+	glqnotes.txt		\
+	makezip.bat		\
+	progdefs.q1		\
+	progdefs.q2		\
+	q.bat			\
+	qa.bat			\
+	qb.bat			\
+	qe3.ico			\
+	qt.bat			\
+	quake-data.spec.sh	\
+	quake-hipnotic.spec.sh	\
+	quake-rogue.spec.sh	\
+	quake-shareware.spec.sh	\
+	quake.gif		\
+	quake.ico		\
+	quake.spec.sh		\
+	winquake.aps		\
+	winquake.rc		\
+	wq.bat			\
+	wqreadme.txt		\
+	$(NULL_SRCS)		\
+	$(DOS_SRCS)		\
+	$(WIN_SRCS)		\
+	$(LNX_SRCS)		\
+	$(SUN_SRCS)		\
+	$(NEXT_SRCS)		\
+	$(GL_SRCS)
+
+dist-hook:
+	cp -rp data docs dxsdk gas2masm kit scitech $(distdir)/
diff -ruN WinQuake/Makefile.in sdlquake-1.0.9/Makefile.in
--- WinQuake/Makefile.in	Wed Dec 31 16:00:00 1969
+++ sdlquake-1.0.9/Makefile.in	Tue Dec 28 11:16:53 1999
@@ -0,0 +1,765 @@
+# Makefile.in generated automatically by automake 1.4 from Makefile.am
+
+# Copyright (C) 1994, 1995-8, 1999 Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+
+SHELL = @SHELL@
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+prefix = @prefix@
+exec_prefix = @exec_prefix@
+
+bindir = @bindir@
+sbindir = @sbindir@
+libexecdir = @libexecdir@
+datadir = @datadir@
+sysconfdir = @sysconfdir@
+sharedstatedir = @sharedstatedir@
+localstatedir = @localstatedir@
+libdir = @libdir@
+infodir = @infodir@
+mandir = @mandir@
+includedir = @includedir@
+oldincludedir = /usr/include
+
+DESTDIR =
+
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+
+top_builddir = .
+
+ACLOCAL = @ACLOCAL@
+AUTOCONF = @AUTOCONF@
+AUTOMAKE = @AUTOMAKE@
+AUTOHEADER = @AUTOHEADER@
+
+INSTALL = @INSTALL@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@ $(AM_INSTALL_PROGRAM_FLAGS)
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+transform = @program_transform_name@
+
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+host_alias = @host_alias@
+host_triplet = @host@
+CC = @CC@
+ICONOBJ = @ICONOBJ@
+INETLIB = @INETLIB@
+MAKEINFO = @MAKEINFO@
+MATHLIB = @MATHLIB@
+PACKAGE = @PACKAGE@
+SDL_CFLAGS = @SDL_CFLAGS@
+SDL_CONFIG = @SDL_CONFIG@
+SDL_LIBS = @SDL_LIBS@
+VERSION = @VERSION@
+
+bin_PROGRAMS = sdlquake
+
+sdlquake_LDADD = @MATHLIB@ @INETLIB@
+
+sdlquake_SOURCES =  	adivtab.h			anorm_dots.h			anorms.h			asm_draw.h			asm_i386.h			block16.h			block8.h			bspfile.h			cd_sdl.c			cdaudio.h			chase.c				cl_demo.c			cl_input.c			cl_main.c			cl_parse.c			cl_tent.c			clean.bat			client.h			cmd.c				cmd.h				common.c			common.h			conproc.h			console.c			console.h			crc.c				crc.h				cvar.c				cvar.h				d_copy.S			d_edge.c			d_fill.c			d_iface.h			d_ifacea.h			d_init.c			d_local.h			d_modech.c			d_part.c			d_polyse.c			d_scan.c			d_sky.c				d_sprite.c			d_surf.c			d_zpoint.c			dosasm.S			dosisms.h			draw.c				draw.h				host.c				host_cmd.c			input.h				keys.c				keys.h				mathlib.c			mathlib.h			menu.c				menu.h				model.c				model.h				modelgen.h			mpdosock.h			net.h				net_bsd.c			net_bw.h			net_dgrm.c			net_dgrm.h			net_loop.c			net_loop.h			net_main.c			net_udp.c			net_udp.h			net_vcr.c			net_vcr.h			net_wso.c			pr_cmds.c			pr_comp.h			pr_edict.c			pr_exec.c			progdefs.h			progs.h				protocol.h			quakeasm.h			quakedef.h			r_aclip.c			r_alias.c			r_bsp.c				r_draw.c			r_edge.c			r_efrag.c			r_light.c			r_local.h			r_main.c			r_misc.c			r_part.c			r_shared.h			r_sky.c				r_sprite.c			r_surf.c			r_vars.c			r_varsa.S			render.h			resource.h			sbar.c				sbar.h				scitech				screen.c			screen.h			server.h			snd_dma.c			snd_mem.c			snd_mix.c			snd_sdl.c			sound.h				spritegn.h			sv_main.c			sv_move.c			sv_phys.c			sv_user.c			sys.h				sys_sdl.c			vgamodes.h			vid.h				vid_sdl.c			view.c				view.h				wad.c				wad.h				winquake.h			world.c				world.h				zone.c				zone.h				$(X86_SRCS) $(NONX86_SRCS)
+
+
+X86_SRCS =  	snd_mixa.S			sys_dosa.S			d_draw.S			d_draw16.S			d_parta.S			d_polysa.S			d_scana.S			d_spr8.S			d_varsa.S			math.S				r_aclipa.S			r_aliasa.S			r_drawa.S			r_edgea.S			surf16.S			surf8.S				worlda.S
+
+
+NONX86_SRCS =  	d_vars.c			nonintel.c
+
+
+NULL_SRCS =  	cd_null.c			in_null.c			net_none.c			snd_null.c			sys_null.c			vid_null.c
+
+
+DOS_SRCS =  	cd_audio.c			dos_v2.c			in_dos.c			mplib.c				mplpc.c				net_bw.c			net_comx.c			net_dos.c			net_ipx.c			net_ipx.h			net_ser.c			net_ser.h			snd_dos.c			snd_gus.c			sys_dos.c			vid_dos.c			vid_dos.h			vid_ext.c			vid_vga.c			vregset.c			vregset.h
+
+
+WIN_SRCS =  	cd_win.c			conproc.c			in_win.c			net_mp.c			net_mp.h			net_win.c			net_wins.c			net_wins.h			net_wipx.c			net_wipx.h			snd_win.c			sys_win.c			sys_wina.S			sys_wind.c			vid_win.c
+
+
+LNX_SRCS =  	cd_linux.c			snd_linux.c			sys_linux.c			vid_svgalib.c			vid_x.c
+
+
+SUN_SRCS =  	snd_sun.c			in_sun.c			sys_sun.c			vid_sunx.c			vid_sunxil.c
+
+
+NEXT_SRCS =  	snd_next.c
+
+
+GL_SRCS =  	gl_draw.c			gl_mesh.c			gl_model.c			gl_model.h			gl_refrag.c			gl_rlight.c			gl_rmain.c			gl_rmisc.c			gl_rsurf.c			gl_screen.c			gl_test.c			gl_vidlinux.c			gl_vidlinuxglx.c		gl_vidnt.c			gl_warp.c			gl_warp_sin.h			glquake.h			glquake2.h
+
+
+EXTRA_DIST =  	README.SDL			3dfx.txt			Makefile.Solaris		Makefile.linuxi386		README.Solaris			WinQuake.dsp			WinQuake.dsw			WinQuake.mdp			WinQuake.ncb			WinQuake.opt			WinQuake.plg			cwsdpmi.exe			glqnotes.txt			makezip.bat			progdefs.q1			progdefs.q2			q.bat				qa.bat				qb.bat				qe3.ico				qt.bat				quake-data.spec.sh		quake-hipnotic.spec.sh		quake-rogue.spec.sh		quake-shareware.spec.sh		quake.gif			quake.ico			quake.spec.sh			winquake.aps			winquake.rc			wq.bat				wqreadme.txt			$(NULL_SRCS)			$(DOS_SRCS)			$(WIN_SRCS)			$(LNX_SRCS)			$(SUN_SRCS)			$(NEXT_SRCS)			$(GL_SRCS)
+
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_CLEAN_FILES = 
+PROGRAMS =  $(bin_PROGRAMS)
+
+
+DEFS = @DEFS@ -I. -I$(srcdir) 
+CPPFLAGS = @CPPFLAGS@
+LDFLAGS = @LDFLAGS@
+LIBS = @LIBS@
+sdlquake_OBJECTS =  cd_sdl.o chase.o cl_demo.o cl_input.o cl_main.o \
+cl_parse.o cl_tent.o cmd.o common.o console.o crc.o cvar.o d_copy.o \
+d_edge.o d_fill.o d_init.o d_modech.o d_part.o d_polyse.o d_scan.o \
+d_sky.o d_sprite.o d_surf.o d_zpoint.o dosasm.o draw.o host.o \
+host_cmd.o keys.o mathlib.o menu.o model.o net_bsd.o net_dgrm.o \
+net_loop.o net_main.o net_udp.o net_vcr.o net_wso.o pr_cmds.o \
+pr_edict.o pr_exec.o r_aclip.o r_alias.o r_bsp.o r_draw.o r_edge.o \
+r_efrag.o r_light.o r_main.o r_misc.o r_part.o r_sky.o r_sprite.o \
+r_surf.o r_vars.o r_varsa.o sbar.o screen.o snd_dma.o snd_mem.o \
+snd_mix.o snd_sdl.o sv_main.o sv_move.o sv_phys.o sv_user.o sys_sdl.o \
+vid_sdl.o view.o wad.o world.o zone.o snd_mixa.o sys_dosa.o d_draw.o \
+d_draw16.o d_parta.o d_polysa.o d_scana.o d_spr8.o d_varsa.o math.o \
+r_aclipa.o r_aliasa.o r_drawa.o r_edgea.o surf16.o surf8.o worlda.o \
+d_vars.o nonintel.o
+sdlquake_DEPENDENCIES = 
+sdlquake_LDFLAGS = 
+CFLAGS = @CFLAGS@
+COMPILE = $(CC) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(LDFLAGS) -o $@
+DIST_COMMON =  COPYING Makefile.am Makefile.in acinclude.m4 aclocal.m4 \
+config.guess config.sub configure configure.in install-sh missing \
+mkinstalldirs
+
+
+DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)
+
+TAR = gtar
+GZIP_ENV = --best
+SOURCES = $(sdlquake_SOURCES)
+OBJECTS = $(sdlquake_OBJECTS)
+
+all: all-redirect
+.SUFFIXES:
+.SUFFIXES: .S .c .o .s
+$(srcdir)/Makefile.in: Makefile.am $(top_srcdir)/configure.in $(ACLOCAL_M4) 
+	cd $(top_srcdir) && $(AUTOMAKE) --foreign --include-deps Makefile
+
+Makefile: $(srcdir)/Makefile.in  $(top_builddir)/config.status
+	cd $(top_builddir) \
+	  && CONFIG_FILES=$@ CONFIG_HEADERS= $(SHELL) ./config.status
+
+$(ACLOCAL_M4):  configure.in  acinclude.m4
+	cd $(srcdir) && $(ACLOCAL)
+
+config.status: $(srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	$(SHELL) ./config.status --recheck
+$(srcdir)/configure: $(srcdir)/configure.in $(ACLOCAL_M4) $(CONFIGURE_DEPENDENCIES)
+	cd $(srcdir) && $(AUTOCONF)
+
+mostlyclean-binPROGRAMS:
+
+clean-binPROGRAMS:
+	-test -z "$(bin_PROGRAMS)" || rm -f $(bin_PROGRAMS)
+
+distclean-binPROGRAMS:
+
+maintainer-clean-binPROGRAMS:
+
+install-binPROGRAMS: $(bin_PROGRAMS)
+	@$(NORMAL_INSTALL)
+	$(mkinstalldirs) $(DESTDIR)$(bindir)
+	@list='$(bin_PROGRAMS)'; for p in $$list; do \
+	  if test -f $$p; then \
+	    echo "  $(INSTALL_PROGRAM) $$p $(DESTDIR)$(bindir)/`echo $$p|sed 's/$(EXEEXT)$$//'|sed '$(transform)'|sed 's/$$/$(EXEEXT)/'`"; \
+	     $(INSTALL_PROGRAM) $$p $(DESTDIR)$(bindir)/`echo $$p|sed 's/$(EXEEXT)$$//'|sed '$(transform)'|sed 's/$$/$(EXEEXT)/'`; \
+	  else :; fi; \
+	done
+
+uninstall-binPROGRAMS:
+	@$(NORMAL_UNINSTALL)
+	list='$(bin_PROGRAMS)'; for p in $$list; do \
+	  rm -f $(DESTDIR)$(bindir)/`echo $$p|sed 's/$(EXEEXT)$$//'|sed '$(transform)'|sed 's/$$/$(EXEEXT)/'`; \
+	done
+
+.c.o:
+	$(COMPILE) -c $<
+
+.s.o:
+	$(COMPILE) -c $<
+
+.S.o:
+	$(COMPILE) -c $<
+
+mostlyclean-compile:
+	-rm -f *.o core *.core
+
+clean-compile:
+
+distclean-compile:
+	-rm -f *.tab.c
+
+maintainer-clean-compile:
+
+sdlquake: $(sdlquake_OBJECTS) $(sdlquake_DEPENDENCIES)
+	@rm -f sdlquake
+	$(LINK) $(sdlquake_LDFLAGS) $(sdlquake_OBJECTS) $(sdlquake_LDADD) $(LIBS)
+
+tags: TAGS
+
+ID: $(HEADERS) $(SOURCES) $(LISP)
+	list='$(SOURCES) $(HEADERS)'; \
+	unique=`for i in $$list; do echo $$i; done | \
+	  awk '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	here=`pwd` && cd $(srcdir) \
+	  && mkid -f$$here/ID $$unique $(LISP)
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)'; \
+	unique=`for i in $$list; do echo $$i; done | \
+	  awk '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(ETAGS_ARGS)$$unique$(LISP)$$tags" \
+	  || (cd $(srcdir) && etags $(ETAGS_ARGS) $$tags  $$unique $(LISP) -o $$here/TAGS)
+
+mostlyclean-tags:
+
+clean-tags:
+
+distclean-tags:
+	-rm -f TAGS ID
+
+maintainer-clean-tags:
+
+distdir = $(PACKAGE)-$(VERSION)
+top_distdir = $(distdir)
+
+# This target untars the dist file and tries a VPATH configuration.  Then
+# it guarantees that the distribution is self-contained by making another
+# tarfile.
+distcheck: dist
+	-rm -rf $(distdir)
+	GZIP=$(GZIP_ENV) $(TAR) zxf $(distdir).tar.gz
+	mkdir $(distdir)/=build
+	mkdir $(distdir)/=inst
+	dc_install_base=`cd $(distdir)/=inst && pwd`; \
+	cd $(distdir)/=build \
+	  && ../configure --srcdir=.. --prefix=$$dc_install_base \
+	  && $(MAKE) $(AM_MAKEFLAGS) \
+	  && $(MAKE) $(AM_MAKEFLAGS) dvi \
+	  && $(MAKE) $(AM_MAKEFLAGS) check \
+	  && $(MAKE) $(AM_MAKEFLAGS) install \
+	  && $(MAKE) $(AM_MAKEFLAGS) installcheck \
+	  && $(MAKE) $(AM_MAKEFLAGS) dist
+	-rm -rf $(distdir)
+	@banner="$(distdir).tar.gz is ready for distribution"; \
+	dashes=`echo "$$banner" | sed s/./=/g`; \
+	echo "$$dashes"; \
+	echo "$$banner"; \
+	echo "$$dashes"
+dist: distdir
+	-chmod -R a+r $(distdir)
+	GZIP=$(GZIP_ENV) $(TAR) chozf $(distdir).tar.gz $(distdir)
+	-rm -rf $(distdir)
+dist-all: distdir
+	-chmod -R a+r $(distdir)
+	GZIP=$(GZIP_ENV) $(TAR) chozf $(distdir).tar.gz $(distdir)
+	-rm -rf $(distdir)
+distdir: $(DISTFILES)
+	-rm -rf $(distdir)
+	mkdir $(distdir)
+	-chmod 777 $(distdir)
+	@for file in $(DISTFILES); do \
+	  d=$(srcdir); \
+	  if test -d $$d/$$file; then \
+	    cp -pr $$/$$file $(distdir)/$$file; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || ln $$d/$$file $(distdir)/$$file 2> /dev/null \
+	    || cp -p $$d/$$file $(distdir)/$$file || :; \
+	  fi; \
+	done
+	$(MAKE) $(AM_MAKEFLAGS) top_distdir="$(top_distdir)" distdir="$(distdir)" dist-hook
+cd_sdl.o: cd_sdl.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h
+chase.o: chase.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h
+cl_demo.o: cl_demo.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h
+cl_input.o: cl_input.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h
+cl_main.o: cl_main.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h
+cl_parse.o: cl_parse.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h
+cl_tent.o: cl_tent.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h
+cmd.o: cmd.c quakedef.h common.h bspfile.h vid.h sys.h zone.h mathlib.h \
+	wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h sbar.h \
+	sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h
+common.o: common.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h
+console.o: console.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h
+crc.o: crc.c quakedef.h common.h bspfile.h vid.h sys.h zone.h mathlib.h \
+	wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h sbar.h \
+	sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h
+cvar.o: cvar.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h
+d_edge.o: d_edge.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h \
+	d_local.h r_shared.h
+d_fill.o: d_fill.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h
+d_init.o: d_init.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h \
+	d_local.h r_shared.h
+d_modech.o: d_modech.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h \
+	d_local.h r_shared.h
+d_part.o: d_part.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h \
+	d_local.h r_shared.h
+d_polyse.o: d_polyse.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h \
+	r_local.h r_shared.h d_local.h adivtab.h
+draw.o: draw.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h
+d_scan.o: d_scan.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h \
+	r_local.h r_shared.h d_local.h
+d_sky.o: d_sky.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h \
+	r_local.h r_shared.h d_local.h
+d_sprite.o: d_sprite.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h \
+	d_local.h r_shared.h
+d_surf.o: d_surf.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h \
+	d_local.h r_shared.h r_local.h
+d_vars.o: d_vars.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h
+d_zpoint.o: d_zpoint.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h \
+	d_local.h r_shared.h
+host_cmd.o: host_cmd.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h
+host.o: host.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h \
+	r_local.h r_shared.h
+keys.o: keys.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h
+mathlib.o: mathlib.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h
+menu.o: menu.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h
+model.o: model.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h \
+	r_local.h r_shared.h
+net_bsd.o: net_bsd.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h \
+	net_loop.h net_dgrm.h net_udp.h
+net_dgrm.o: net_dgrm.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h \
+	net_dgrm.h
+net_loop.o: net_loop.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h \
+	net_loop.h
+net_main.o: net_main.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h \
+	net_vcr.h
+net_udp.o: net_udp.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h \
+	net_udp.h
+net_vcr.o: net_vcr.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h \
+	net_vcr.h
+net_wso.o: net_wso.c
+nonintel.o: nonintel.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h \
+	r_local.h r_shared.h d_local.h
+pr_cmds.o: pr_cmds.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h
+pr_edict.o: pr_edict.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h
+pr_exec.o: pr_exec.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h
+r_aclip.o: r_aclip.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h \
+	r_local.h r_shared.h d_local.h
+r_alias.o: r_alias.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h \
+	r_local.h r_shared.h d_local.h anorms.h
+r_bsp.o: r_bsp.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h \
+	r_local.h r_shared.h
+r_draw.o: r_draw.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h \
+	r_local.h r_shared.h d_local.h
+r_edge.o: r_edge.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h \
+	r_local.h r_shared.h
+r_efrag.o: r_efrag.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h \
+	r_local.h r_shared.h
+r_light.o: r_light.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h \
+	r_local.h r_shared.h
+r_main.o: r_main.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h \
+	r_local.h r_shared.h
+r_misc.o: r_misc.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h \
+	r_local.h r_shared.h
+r_part.o: r_part.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h \
+	r_local.h r_shared.h
+r_sky.o: r_sky.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h \
+	r_local.h r_shared.h d_local.h
+r_sprite.o: r_sprite.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h \
+	r_local.h r_shared.h
+r_surf.o: r_surf.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h \
+	r_local.h r_shared.h
+r_vars.o: r_vars.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h
+sbar.o: sbar.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h
+screen.o: screen.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h \
+	r_local.h r_shared.h
+snd_dma.o: snd_dma.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h
+snd_mem.o: snd_mem.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h
+snd_mix.o: snd_mix.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h
+snd_sdl.o: snd_sdl.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h
+sv_main.o: sv_main.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h
+sv_move.o: sv_move.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h
+sv_phys.o: sv_phys.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h
+sv_user.o: sv_user.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h
+sys_sdl.o: sys_sdl.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h
+vid_sdl.o: vid_sdl.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h \
+	d_local.h r_shared.h
+view.o: view.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h \
+	r_local.h r_shared.h
+wad.o: wad.c quakedef.h common.h bspfile.h vid.h sys.h zone.h mathlib.h \
+	wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h sbar.h \
+	sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h
+world.o: world.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h
+zone.o: zone.c quakedef.h common.h bspfile.h vid.h sys.h zone.h \
+	mathlib.h wad.h draw.h cvar.h screen.h net.h protocol.h cmd.h \
+	sbar.h sound.h render.h client.h progs.h pr_comp.h progdefs.h \
+	progdefs.q1 server.h model.h modelgen.h spritegn.h d_iface.h \
+	input.h world.h keys.h console.h view.h menu.h crc.h cdaudio.h
+
+info-am:
+info: info-am
+dvi-am:
+dvi: dvi-am
+check-am: all-am
+check: check-am
+installcheck-am:
+installcheck: installcheck-am
+install-exec-am: install-binPROGRAMS
+install-exec: install-exec-am
+
+install-data-am:
+install-data: install-data-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+install: install-am
+uninstall-am: uninstall-binPROGRAMS
+uninstall: uninstall-am
+all-am: Makefile $(PROGRAMS)
+all-redirect: all-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) AM_INSTALL_PROGRAM_FLAGS=-s install
+installdirs:
+	$(mkinstalldirs)  $(DESTDIR)$(bindir)
+
+
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f config.cache config.log stamp-h stamp-h[0-9]*
+
+maintainer-clean-generic:
+mostlyclean-am:  mostlyclean-binPROGRAMS mostlyclean-compile \
+		mostlyclean-tags mostlyclean-generic
+
+mostlyclean: mostlyclean-am
+
+clean-am:  clean-binPROGRAMS clean-compile clean-tags clean-generic \
+		mostlyclean-am
+
+clean: clean-am
+
+distclean-am:  distclean-binPROGRAMS distclean-compile distclean-tags \
+		distclean-generic clean-am
+
+distclean: distclean-am
+	-rm -f config.status
+
+maintainer-clean-am:  maintainer-clean-binPROGRAMS \
+		maintainer-clean-compile maintainer-clean-tags \
+		maintainer-clean-generic distclean-am
+	@echo "This command is intended for maintainers to use;"
+	@echo "it deletes files that may require special tools to rebuild."
+
+maintainer-clean: maintainer-clean-am
+	-rm -f config.status
+
+.PHONY: mostlyclean-binPROGRAMS distclean-binPROGRAMS clean-binPROGRAMS \
+maintainer-clean-binPROGRAMS uninstall-binPROGRAMS install-binPROGRAMS \
+mostlyclean-compile distclean-compile clean-compile \
+maintainer-clean-compile tags mostlyclean-tags distclean-tags \
+clean-tags maintainer-clean-tags distdir info-am info dvi-am dvi check \
+check-am installcheck-am installcheck install-exec-am install-exec \
+install-data-am install-data install-am install uninstall-am uninstall \
+all-redirect all-am all installdirs mostlyclean-generic \
+distclean-generic clean-generic maintainer-clean-generic clean \
+mostlyclean distclean maintainer-clean
+
+
+dist-hook:
+	cp -rp data docs dxsdk gas2masm kit scitech $(distdir)/
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -ruN WinQuake/Makefile.linuxi386 sdlquake-1.0.9/Makefile.linuxi386
--- WinQuake/Makefile.linuxi386	Tue Apr 27 17:51:18 1999
+++ sdlquake-1.0.9/Makefile.linuxi386	Sat Dec 25 04:38:20 1999
@@ -25,7 +25,8 @@
 endif
 NOARCH=noarch
 
-MOUNT_DIR=/grog/Projects/WinQuake
+#MOUNT_DIR=/grog/Projects/WinQuake
+MOUNT_DIR := $(shell pwd)
 MASTER_DIR=/grog/Projects/QuakeMaster
 MESA_DIR=/usr/local/src/Mesa-2.6
 TDFXGL_DIR = /home/zoid/3dfxgl
@@ -33,8 +34,8 @@
 BUILD_DEBUG_DIR=debug$(ARCH)$(GLIBC)
 BUILD_RELEASE_DIR=release$(ARCH)$(GLIBC)
 
-EGCS=/usr/local/egcs-1.1.2/bin/gcc
-CC=$(EGCS)
+#EGCS=/usr/local/egcs-1.1.2/bin/gcc
+#CC=$(EGCS)
 
 BASE_CFLAGS=-Dstricmp=strcasecmp
 RELEASE_CFLAGS=$(BASE_CFLAGS) -g -mpentiumpro -O6 -ffast-math -funroll-loops \
@@ -57,18 +58,19 @@
 DO_X11_CC=$(CC) $(CFLAGS) $(XCFLAGS) -o $@ -c $<
 DO_X11_DEBUG_CC=$(CC) $(DEBUG_CFLAGS) $(XCFLAGS) -o $@ -c $<
 DO_O_CC=$(CC) -O $(CFLAGS) -o $@ -c $<
-DO_AS=$(CC) $(CFLAGS) -DELF -x assembler-with-cpp -o $@ -c $<
+#DO_AS=$(CC) $(CFLAGS) -DELF -x assembler-with-cpp -o $@ -c $<
+DO_AS=$(CC) $(CFLAGS) -DELF -o $@ -c $<
 DO_GL_AS=$(CC) $(CFLAGS) $(GLCFLAGS) -DELF -x assembler-with-cpp -o $@ -c $<
 
 #############################################################################
 # SETUP AND BUILD
 #############################################################################
 
-TARGETS=$(BUILDDIR)/bin/squake \
+TARGETS=$(BUILDDIR)/bin/quake.x11\
+	$(BUILDDIR)/bin/squake \
 	$(BUILDDIR)/bin/glquake \
 	$(BUILDDIR)/bin/glquake.glx \
 	$(BUILDDIR)/bin/glquake.3dfxgl \
-	$(BUILDDIR)/bin/quake.x11
 	# $(BUILDDIR)/bin/unixded
 
 build_debug:
@@ -410,61 +412,61 @@
 
 #####
 
-$(BUILDDIR)/squake/d_copy.o :   $(MOUNT_DIR)/d_copy.s
+$(BUILDDIR)/squake/d_copy.o :   $(MOUNT_DIR)/d_copy.S
 	$(DO_AS)
 
-$(BUILDDIR)/squake/d_draw.o :   $(MOUNT_DIR)/d_draw.s
+$(BUILDDIR)/squake/d_draw.o :   $(MOUNT_DIR)/d_draw.S
 	$(DO_AS)
 
-$(BUILDDIR)/squake/d_draw16.o : $(MOUNT_DIR)/d_draw16.s
+$(BUILDDIR)/squake/d_draw16.o : $(MOUNT_DIR)/d_draw16.S
 	$(DO_AS)
 
-$(BUILDDIR)/squake/d_parta.o :  $(MOUNT_DIR)/d_parta.s
+$(BUILDDIR)/squake/d_parta.o :  $(MOUNT_DIR)/d_parta.S
 	$(DO_AS)
 
-$(BUILDDIR)/squake/d_polysa.o : $(MOUNT_DIR)/d_polysa.s
+$(BUILDDIR)/squake/d_polysa.o : $(MOUNT_DIR)/d_polysa.S
 	$(DO_AS)
 
-$(BUILDDIR)/squake/d_scana.o :  $(MOUNT_DIR)/d_scana.s
+$(BUILDDIR)/squake/d_scana.o :  $(MOUNT_DIR)/d_scana.S
 	$(DO_AS)
 
-$(BUILDDIR)/squake/d_spr8.o :   $(MOUNT_DIR)/d_spr8.s
+$(BUILDDIR)/squake/d_spr8.o :   $(MOUNT_DIR)/d_spr8.S
 	$(DO_AS)
 
-$(BUILDDIR)/squake/d_varsa.o :  $(MOUNT_DIR)/d_varsa.s
+$(BUILDDIR)/squake/d_varsa.o :  $(MOUNT_DIR)/d_varsa.S
 	$(DO_AS)
 
-$(BUILDDIR)/squake/math.o :     $(MOUNT_DIR)/math.s
+$(BUILDDIR)/squake/math.o :     $(MOUNT_DIR)/math.S
 	$(DO_AS)
 
-$(BUILDDIR)/squake/r_aliasa.o : $(MOUNT_DIR)/r_aliasa.s
+$(BUILDDIR)/squake/r_aliasa.o : $(MOUNT_DIR)/r_aliasa.S
 	$(DO_AS)
 
-$(BUILDDIR)/squake/r_drawa.o :  $(MOUNT_DIR)/r_drawa.s
+$(BUILDDIR)/squake/r_drawa.o :  $(MOUNT_DIR)/r_drawa.S
 	$(DO_AS)
 
-$(BUILDDIR)/squake/r_edgea.o :  $(MOUNT_DIR)/r_edgea.s
+$(BUILDDIR)/squake/r_edgea.o :  $(MOUNT_DIR)/r_edgea.S
 	$(DO_AS)
 
-$(BUILDDIR)/squake/r_varsa.o :  $(MOUNT_DIR)/r_varsa.s
+$(BUILDDIR)/squake/r_varsa.o :  $(MOUNT_DIR)/r_varsa.S
 	$(DO_AS)
 
-$(BUILDDIR)/squake/surf16.o :   $(MOUNT_DIR)/surf16.s
+$(BUILDDIR)/squake/surf16.o :   $(MOUNT_DIR)/surf16.S
 	$(DO_AS)
 
-$(BUILDDIR)/squake/surf8.o :    $(MOUNT_DIR)/surf8.s
+$(BUILDDIR)/squake/surf8.o :    $(MOUNT_DIR)/surf8.S
 	$(DO_AS)
 
-$(BUILDDIR)/squake/worlda.o :   $(MOUNT_DIR)/worlda.s
+$(BUILDDIR)/squake/worlda.o :   $(MOUNT_DIR)/worlda.S
 	$(DO_AS)
 
-$(BUILDDIR)/squake/r_aclipa.o : $(MOUNT_DIR)/r_aclipa.s
+$(BUILDDIR)/squake/r_aclipa.o : $(MOUNT_DIR)/r_aclipa.S
 	$(DO_AS)
 
-$(BUILDDIR)/squake/snd_mixa.o : $(MOUNT_DIR)/snd_mixa.s
+$(BUILDDIR)/squake/snd_mixa.o : $(MOUNT_DIR)/snd_mixa.S
 	$(DO_AS)
 
-$(BUILDDIR)/squake/sys_dosa.o : $(MOUNT_DIR)/sys_dosa.s
+$(BUILDDIR)/squake/sys_dosa.o : $(MOUNT_DIR)/sys_dosa.S
 	$(DO_AS)
 
 #############################################################################
@@ -783,61 +785,61 @@
 
 #####
 
-$(BUILDDIR)/x11/d_copy.o :   $(MOUNT_DIR)/d_copy.s
+$(BUILDDIR)/x11/d_copy.o :   $(MOUNT_DIR)/d_copy.S
 	$(DO_AS)
 
-$(BUILDDIR)/x11/d_draw.o :   $(MOUNT_DIR)/d_draw.s
+$(BUILDDIR)/x11/d_draw.o :   $(MOUNT_DIR)/d_draw.S
 	$(DO_AS)
 
-$(BUILDDIR)/x11/d_draw16.o : $(MOUNT_DIR)/d_draw16.s
+$(BUILDDIR)/x11/d_draw16.o : $(MOUNT_DIR)/d_draw16.S
 	$(DO_AS)
 
-$(BUILDDIR)/x11/d_parta.o :  $(MOUNT_DIR)/d_parta.s
+$(BUILDDIR)/x11/d_parta.o :  $(MOUNT_DIR)/d_parta.S
 	$(DO_AS)
 
-$(BUILDDIR)/x11/d_polysa.o : $(MOUNT_DIR)/d_polysa.s
+$(BUILDDIR)/x11/d_polysa.o : $(MOUNT_DIR)/d_polysa.S
 	$(DO_AS)
 
-$(BUILDDIR)/x11/d_scana.o :  $(MOUNT_DIR)/d_scana.s
+$(BUILDDIR)/x11/d_scana.o :  $(MOUNT_DIR)/d_scana.S
 	$(DO_AS)
 
-$(BUILDDIR)/x11/d_spr8.o :   $(MOUNT_DIR)/d_spr8.s
+$(BUILDDIR)/x11/d_spr8.o :   $(MOUNT_DIR)/d_spr8.S
 	$(DO_AS)
 
-$(BUILDDIR)/x11/d_varsa.o :  $(MOUNT_DIR)/d_varsa.s
+$(BUILDDIR)/x11/d_varsa.o :  $(MOUNT_DIR)/d_varsa.S
 	$(DO_AS)
 
-$(BUILDDIR)/x11/math.o :     $(MOUNT_DIR)/math.s
+$(BUILDDIR)/x11/math.o :     $(MOUNT_DIR)/math.S
 	$(DO_AS)
 
-$(BUILDDIR)/x11/r_aliasa.o : $(MOUNT_DIR)/r_aliasa.s
+$(BUILDDIR)/x11/r_aliasa.o : $(MOUNT_DIR)/r_aliasa.S
 	$(DO_AS)
 
-$(BUILDDIR)/x11/r_drawa.o :  $(MOUNT_DIR)/r_drawa.s
+$(BUILDDIR)/x11/r_drawa.o :  $(MOUNT_DIR)/r_drawa.S
 	$(DO_AS)
 
-$(BUILDDIR)/x11/r_edgea.o :  $(MOUNT_DIR)/r_edgea.s
+$(BUILDDIR)/x11/r_edgea.o :  $(MOUNT_DIR)/r_edgea.S
 	$(DO_AS)
 
-$(BUILDDIR)/x11/r_varsa.o :  $(MOUNT_DIR)/r_varsa.s
+$(BUILDDIR)/x11/r_varsa.o :  $(MOUNT_DIR)/r_varsa.S
 	$(DO_AS)
 
-$(BUILDDIR)/x11/surf16.o :   $(MOUNT_DIR)/surf16.s
+$(BUILDDIR)/x11/surf16.o :   $(MOUNT_DIR)/surf16.S
 	$(DO_AS)
 
-$(BUILDDIR)/x11/surf8.o :    $(MOUNT_DIR)/surf8.s
+$(BUILDDIR)/x11/surf8.o :    $(MOUNT_DIR)/surf8.S
 	$(DO_AS)
 
-$(BUILDDIR)/x11/worlda.o :   $(MOUNT_DIR)/worlda.s
+$(BUILDDIR)/x11/worlda.o :   $(MOUNT_DIR)/worlda.S
 	$(DO_AS)
 
-$(BUILDDIR)/x11/r_aclipa.o : $(MOUNT_DIR)/r_aclipa.s
+$(BUILDDIR)/x11/r_aclipa.o : $(MOUNT_DIR)/r_aclipa.S
 	$(DO_AS)
 
-$(BUILDDIR)/x11/snd_mixa.o : $(MOUNT_DIR)/snd_mixa.s
+$(BUILDDIR)/x11/snd_mixa.o : $(MOUNT_DIR)/snd_mixa.S
 	$(DO_AS)
 
-$(BUILDDIR)/x11/sys_dosa.o : $(MOUNT_DIR)/sys_dosa.s
+$(BUILDDIR)/x11/sys_dosa.o : $(MOUNT_DIR)/sys_dosa.S
 	$(DO_AS)
 
 #############################################################################
@@ -1080,16 +1082,16 @@
 $(BUILDDIR)/glquake/snd_linux.o :    $(MOUNT_DIR)/snd_linux.c
 	$(DO_GL_CC)
 
-$(BUILDDIR)/glquake/math.o :         $(MOUNT_DIR)/math.s
+$(BUILDDIR)/glquake/math.o :         $(MOUNT_DIR)/math.S
 	$(DO_GL_AS)
 
-$(BUILDDIR)/glquake/worlda.o :       $(MOUNT_DIR)/worlda.s
+$(BUILDDIR)/glquake/worlda.o :       $(MOUNT_DIR)/worlda.S
 	$(DO_GL_AS)
 
-$(BUILDDIR)/glquake/snd_mixa.o :     $(MOUNT_DIR)/snd_mixa.s
+$(BUILDDIR)/glquake/snd_mixa.o :     $(MOUNT_DIR)/snd_mixa.S
 	$(DO_GL_AS)
 
-$(BUILDDIR)/glquake/sys_dosa.o :     $(MOUNT_DIR)/sys_dosa.s
+$(BUILDDIR)/glquake/sys_dosa.o :     $(MOUNT_DIR)/sys_dosa.S
 	$(DO_GL_AS)
 
 #############################################################################
diff -ruN WinQuake/README.SDL sdlquake-1.0.9/README.SDL
--- WinQuake/README.SDL	Wed Dec 31 16:00:00 1969
+++ sdlquake-1.0.9/README.SDL	Sat Dec 25 04:35:06 1999
@@ -0,0 +1,34 @@
+
+This is a quick hack of Quake ported to the Simple DirectMedia Layer library.
+http://www.devolution.com/~slouken/SDL/
+
+To build under Linux, simply run ./configure; make
+
+This game requires the original Quake datafiles.  You can get the shareware
+data files from http://www.idsoftware.com/.
+
+Of interest in the original X sources is the following:
+	// Duff's Device
+	count = width;
+	n = (count + 7) / 8;
+	dest = ((PIXEL16 *)src) + x+width - 1;
+	src += x+width - 1;
+
+	switch (count % 8) {
+	case 0:	do {	*dest-- = st2d_8to16table[*src--];
+	case 7:		*dest-- = st2d_8to16table[*src--];
+	case 6:		*dest-- = st2d_8to16table[*src--];
+	case 5:		*dest-- = st2d_8to16table[*src--];
+	case 4:		*dest-- = st2d_8to16table[*src--];
+	case 3:		*dest-- = st2d_8to16table[*src--];
+	case 2:		*dest-- = st2d_8to16table[*src--];
+	case 1:		*dest-- = st2d_8to16table[*src--];
+		} while (--n > 0);
+	}
+This idea may make it into the SDL blitters if it turns out to be faster
+than my current code. :)
+
+Thanks to Zoid, Dave Taylor, John Carmack, and everyone else involved in the
+open source release of id games. :)
+
+- Sam Lantinga (slouken@devolution.com) 12/25/1999
diff -ruN WinQuake/acinclude.m4 sdlquake-1.0.9/acinclude.m4
--- WinQuake/acinclude.m4	Wed Dec 31 16:00:00 1969
+++ sdlquake-1.0.9/acinclude.m4	Sat Dec 25 03:38:02 1999
@@ -0,0 +1,165 @@
+# Configure paths for SDL
+# Sam Lantinga 9/21/99
+# stolen from Manish Singh
+# stolen back from Frank Belew
+# stolen from Manish Singh
+# Shamelessly stolen from Owen Taylor
+
+dnl AM_PATH_SDL([MINIMUM-VERSION, [ACTION-IF-FOUND [, ACTION-IF-NOT-FOUND]]])
+dnl Test for SDL, and define SDL_CFLAGS and SDL_LIBS
+dnl
+AC_DEFUN(AM_PATH_SDL,
+[dnl 
+dnl Get the cflags and libraries from the sdl-config script
+dnl
+AC_ARG_WITH(sdl-prefix,[  --with-sdl-prefix=PFX   Prefix where SDL is installed (optional)],
+            sdl_prefix="$withval", sdl_prefix="")
+AC_ARG_WITH(sdl-exec-prefix,[  --with-sdl-exec-prefix=PFX Exec prefix where SDL is installed (optional)],
+            sdl_exec_prefix="$withval", sdl_exec_prefix="")
+AC_ARG_ENABLE(sdltest, [  --disable-sdltest       Do not try to compile and run a test SDL program],
+		    , enable_sdltest=yes)
+
+  if test x$sdl_exec_prefix != x ; then
+     sdl_args="$sdl_args --exec-prefix=$sdl_exec_prefix"
+     if test x${SDL_CONFIG+set} != xset ; then
+        SDL_CONFIG=$sdl_exec_prefix/bin/sdl-config
+     fi
+  fi
+  if test x$sdl_prefix != x ; then
+     sdl_args="$sdl_args --prefix=$sdl_prefix"
+     if test x${SDL_CONFIG+set} != xset ; then
+        SDL_CONFIG=$sdl_prefix/bin/sdl-config
+     fi
+  fi
+
+  AC_PATH_PROG(SDL_CONFIG, sdl-config, no)
+  min_sdl_version=ifelse([$1], ,0.11.0,$1)
+  AC_MSG_CHECKING(for SDL - version >= $min_sdl_version)
+  no_sdl=""
+  if test "$SDL_CONFIG" = "no" ; then
+    no_sdl=yes
+  else
+    SDL_CFLAGS=`$SDL_CONFIG $sdlconf_args --cflags`
+    SDL_LIBS=`$SDL_CONFIG $sdlconf_args --libs`
+
+    sdl_major_version=`$SDL_CONFIG $sdl_args --version | \
+           sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\1/'`
+    sdl_minor_version=`$SDL_CONFIG $sdl_args --version | \
+           sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\2/'`
+    sdl_micro_version=`$SDL_CONFIG $sdl_config_args --version | \
+           sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\3/'`
+    if test "x$enable_sdltest" = "xyes" ; then
+      ac_save_CFLAGS="$CFLAGS"
+      ac_save_LIBS="$LIBS"
+      CFLAGS="$CFLAGS $SDL_CFLAGS"
+      LIBS="$LIBS $SDL_LIBS"
+dnl
+dnl Now check if the installed SDL is sufficiently new. (Also sanity
+dnl checks the results of sdl-config to some extent
+dnl
+      rm -f conf.sdltest
+      AC_TRY_RUN([
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "SDL.h"
+
+char*
+my_strdup (char *str)
+{
+  char *new_str;
+  
+  if (str)
+    {
+      new_str = malloc ((strlen (str) + 1) * sizeof(char));
+      strcpy (new_str, str);
+    }
+  else
+    new_str = NULL;
+  
+  return new_str;
+}
+
+int main ()
+{
+  int major, minor, micro;
+  char *tmp_version;
+
+  system ("touch conf.sdltest");
+
+  /* HP/UX 9 (%@#!) writes to sscanf strings */
+  tmp_version = my_strdup("$min_sdl_version");
+  if (sscanf(tmp_version, "%d.%d.%d", &major, &minor, &micro) != 3) {
+     printf("%s, bad version string\n", "$min_sdl_version");
+     exit(1);
+   }
+
+   if (($sdl_major_version > major) ||
+      (($sdl_major_version == major) && ($sdl_minor_version > minor)) ||
+      (($sdl_major_version == major) && ($sdl_minor_version == minor) && ($sdl_micro_version >= micro)))
+    {
+      return 0;
+    }
+  else
+    {
+      printf("\n*** 'sdl-config --version' returned %d.%d.%d, but the minimum version\n", $sdl_major_version, $sdl_minor_version, $sdl_micro_version);
+      printf("*** of SDL required is %d.%d.%d. If sdl-config is correct, then it is\n", major, minor, micro);
+      printf("*** best to upgrade to the required version.\n");
+      printf("*** If sdl-config was wrong, set the environment variable SDL_CONFIG\n");
+      printf("*** to point to the correct copy of sdl-config, and remove the file\n");
+      printf("*** config.cache before re-running configure\n");
+      return 1;
+    }
+}
+
+],, no_sdl=yes,[echo $ac_n "cross compiling; assumed OK... $ac_c"])
+       CFLAGS="$ac_save_CFLAGS"
+       LIBS="$ac_save_LIBS"
+     fi
+  fi
+  if test "x$no_sdl" = x ; then
+     AC_MSG_RESULT(yes)
+     ifelse([$2], , :, [$2])     
+  else
+     AC_MSG_RESULT(no)
+     if test "$SDL_CONFIG" = "no" ; then
+       echo "*** The sdl-config script installed by SDL could not be found"
+       echo "*** If SDL was installed in PREFIX, make sure PREFIX/bin is in"
+       echo "*** your path, or set the SDL_CONFIG environment variable to the"
+       echo "*** full path to sdl-config."
+     else
+       if test -f conf.sdltest ; then
+        :
+       else
+          echo "*** Could not run SDL test program, checking why..."
+          CFLAGS="$CFLAGS $SDL_CFLAGS"
+          LIBS="$LIBS $SDL_LIBS"
+          AC_TRY_LINK([
+#include <stdio.h>
+#include "SDL.h"
+],      [ return 0; ],
+        [ echo "*** The test program compiled, but did not run. This usually means"
+          echo "*** that the run-time linker is not finding SDL or finding the wrong"
+          echo "*** version of SDL. If it is not finding SDL, you'll need to set your"
+          echo "*** LD_LIBRARY_PATH environment variable, or edit /etc/ld.so.conf to point"
+          echo "*** to the installed location  Also, make sure you have run ldconfig if that"
+          echo "*** is required on your system"
+	  echo "***"
+          echo "*** If you have an old version installed, it is best to remove it, although"
+          echo "*** you may also be able to get things to work by modifying LD_LIBRARY_PATH"],
+        [ echo "*** The test program failed to compile or link. See the file config.log for the"
+          echo "*** exact error that occured. This usually means SDL was incorrectly installed"
+          echo "*** or that you have moved SDL since it was installed. In the latter case, you"
+          echo "*** may want to edit the sdl-config script: $SDL_CONFIG" ])
+          CFLAGS="$ac_save_CFLAGS"
+          LIBS="$ac_save_LIBS"
+       fi
+     fi
+     SDL_CFLAGS=""
+     SDL_LIBS=""
+     ifelse([$3], , :, [$3])
+  fi
+  AC_SUBST(SDL_CFLAGS)
+  AC_SUBST(SDL_LIBS)
+  rm -f conf.sdltest
+])
diff -ruN WinQuake/aclocal.m4 sdlquake-1.0.9/aclocal.m4
--- WinQuake/aclocal.m4	Wed Dec 31 16:00:00 1969
+++ sdlquake-1.0.9/aclocal.m4	Tue Dec 28 10:54:24 1999
@@ -0,0 +1,270 @@
+dnl aclocal.m4 generated automatically by aclocal 1.4
+
+dnl Copyright (C) 1994, 1995-8, 1999 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl This program is distributed in the hope that it will be useful,
+dnl but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+dnl even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+dnl PARTICULAR PURPOSE.
+
+# Configure paths for SDL
+# Sam Lantinga 9/21/99
+# stolen from Manish Singh
+# stolen back from Frank Belew
+# stolen from Manish Singh
+# Shamelessly stolen from Owen Taylor
+
+dnl AM_PATH_SDL([MINIMUM-VERSION, [ACTION-IF-FOUND [, ACTION-IF-NOT-FOUND]]])
+dnl Test for SDL, and define SDL_CFLAGS and SDL_LIBS
+dnl
+AC_DEFUN(AM_PATH_SDL,
+[dnl 
+dnl Get the cflags and libraries from the sdl-config script
+dnl
+AC_ARG_WITH(sdl-prefix,[  --with-sdl-prefix=PFX   Prefix where SDL is installed (optional)],
+            sdl_prefix="$withval", sdl_prefix="")
+AC_ARG_WITH(sdl-exec-prefix,[  --with-sdl-exec-prefix=PFX Exec prefix where SDL is installed (optional)],
+            sdl_exec_prefix="$withval", sdl_exec_prefix="")
+AC_ARG_ENABLE(sdltest, [  --disable-sdltest       Do not try to compile and run a test SDL program],
+		    , enable_sdltest=yes)
+
+  if test x$sdl_exec_prefix != x ; then
+     sdl_args="$sdl_args --exec-prefix=$sdl_exec_prefix"
+     if test x${SDL_CONFIG+set} != xset ; then
+        SDL_CONFIG=$sdl_exec_prefix/bin/sdl-config
+     fi
+  fi
+  if test x$sdl_prefix != x ; then
+     sdl_args="$sdl_args --prefix=$sdl_prefix"
+     if test x${SDL_CONFIG+set} != xset ; then
+        SDL_CONFIG=$sdl_prefix/bin/sdl-config
+     fi
+  fi
+
+  AC_PATH_PROG(SDL_CONFIG, sdl-config, no)
+  min_sdl_version=ifelse([$1], ,0.11.0,$1)
+  AC_MSG_CHECKING(for SDL - version >= $min_sdl_version)
+  no_sdl=""
+  if test "$SDL_CONFIG" = "no" ; then
+    no_sdl=yes
+  else
+    SDL_CFLAGS=`$SDL_CONFIG $sdlconf_args --cflags`
+    SDL_LIBS=`$SDL_CONFIG $sdlconf_args --libs`
+
+    sdl_major_version=`$SDL_CONFIG $sdl_args --version | \
+           sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\1/'`
+    sdl_minor_version=`$SDL_CONFIG $sdl_args --version | \
+           sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\2/'`
+    sdl_micro_version=`$SDL_CONFIG $sdl_config_args --version | \
+           sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\3/'`
+    if test "x$enable_sdltest" = "xyes" ; then
+      ac_save_CFLAGS="$CFLAGS"
+      ac_save_LIBS="$LIBS"
+      CFLAGS="$CFLAGS $SDL_CFLAGS"
+      LIBS="$LIBS $SDL_LIBS"
+dnl
+dnl Now check if the installed SDL is sufficiently new. (Also sanity
+dnl checks the results of sdl-config to some extent
+dnl
+      rm -f conf.sdltest
+      AC_TRY_RUN([
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "SDL.h"
+
+char*
+my_strdup (char *str)
+{
+  char *new_str;
+  
+  if (str)
+    {
+      new_str = malloc ((strlen (str) + 1) * sizeof(char));
+      strcpy (new_str, str);
+    }
+  else
+    new_str = NULL;
+  
+  return new_str;
+}
+
+int main ()
+{
+  int major, minor, micro;
+  char *tmp_version;
+
+  system ("touch conf.sdltest");
+
+  /* HP/UX 9 (%@#!) writes to sscanf strings */
+  tmp_version = my_strdup("$min_sdl_version");
+  if (sscanf(tmp_version, "%d.%d.%d", &major, &minor, &micro) != 3) {
+     printf("%s, bad version string\n", "$min_sdl_version");
+     exit(1);
+   }
+
+   if (($sdl_major_version > major) ||
+      (($sdl_major_version == major) && ($sdl_minor_version > minor)) ||
+      (($sdl_major_version == major) && ($sdl_minor_version == minor) && ($sdl_micro_version >= micro)))
+    {
+      return 0;
+    }
+  else
+    {
+      printf("\n*** 'sdl-config --version' returned %d.%d.%d, but the minimum version\n", $sdl_major_version, $sdl_minor_version, $sdl_micro_version);
+      printf("*** of SDL required is %d.%d.%d. If sdl-config is correct, then it is\n", major, minor, micro);
+      printf("*** best to upgrade to the required version.\n");
+      printf("*** If sdl-config was wrong, set the environment variable SDL_CONFIG\n");
+      printf("*** to point to the correct copy of sdl-config, and remove the file\n");
+      printf("*** config.cache before re-running configure\n");
+      return 1;
+    }
+}
+
+],, no_sdl=yes,[echo $ac_n "cross compiling; assumed OK... $ac_c"])
+       CFLAGS="$ac_save_CFLAGS"
+       LIBS="$ac_save_LIBS"
+     fi
+  fi
+  if test "x$no_sdl" = x ; then
+     AC_MSG_RESULT(yes)
+     ifelse([$2], , :, [$2])     
+  else
+     AC_MSG_RESULT(no)
+     if test "$SDL_CONFIG" = "no" ; then
+       echo "*** The sdl-config script installed by SDL could not be found"
+       echo "*** If SDL was installed in PREFIX, make sure PREFIX/bin is in"
+       echo "*** your path, or set the SDL_CONFIG environment variable to the"
+       echo "*** full path to sdl-config."
+     else
+       if test -f conf.sdltest ; then
+        :
+       else
+          echo "*** Could not run SDL test program, checking why..."
+          CFLAGS="$CFLAGS $SDL_CFLAGS"
+          LIBS="$LIBS $SDL_LIBS"
+          AC_TRY_LINK([
+#include <stdio.h>
+#include "SDL.h"
+],      [ return 0; ],
+        [ echo "*** The test program compiled, but did not run. This usually means"
+          echo "*** that the run-time linker is not finding SDL or finding the wrong"
+          echo "*** version of SDL. If it is not finding SDL, you'll need to set your"
+          echo "*** LD_LIBRARY_PATH environment variable, or edit /etc/ld.so.conf to point"
+          echo "*** to the installed location  Also, make sure you have run ldconfig if that"
+          echo "*** is required on your system"
+	  echo "***"
+          echo "*** If you have an old version installed, it is best to remove it, although"
+          echo "*** you may also be able to get things to work by modifying LD_LIBRARY_PATH"],
+        [ echo "*** The test program failed to compile or link. See the file config.log for the"
+          echo "*** exact error that occured. This usually means SDL was incorrectly installed"
+          echo "*** or that you have moved SDL since it was installed. In the latter case, you"
+          echo "*** may want to edit the sdl-config script: $SDL_CONFIG" ])
+          CFLAGS="$ac_save_CFLAGS"
+          LIBS="$ac_save_LIBS"
+       fi
+     fi
+     SDL_CFLAGS=""
+     SDL_LIBS=""
+     ifelse([$3], , :, [$3])
+  fi
+  AC_SUBST(SDL_CFLAGS)
+  AC_SUBST(SDL_LIBS)
+  rm -f conf.sdltest
+])
+
+# Do all the work for Automake.  This macro actually does too much --
+# some checks are only needed if your package does certain things.
+# But this isn't really a big deal.
+
+# serial 1
+
+dnl Usage:
+dnl AM_INIT_AUTOMAKE(package,version, [no-define])
+
+AC_DEFUN(AM_INIT_AUTOMAKE,
+[AC_REQUIRE([AC_PROG_INSTALL])
+PACKAGE=[$1]
+AC_SUBST(PACKAGE)
+VERSION=[$2]
+AC_SUBST(VERSION)
+dnl test to see if srcdir already configured
+if test "`cd $srcdir && pwd`" != "`pwd`" && test -f $srcdir/config.status; then
+  AC_MSG_ERROR([source directory already configured; run "make distclean" there first])
+fi
+ifelse([$3],,
+AC_DEFINE_UNQUOTED(PACKAGE, "$PACKAGE", [Name of package])
+AC_DEFINE_UNQUOTED(VERSION, "$VERSION", [Version number of package]))
+AC_REQUIRE([AM_SANITY_CHECK])
+AC_REQUIRE([AC_ARG_PROGRAM])
+dnl FIXME This is truly gross.
+missing_dir=`cd $ac_aux_dir && pwd`
+AM_MISSING_PROG(ACLOCAL, aclocal, $missing_dir)
+AM_MISSING_PROG(AUTOCONF, autoconf, $missing_dir)
+AM_MISSING_PROG(AUTOMAKE, automake, $missing_dir)
+AM_MISSING_PROG(AUTOHEADER, autoheader, $missing_dir)
+AM_MISSING_PROG(MAKEINFO, makeinfo, $missing_dir)
+AC_REQUIRE([AC_PROG_MAKE_SET])])
+
+#
+# Check to make sure that the build environment is sane.
+#
+
+AC_DEFUN(AM_SANITY_CHECK,
+[AC_MSG_CHECKING([whether build environment is sane])
+# Just in case
+sleep 1
+echo timestamp > conftestfile
+# Do `set' in a subshell so we don't clobber the current shell's
+# arguments.  Must try -L first in case configure is actually a
+# symlink; some systems play weird games with the mod time of symlinks
+# (eg FreeBSD returns the mod time of the symlink's containing
+# directory).
+if (
+   set X `ls -Lt $srcdir/configure conftestfile 2> /dev/null`
+   if test "[$]*" = "X"; then
+      # -L didn't work.
+      set X `ls -t $srcdir/configure conftestfile`
+   fi
+   if test "[$]*" != "X $srcdir/configure conftestfile" \
+      && test "[$]*" != "X conftestfile $srcdir/configure"; then
+
+      # If neither matched, then we have a broken ls.  This can happen
+      # if, for instance, CONFIG_SHELL is bash and it inherits a
+      # broken ls alias from the environment.  This has actually
+      # happened.  Such a system could not be considered "sane".
+      AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken
+alias in your environment])
+   fi
+
+   test "[$]2" = conftestfile
+   )
+then
+   # Ok.
+   :
+else
+   AC_MSG_ERROR([newly created file is older than distributed files!
+Check your system clock])
+fi
+rm -f conftest*
+AC_MSG_RESULT(yes)])
+
+dnl AM_MISSING_PROG(NAME, PROGRAM, DIRECTORY)
+dnl The program must properly implement --version.
+AC_DEFUN(AM_MISSING_PROG,
+[AC_MSG_CHECKING(for working $2)
+# Run test in a subshell; some versions of sh will print an error if
+# an executable is not found, even if stderr is redirected.
+# Redirect stdin to placate older versions of autoconf.  Sigh.
+if ($2 --version) < /dev/null > /dev/null 2>&1; then
+   $1=$2
+   AC_MSG_RESULT(found)
+else
+   $1="$3/missing $2"
+   AC_MSG_RESULT(missing)
+fi
+AC_SUBST($1)])
+
diff -ruN WinQuake/cd_sdl.c sdlquake-1.0.9/cd_sdl.c
--- WinQuake/cd_sdl.c	Wed Dec 31 16:00:00 1969
+++ sdlquake-1.0.9/cd_sdl.c	Tue Dec 28 10:41:38 1999
@@ -0,0 +1,223 @@
+/*
+  Some of this may not work. I'm not overly familiar with SDL, I just sort
+  of podged this together from the SDL headers, and the other cd-rom code.
+
+  Mark Baker <homer1@together.net>
+*/
+
+#include <SDL.h>
+
+#include "quakedef.h"
+
+static qboolean cdValid = false;
+static qboolean initialized = false;
+static qboolean enabled = true;
+static qboolean playLooping = false;
+static SDL_CD *cd_id;
+static float cdvolume = 1.0;
+
+static void CD_f();
+
+static void CDAudio_Eject()
+{
+	if(!cd_id || !enabled) return;
+
+	if(SDL_CDEject(cd_id))
+		Con_DPrintf("Unable to eject CD-ROM tray.\n");
+}
+
+void CDAudio_Play(byte track, qboolean looping)
+{
+	CDstatus cd_stat;
+	if(!cd_id || !enabled) return;
+	
+	if(!cdValid)
+	{
+		if(!CD_INDRIVE(cd_stat=SDL_CDStatus(cd_id)) ||(!cd_id->numtracks)) return;
+		cdValid = true;
+	}
+
+	if((track < 1) || (track >= cd_id->numtracks))
+	{
+		Con_DPrintf("CDAudio: Bad track number: %d\n",track);
+		return;
+	}
+	track--; /* Convert track from person to SDL value */
+	if(cd_stat == CD_PLAYING)
+	{
+		if(cd_id->cur_track == track) return;
+		CDAudio_Stop();
+	}
+
+	if(SDL_CDPlay(cd_id,cd_id->track[track].offset,
+			  cd_id->track[track].length))
+	{
+		Con_DPrintf("CDAudio_Play: Unable to play track: %d\n",track+1);
+		return;
+	}
+	playLooping = looping;
+}
+
+
+void CDAudio_Stop()
+{
+	int cdstate;
+	if(!cd_id || !enabled) return;
+	cdstate = SDL_CDStatus(cd_id);
+	if((cdstate != CD_PLAYING) && (cdstate != CD_PAUSED)) return;
+
+	if(SDL_CDStop(cd_id))
+		Con_DPrintf("CDAudio_Stop: Failed to stop track.\n");
+}
+
+void CDAudio_Pause()
+{
+	if(!cd_id || !enabled) return;
+	if(SDL_CDStatus(cd_id) != CD_PLAYING) return;
+
+	if(SDL_CDPause(cd_id))
+		Con_DPrintf("CDAudio_Pause: Failed to pause track.\n");
+}
+
+
+void CDAudio_Resume()
+{
+	if(!cd_id || !enabled) return;
+	if(SDL_CDStatus(cd_id) != CD_PAUSED) return;
+
+	if(SDL_CDResume(cd_id))
+		Con_DPrintf("CDAudio_Resume: Failed tp resume track.\n");
+}
+
+void CDAudio_Update()
+{
+	if(!cd_id || !enabled) return;
+	if(bgmvolume.value != cdvolume)
+	{
+		if(cdvolume)
+		{
+			Cvar_SetValue("bgmvolume",0.0);
+			CDAudio_Pause();
+		}
+		else
+		{
+			Cvar_SetValue("bgmvolume",1.0);
+			CDAudio_Resume();
+		}
+		cdvolume = bgmvolume.value;
+		return;
+	}
+	if(playLooping && (SDL_CDStatus(cd_id) != CD_PLAYING)
+		 && (SDL_CDStatus(cd_id) != CD_PAUSED))
+		CDAudio_Play(cd_id->cur_track+1,true);
+}
+
+int CDAudio_Init()
+{
+	if((cls.state == ca_dedicated) || COM_CheckParm("-nocdaudio"))
+		return -1;
+		
+	cd_id = SDL_CDOpen(0);
+	if(!cd_id)
+	{
+		Con_Printf("CDAudio_Init: Unable to open default CD-ROM drive: %s\n",
+			SDL_GetError());
+		return -1;
+	}
+	
+	initialized = true;
+	enabled = true;
+	cdValid = true;
+	
+	if(!CD_INDRIVE(SDL_CDStatus(cd_id)))
+	{
+		Con_Printf("CDAudio_Init: No CD in drive.\n");
+		cdValid = false;
+	}
+	if(!cd_id->numtracks)
+	{
+		Con_Printf("CDAudio_Init: CD contains no audio tracks.\n");
+		cdValid = false;
+	}
+	Cmd_AddCommand("cd",CD_f);
+	Con_Printf("CD Audio Initialized.\n");
+	return 0;
+}
+
+
+void CDAudio_Shutdown()
+{
+	if(!cd_id) return;
+	CDAudio_Stop();
+	SDL_CDClose(cd_id);
+	cd_id = NULL;
+}
+
+static void CD_f()
+{
+	char *command;
+	int cdstate;
+	if(Cmd_Argc() < 2) return;
+
+	command = Cmd_Argv(1);
+	if(!Q_strcasecmp(command,"on"))
+	{
+		enabled = true;
+	}
+	if(!Q_strcasecmp(command,"off"))
+	{
+		if(!cd_id) return;
+		cdstate = SDL_CDStatus(cd_id);
+		if((cdstate == CD_PLAYING) || (cdstate == CD_PAUSED))
+			CDAudio_Stop();
+		enabled = false;
+		return;
+	}
+	if(!Q_strcasecmp(command,"play"))
+	{
+		CDAudio_Play(Q_atoi(Cmd_Argv(2)),false);
+		return;
+	}
+	if(!Q_strcasecmp(command,"loop"))
+	{
+		CDAudio_Play(Q_atoi(Cmd_Argv(2)),true);
+		return;
+	}
+	if(!Q_strcasecmp(command,"stop"))
+	{
+		CDAudio_Stop();
+		return;
+	}
+	if(!Q_strcasecmp(command,"pause"))
+	{
+		CDAudio_Pause();
+		return;
+	}
+	if(!Q_strcasecmp(command,"resume"))
+	{
+		CDAudio_Resume();
+		return;
+	}
+	if(!Q_strcasecmp(command,"eject"))
+	{
+		CDAudio_Eject();
+		return;
+	}
+	if(!Q_strcasecmp(command,"info"))
+	{
+		if(!cd_id) return;
+		cdstate = SDL_CDStatus(cd_id);
+		Con_Printf("%d tracks\n",cd_id->numtracks);
+		if(cdstate == CD_PLAYING)
+			Con_Printf("Currently %s track %d\n",
+				playLooping ? "looping" : "playing",
+				cd_id->cur_track+1);
+		else
+		if(cdstate == CD_PAUSED)
+			Con_Printf("Paused %s track %d\n",
+				playLooping ? "looping" : "playing",
+				cd_id->cur_track+1);
+		return;
+	}
+}
+
diff -ruN WinQuake/common.c sdlquake-1.0.9/common.c
--- WinQuake/common.c	Tue Dec 21 15:53:24 1999
+++ sdlquake-1.0.9/common.c	Sat Dec 25 03:38:02 1999
@@ -431,6 +431,10 @@
 ============================================================================
 */
 
+#ifdef SDL
+#include "SDL_byteorder.h"
+#endif
+
 qboolean        bigendien;
 
 short   (*BigShort) (short l);
@@ -1127,7 +1131,12 @@
 	byte    swaptest[2] = {1,0};
 
 // set the byte swapping variables in a portable manner 
+#ifdef SDL
+	// This is necessary because egcs 1.1.1 mis-compiles swaptest with -O2
+	if ( SDL_BYTEORDER == SDL_LIL_ENDIAN )
+#else
 	if ( *(short *)swaptest == 1)
+#endif
 	{
 		bigendien = false;
 		BigShort = ShortSwap;
@@ -1438,7 +1447,7 @@
 				else
 					sprintf (cachepath,"%s%s", com_cachedir, netpath+2);
 #else
-				sprintf (cachepath,"%s%s", com_cachedir, netpath);
+				sprintf (cachepath,"%s/%s", com_cachedir, netpath);
 #endif
 
 				cachetime = Sys_FileTime (cachepath);
diff -ruN WinQuake/config.guess sdlquake-1.0.9/config.guess
--- WinQuake/config.guess	Wed Dec 31 16:00:00 1969
+++ sdlquake-1.0.9/config.guess	Sat Dec 25 03:38:02 1999
@@ -0,0 +1,997 @@
+#! /bin/sh
+# Attempt to guess a canonical system name.
+#   Copyright (C) 1992, 93, 94, 95, 96, 97, 1998 Free Software Foundation, Inc.
+#
+# This file is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+#
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+# Written by Per Bothner <bothner@cygnus.com>.
+# The master version of this file is at the FSF in /home/gd/gnu/lib.
+# Please send patches to the Autoconf mailing list <autoconf@gnu.org>.
+#
+# This script attempts to guess a canonical system name similar to
+# config.sub.  If it succeeds, it prints the system name on stdout, and
+# exits with 0.  Otherwise, it exits with 1.
+#
+# The plan is that this can be called by configure scripts if you
+# don't specify an explicit system type (host/target name).
+#
+# Only a few systems have been added to this list; please add others
+# (but try to keep the structure clean).
+#
+
+# This is needed to find uname on a Pyramid OSx when run in the BSD universe.
+# (ghazi@noc.rutgers.edu 8/24/94.)
+if (test -f /.attbin/uname) >/dev/null 2>&1 ; then
+	PATH=$PATH:/.attbin ; export PATH
+fi
+
+UNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown
+UNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown
+UNAME_SYSTEM=`(uname -s) 2>/dev/null` || UNAME_SYSTEM=unknown
+UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
+
+dummy=dummy-$$
+trap 'rm -f $dummy.c $dummy.o $dummy; exit 1' 1 2 15
+
+# Note: order is significant - the case branches are not exclusive.
+
+case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
+    alpha:OSF1:*:*)
+	if test $UNAME_RELEASE = "V4.0"; then
+		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`
+	fi
+	# A Vn.n version is a released version.
+	# A Tn.n version is a released field test version.
+	# A Xn.n version is an unreleased experimental baselevel.
+	# 1.2 uses "1.2" for uname -r.
+	cat <<EOF >$dummy.s
+	.globl main
+	.ent main
+main:
+	.frame \$30,0,\$26,0
+	.prologue 0
+	.long 0x47e03d80 # implver $0
+	lda \$2,259
+	.long 0x47e20c21 # amask $2,$1
+	srl \$1,8,\$2
+	sll \$2,2,\$2
+	sll \$0,3,\$0
+	addl \$1,\$0,\$0
+	addl \$2,\$0,\$0
+	ret \$31,(\$26),1
+	.end main
+EOF
+	${CC-cc} $dummy.s -o $dummy 2>/dev/null
+	if test "$?" = 0 ; then
+		./$dummy
+		case "$?" in
+			7)
+				UNAME_MACHINE="alpha"
+				;;
+			15)
+				UNAME_MACHINE="alphaev5"
+				;;
+			14)
+				UNAME_MACHINE="alphaev56"
+				;;
+			10)
+				UNAME_MACHINE="alphapca56"
+				;;
+			16)
+				UNAME_MACHINE="alphaev6"
+				;;
+		esac
+	fi
+	rm -f $dummy.s $dummy
+	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[VTX]//' | tr [[A-Z]] [[a-z]]`
+	exit 0 ;;
+    21064:Windows_NT:50:3)
+	echo alpha-dec-winnt3.5
+	exit 0 ;;
+    Amiga*:UNIX_System_V:4.0:*)
+	echo m68k-cbm-sysv4
+	exit 0;;
+    amiga:NetBSD:*:*)
+      echo m68k-cbm-netbsd${UNAME_RELEASE}
+      exit 0 ;;
+    amiga:OpenBSD:*:*)
+	echo m68k-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    *:[Aa]miga[Oo][Ss]:*:*)
+	echo ${UNAME_MACHINE}-unknown-amigaos
+	exit 0 ;;
+    arc64:OpenBSD:*:*)
+	echo mips64el-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    arc:OpenBSD:*:*)
+	echo mipsel-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    hkmips:OpenBSD:*:*)
+	echo mips-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    pmax:OpenBSD:*:*)
+	echo mipsel-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    sgi:OpenBSD:*:*)
+	echo mips-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    wgrisc:OpenBSD:*:*)
+	echo mipsel-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
+	echo arm-acorn-riscix${UNAME_RELEASE}
+	exit 0;;
+    arm32:NetBSD:*:*)
+	echo arm-unknown-netbsd`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
+	exit 0 ;;
+    SR2?01:HI-UX/MPP:*:*)
+	echo hppa1.1-hitachi-hiuxmpp
+	exit 0;;
+    Pyramid*:OSx*:*:*|MIS*:OSx*:*:*|MIS*:SMP_DC-OSx*:*:*)
+	# akee@wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.
+	if test "`(/bin/universe) 2>/dev/null`" = att ; then
+		echo pyramid-pyramid-sysv3
+	else
+		echo pyramid-pyramid-bsd
+	fi
+	exit 0 ;;
+    NILE*:*:*:dcosx)
+	echo pyramid-pyramid-svr4
+	exit 0 ;;
+    sun4H:SunOS:5.*:*)
+	echo sparc-hal-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit 0 ;;
+    sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
+	echo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit 0 ;;
+    i86pc:SunOS:5.*:*)
+	echo i386-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit 0 ;;
+    sun4*:SunOS:6*:*)
+	# According to config.sub, this is the proper way to canonicalize
+	# SunOS6.  Hard to guess exactly what SunOS6 will be like, but
+	# it's likely to be more like Solaris than SunOS4.
+	echo sparc-sun-solaris3`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit 0 ;;
+    sun4*:SunOS:*:*)
+	case "`/usr/bin/arch -k`" in
+	    Series*|S4*)
+		UNAME_RELEASE=`uname -v`
+		;;
+	esac
+	# Japanese Language versions have a version number like `4.1.3-JL'.
+	echo sparc-sun-sunos`echo ${UNAME_RELEASE}|sed -e 's/-/_/'`
+	exit 0 ;;
+    sun3*:SunOS:*:*)
+	echo m68k-sun-sunos${UNAME_RELEASE}
+	exit 0 ;;
+    sun*:*:4.2BSD:*)
+	UNAME_RELEASE=`(head -1 /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
+	test "x${UNAME_RELEASE}" = "x" && UNAME_RELEASE=3
+	case "`/bin/arch`" in
+	    sun3)
+		echo m68k-sun-sunos${UNAME_RELEASE}
+		;;
+	    sun4)
+		echo sparc-sun-sunos${UNAME_RELEASE}
+		;;
+	esac
+	exit 0 ;;
+    aushp:SunOS:*:*)
+	echo sparc-auspex-sunos${UNAME_RELEASE}
+	exit 0 ;;
+    atari*:NetBSD:*:*)
+	echo m68k-atari-netbsd${UNAME_RELEASE}
+	exit 0 ;;
+    atari*:OpenBSD:*:*)
+	echo m68k-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    sun3*:NetBSD:*:*)
+	echo m68k-sun-netbsd${UNAME_RELEASE}
+	exit 0 ;;
+    sun3*:OpenBSD:*:*)
+	echo m68k-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    mac68k:NetBSD:*:*)
+	echo m68k-apple-netbsd${UNAME_RELEASE}
+	exit 0 ;;
+    mac68k:OpenBSD:*:*)
+	echo m68k-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    mvme68k:OpenBSD:*:*)
+	echo m68k-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    mvme88k:OpenBSD:*:*)
+	echo m88k-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    powerpc:machten:*:*)
+	echo powerpc-apple-machten${UNAME_RELEASE}
+	exit 0 ;;
+    macppc:NetBSD:*:*)
+        echo powerpc-apple-netbsd${UNAME_RELEASE}
+        exit 0 ;;
+    RISC*:Mach:*:*)
+	echo mips-dec-mach_bsd4.3
+	exit 0 ;;
+    RISC*:ULTRIX:*:*)
+	echo mips-dec-ultrix${UNAME_RELEASE}
+	exit 0 ;;
+    VAX*:ULTRIX*:*:*)
+	echo vax-dec-ultrix${UNAME_RELEASE}
+	exit 0 ;;
+    2020:CLIX:*:*)
+	echo clipper-intergraph-clix${UNAME_RELEASE}
+	exit 0 ;;
+    mips:*:*:UMIPS | mips:*:*:RISCos)
+	sed 's/^	//' << EOF >$dummy.c
+#ifdef __cplusplus
+	int main (int argc, char *argv[]) {
+#else
+	int main (argc, argv) int argc; char *argv[]; {
+#endif
+	#if defined (host_mips) && defined (MIPSEB)
+	#if defined (SYSTYPE_SYSV)
+	  printf ("mips-mips-riscos%ssysv\n", argv[1]); exit (0);
+	#endif
+	#if defined (SYSTYPE_SVR4)
+	  printf ("mips-mips-riscos%ssvr4\n", argv[1]); exit (0);
+	#endif
+	#if defined (SYSTYPE_BSD43) || defined(SYSTYPE_BSD)
+	  printf ("mips-mips-riscos%sbsd\n", argv[1]); exit (0);
+	#endif
+	#endif
+	  exit (-1);
+	}
+EOF
+	${CC-cc} $dummy.c -o $dummy \
+	  && ./$dummy `echo "${UNAME_RELEASE}" | sed -n 's/\([0-9]*\).*/\1/p'` \
+	  && rm $dummy.c $dummy && exit 0
+	rm -f $dummy.c $dummy
+	echo mips-mips-riscos${UNAME_RELEASE}
+	exit 0 ;;
+    Night_Hawk:Power_UNIX:*:*)
+	echo powerpc-harris-powerunix
+	exit 0 ;;
+    m88k:CX/UX:7*:*)
+	echo m88k-harris-cxux7
+	exit 0 ;;
+    m88k:*:4*:R4*)
+	echo m88k-motorola-sysv4
+	exit 0 ;;
+    m88k:*:3*:R3*)
+	echo m88k-motorola-sysv3
+	exit 0 ;;
+    AViiON:dgux:*:*)
+        # DG/UX returns AViiON for all architectures
+        UNAME_PROCESSOR=`/usr/bin/uname -p`
+        if [ $UNAME_PROCESSOR = mc88100 -o $UNAME_PROCESSOR = mc88110 ] ; then
+	if [ ${TARGET_BINARY_INTERFACE}x = m88kdguxelfx \
+	     -o ${TARGET_BINARY_INTERFACE}x = x ] ; then
+		echo m88k-dg-dgux${UNAME_RELEASE}
+	else
+		echo m88k-dg-dguxbcs${UNAME_RELEASE}
+	fi
+        else echo i586-dg-dgux${UNAME_RELEASE}
+        fi
+ 	exit 0 ;;
+    M88*:DolphinOS:*:*)	# DolphinOS (SVR3)
+	echo m88k-dolphin-sysv3
+	exit 0 ;;
+    M88*:*:R3*:*)
+	# Delta 88k system running SVR3
+	echo m88k-motorola-sysv3
+	exit 0 ;;
+    XD88*:*:*:*) # Tektronix XD88 system running UTekV (SVR3)
+	echo m88k-tektronix-sysv3
+	exit 0 ;;
+    Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)
+	echo m68k-tektronix-bsd
+	exit 0 ;;
+    *:IRIX*:*:*)
+	echo mips-sgi-irix`echo ${UNAME_RELEASE}|sed -e 's/-/_/g'`
+	exit 0 ;;
+    ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.
+	echo romp-ibm-aix      # uname -m gives an 8 hex-code CPU id
+	exit 0 ;;              # Note that: echo "'`uname -s`'" gives 'AIX '
+    i?86:AIX:*:*)
+	echo i386-ibm-aix
+	exit 0 ;;
+    *:AIX:2:3)
+	if grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then
+		sed 's/^		//' << EOF >$dummy.c
+		#include <sys/systemcfg.h>
+
+		main()
+			{
+			if (!__power_pc())
+				exit(1);
+			puts("powerpc-ibm-aix3.2.5");
+			exit(0);
+			}
+EOF
+		${CC-cc} $dummy.c -o $dummy && ./$dummy && rm $dummy.c $dummy && exit 0
+		rm -f $dummy.c $dummy
+		echo rs6000-ibm-aix3.2.5
+	elif grep bos324 /usr/include/stdio.h >/dev/null 2>&1; then
+		echo rs6000-ibm-aix3.2.4
+	else
+		echo rs6000-ibm-aix3.2
+	fi
+	exit 0 ;;
+    *:AIX:*:4)
+	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | head -1 | awk '{ print $1 }'`
+	if /usr/sbin/lsattr -EHl ${IBM_CPU_ID} | grep POWER >/dev/null 2>&1; then
+		IBM_ARCH=rs6000
+	else
+		IBM_ARCH=powerpc
+	fi
+	if [ -x /usr/bin/oslevel ] ; then
+		IBM_REV=`/usr/bin/oslevel`
+	else
+		IBM_REV=4.${UNAME_RELEASE}
+	fi
+	echo ${IBM_ARCH}-ibm-aix${IBM_REV}
+	exit 0 ;;
+    *:AIX:*:*)
+	echo rs6000-ibm-aix
+	exit 0 ;;
+    ibmrt:4.4BSD:*|romp-ibm:BSD:*)
+	echo romp-ibm-bsd4.4
+	exit 0 ;;
+    ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC NetBSD and
+	echo romp-ibm-bsd${UNAME_RELEASE}   # 4.3 with uname added to
+	exit 0 ;;                           # report: romp-ibm BSD 4.3
+    *:BOSX:*:*)
+	echo rs6000-bull-bosx
+	exit 0 ;;
+    DPX/2?00:B.O.S.:*:*)
+	echo m68k-bull-sysv3
+	exit 0 ;;
+    9000/[34]??:4.3bsd:1.*:*)
+	echo m68k-hp-bsd
+	exit 0 ;;
+    hp300:4.4BSD:*:* | 9000/[34]??:4.3bsd:2.*:*)
+	echo m68k-hp-bsd4.4
+	exit 0 ;;
+    9000/[34678]??:HP-UX:*:*)
+	case "${UNAME_MACHINE}" in
+	    9000/31? )            HP_ARCH=m68000 ;;
+	    9000/[34]?? )         HP_ARCH=m68k ;;
+	    9000/6?? | 9000/7?? | 9000/80[024] | 9000/8?[136790] | 9000/892 )
+              sed 's/^              //' << EOF >$dummy.c
+              #include <stdlib.h>
+              #include <unistd.h>
+
+              int main ()
+              {
+              #if defined(_SC_KERNEL_BITS)
+                  long bits = sysconf(_SC_KERNEL_BITS);
+              #endif
+                  long cpu  = sysconf (_SC_CPU_VERSION);
+
+                  switch (cpu)
+              	{
+              	case CPU_PA_RISC1_0: puts ("hppa1.0"); break;
+              	case CPU_PA_RISC1_1: puts ("hppa1.1"); break;
+              	case CPU_PA_RISC2_0:
+              #if defined(_SC_KERNEL_BITS)
+              	    switch (bits)
+              		{
+              		case 64: puts ("hppa2.0w"); break;
+              		case 32: puts ("hppa2.0n"); break;
+              		default: puts ("hppa2.0"); break;
+              		} break;
+              #else  /* !defined(_SC_KERNEL_BITS) */
+              	    puts ("hppa2.0"); break;
+              #endif
+              	default: puts ("hppa1.0"); break;
+              	}
+                  exit (0);
+              }
+EOF
+	(${CC-cc} $dummy.c -o $dummy 2>/dev/null ) && HP_ARCH=`./$dummy`
+	rm -f $dummy.c $dummy
+	esac
+	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
+	echo ${HP_ARCH}-hp-hpux${HPUX_REV}
+	exit 0 ;;
+    3050*:HI-UX:*:*)
+	sed 's/^	//' << EOF >$dummy.c
+	#include <unistd.h>
+	int
+	main ()
+	{
+	  long cpu = sysconf (_SC_CPU_VERSION);
+	  /* The order matters, because CPU_IS_HP_MC68K erroneously returns
+	     true for CPU_PA_RISC1_0.  CPU_IS_PA_RISC returns correct
+	     results, however.  */
+	  if (CPU_IS_PA_RISC (cpu))
+	    {
+	      switch (cpu)
+		{
+		  case CPU_PA_RISC1_0: puts ("hppa1.0-hitachi-hiuxwe2"); break;
+		  case CPU_PA_RISC1_1: puts ("hppa1.1-hitachi-hiuxwe2"); break;
+		  case CPU_PA_RISC2_0: puts ("hppa2.0-hitachi-hiuxwe2"); break;
+		  default: puts ("hppa-hitachi-hiuxwe2"); break;
+		}
+	    }
+	  else if (CPU_IS_HP_MC68K (cpu))
+	    puts ("m68k-hitachi-hiuxwe2");
+	  else puts ("unknown-hitachi-hiuxwe2");
+	  exit (0);
+	}
+EOF
+	${CC-cc} $dummy.c -o $dummy && ./$dummy && rm $dummy.c $dummy && exit 0
+	rm -f $dummy.c $dummy
+	echo unknown-hitachi-hiuxwe2
+	exit 0 ;;
+    9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:* )
+	echo hppa1.1-hp-bsd
+	exit 0 ;;
+    9000/8??:4.3bsd:*:*)
+	echo hppa1.0-hp-bsd
+	exit 0 ;;
+    *9??*:MPE*:*:*)
+	echo hppa1.0-hp-mpeix
+	exit 0 ;;
+    *9??*:MPE*:*:*)
+	echo hppa1.0-hp-mpeix
+	exit 0 ;;
+    hp7??:OSF1:*:* | hp8?[79]:OSF1:*:* )
+	echo hppa1.1-hp-osf
+	exit 0 ;;
+    hp8??:OSF1:*:*)
+	echo hppa1.0-hp-osf
+	exit 0 ;;
+    i?86:OSF1:*:*)
+	if [ -x /usr/sbin/sysversion ] ; then
+	    echo ${UNAME_MACHINE}-unknown-osf1mk
+	else
+	    echo ${UNAME_MACHINE}-unknown-osf1
+	fi
+	exit 0 ;;
+    parisc*:Lites*:*:*)
+	echo hppa1.1-hp-lites
+	exit 0 ;;
+    C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)
+	echo c1-convex-bsd
+        exit 0 ;;
+    C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)
+	if getsysinfo -f scalar_acc
+	then echo c32-convex-bsd
+	else echo c2-convex-bsd
+	fi
+        exit 0 ;;
+    C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)
+	echo c34-convex-bsd
+        exit 0 ;;
+    C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)
+	echo c38-convex-bsd
+        exit 0 ;;
+    C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)
+	echo c4-convex-bsd
+        exit 0 ;;
+    CRAY*X-MP:*:*:*)
+	echo xmp-cray-unicos
+        exit 0 ;;
+    CRAY*Y-MP:*:*:*)
+	echo ymp-cray-unicos${UNAME_RELEASE}
+	exit 0 ;;
+    CRAY*[A-Z]90:*:*:*)
+	echo ${UNAME_MACHINE}-cray-unicos${UNAME_RELEASE} \
+	| sed -e 's/CRAY.*\([A-Z]90\)/\1/' \
+	      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/
+	exit 0 ;;
+    CRAY*TS:*:*:*)
+	echo t90-cray-unicos${UNAME_RELEASE}
+	exit 0 ;;
+    CRAY*T3E:*:*:*)
+	echo t3e-cray-unicosmk${UNAME_RELEASE}
+	exit 0 ;;
+    CRAY-2:*:*:*)
+	echo cray2-cray-unicos
+        exit 0 ;;
+    F300:UNIX_System_V:*:*)
+        FUJITSU_SYS=`uname -p | tr [A-Z] [a-z] | sed -e 's/\///'`
+        FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
+        echo "f300-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
+        exit 0 ;;
+    F301:UNIX_System_V:*:*)
+       echo f301-fujitsu-uxpv`echo $UNAME_RELEASE | sed 's/ .*//'`
+       exit 0 ;;
+    hp3[0-9][05]:NetBSD:*:*)
+	echo m68k-hp-netbsd${UNAME_RELEASE}
+	exit 0 ;;
+    hp300:OpenBSD:*:*)
+	echo m68k-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    sparc*:BSD/OS:*:*)
+	echo sparc-unknown-bsdi${UNAME_RELEASE}
+	exit 0 ;;
+    i?86:BSD/386:*:* | i?86:BSD/OS:*:*)
+	echo ${UNAME_MACHINE}-pc-bsdi${UNAME_RELEASE}
+	exit 0 ;;
+    *:BSD/OS:*:*)
+	echo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}
+	exit 0 ;;
+    *:FreeBSD:*:*)
+	if test -x /usr/bin/objformat; then
+	    if test "elf" = "`/usr/bin/objformat`"; then
+		echo ${UNAME_MACHINE}-unknown-freebsdelf`echo ${UNAME_RELEASE}|sed -e 's/[-_].*//'`
+		exit 0
+	    fi
+	fi
+	echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
+	exit 0 ;;
+    *:NetBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-netbsd`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
+	exit 0 ;;
+    *:OpenBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-openbsd`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
+	exit 0 ;;
+    i*:CYGWIN*:*)
+	echo ${UNAME_MACHINE}-pc-cygwin
+	exit 0 ;;
+    i*:MINGW*:*)
+	echo ${UNAME_MACHINE}-pc-mingw32
+	exit 0 ;;
+    p*:CYGWIN*:*)
+	echo powerpcle-unknown-cygwin
+	exit 0 ;;
+    prep*:SunOS:5.*:*)
+	echo powerpcle-unknown-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit 0 ;;
+    *:GNU:*:*)
+	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
+	exit 0 ;;
+    *:Linux:*:*)
+#	# uname on the ARM produces all sorts of strangeness, and we need to
+#	# filter it out.
+#	case "$UNAME_MACHINE" in
+#	  armv*)		      UNAME_MACHINE=$UNAME_MACHINE ;;
+#	  arm* | sa110*)	      UNAME_MACHINE="arm" ;;
+#	esac
+
+	# The BFD linker knows what the default object file format is, so
+	# first see if it will tell us.
+	ld_help_string=`ld --help 2>&1`
+	ld_supported_emulations=`echo $ld_help_string \
+			 | sed -ne '/supported emulations:/!d
+				    s/[ 	][ 	]*/ /g
+				    s/.*supported emulations: *//
+				    s/ .*//
+				    p'`
+        case "$ld_supported_emulations" in
+	  i?86linux)  echo "${UNAME_MACHINE}-pc-linux-gnuaout"      ; exit 0 ;;
+	  i?86coff)   echo "${UNAME_MACHINE}-pc-linux-gnucoff"      ; exit 0 ;;
+	  sparclinux) echo "${UNAME_MACHINE}-unknown-linux-gnuaout" ; exit 0 ;;
+	  armlinux)   echo "${UNAME_MACHINE}-unknown-linux-gnuaout" ; exit 0 ;;
+	  m68klinux)  echo "${UNAME_MACHINE}-unknown-linux-gnuaout" ; exit 0 ;;
+	  elf32arm)   echo "${UNAME_MACHINE}-unknown-linux-gnu"     ; exit 0 ;;
+	  elf32ppc)   echo "powerpc-unknown-linux-gnu"              ; exit 0 ;;
+	esac
+
+	if test "${UNAME_MACHINE}" = "alpha" ; then
+		sed 's/^	//'  <<EOF >$dummy.s
+		.globl main
+		.ent main
+	main:
+		.frame \$30,0,\$26,0
+		.prologue 0
+		.long 0x47e03d80 # implver $0
+		lda \$2,259
+		.long 0x47e20c21 # amask $2,$1
+		srl \$1,8,\$2
+		sll \$2,2,\$2
+		sll \$0,3,\$0
+		addl \$1,\$0,\$0
+		addl \$2,\$0,\$0
+		ret \$31,(\$26),1
+		.end main
+EOF
+		LIBC=""
+		${CC-cc} $dummy.s -o $dummy 2>/dev/null
+		if test "$?" = 0 ; then
+			./$dummy
+			case "$?" in
+			7)
+				UNAME_MACHINE="alpha"
+				;;
+			15)
+				UNAME_MACHINE="alphaev5"
+				;;
+			14)
+				UNAME_MACHINE="alphaev56"
+				;;
+			10)
+				UNAME_MACHINE="alphapca56"
+				;;
+			16)
+				UNAME_MACHINE="alphaev6"
+				;;
+			esac
+
+			objdump --private-headers $dummy | \
+			  grep ld.so.1 > /dev/null
+			if test "$?" = 0 ; then
+				LIBC="libc1"
+			fi
+		fi
+		rm -f $dummy.s $dummy
+		echo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC} ; exit 0
+	elif test "${UNAME_MACHINE}" = "mips" ; then
+	  cat >$dummy.c <<EOF
+#ifdef __cplusplus
+	int main (int argc, char *argv[]) {
+#else
+	int main (argc, argv) int argc; char *argv[]; {
+#endif
+#ifdef __MIPSEB__
+  printf ("%s-unknown-linux-gnu\n", argv[1]);
+#endif
+#ifdef __MIPSEL__
+  printf ("%sel-unknown-linux-gnu\n", argv[1]);
+#endif
+  return 0;
+}
+EOF
+	  ${CC-cc} $dummy.c -o $dummy 2>/dev/null && ./$dummy "${UNAME_MACHINE}" && rm $dummy.c $dummy && exit 0
+	  rm -f $dummy.c $dummy
+	else
+	  # Either a pre-BFD a.out linker (linux-gnuoldld)
+	  # or one that does not give us useful --help.
+	  # GCC wants to distinguish between linux-gnuoldld and linux-gnuaout.
+	  # If ld does not provide *any* "supported emulations:"
+	  # that means it is gnuoldld.
+	  echo "$ld_help_string" | grep >/dev/null 2>&1 "supported emulations:"
+	  test $? != 0 && echo "${UNAME_MACHINE}-pc-linux-gnuoldld" && exit 0
+
+	  case "${UNAME_MACHINE}" in
+	  i?86)
+	    VENDOR=pc;
+	    ;;
+	  *)
+	    VENDOR=unknown;
+	    ;;
+	  esac
+	  # Determine whether the default compiler is a.out or elf
+	  cat >$dummy.c <<EOF
+#include <features.h>
+#ifdef __cplusplus
+	int main (int argc, char *argv[]) {
+#else
+	int main (argc, argv) int argc; char *argv[]; {
+#endif
+#ifdef __ELF__
+# ifdef __GLIBC__
+#  if __GLIBC__ >= 2
+    printf ("%s-${VENDOR}-linux-gnu\n", argv[1]);
+#  else
+    printf ("%s-${VENDOR}-linux-gnulibc1\n", argv[1]);
+#  endif
+# else
+   printf ("%s-${VENDOR}-linux-gnulibc1\n", argv[1]);
+# endif
+#else
+  printf ("%s-${VENDOR}-linux-gnuaout\n", argv[1]);
+#endif
+  return 0;
+}
+EOF
+	  ${CC-cc} $dummy.c -o $dummy 2>/dev/null && ./$dummy "${UNAME_MACHINE}" && rm $dummy.c $dummy && exit 0
+	  rm -f $dummy.c $dummy
+	fi ;;
+# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.  earlier versions
+# are messed up and put the nodename in both sysname and nodename.
+    i?86:DYNIX/ptx:4*:*)
+	echo i386-sequent-sysv4
+	exit 0 ;;
+    i?86:UNIX_SV:4.2MP:2.*)
+        # Unixware is an offshoot of SVR4, but it has its own version
+        # number series starting with 2...
+        # I am not positive that other SVR4 systems won't match this,
+	# I just have to hope.  -- rms.
+        # Use sysv4.2uw... so that sysv4* matches it.
+	echo ${UNAME_MACHINE}-pc-sysv4.2uw${UNAME_VERSION}
+	exit 0 ;;
+    i?86:*:4.*:* | i?86:SYSTEM_V:4.*:*)
+	if grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then
+		echo ${UNAME_MACHINE}-univel-sysv${UNAME_RELEASE}
+	else
+		echo ${UNAME_MACHINE}-pc-sysv${UNAME_RELEASE}
+	fi
+	exit 0 ;;
+    i?86:*:3.2:*)
+	if test -f /usr/options/cb.name; then
+		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
+		echo ${UNAME_MACHINE}-pc-isc$UNAME_REL
+	elif /bin/uname -X 2>/dev/null >/dev/null ; then
+		UNAME_REL=`(/bin/uname -X|egrep Release|sed -e 's/.*= //')`
+		(/bin/uname -X|egrep i80486 >/dev/null) && UNAME_MACHINE=i486
+		(/bin/uname -X|egrep '^Machine.*Pentium' >/dev/null) \
+			&& UNAME_MACHINE=i586
+		echo ${UNAME_MACHINE}-pc-sco$UNAME_REL
+	else
+		echo ${UNAME_MACHINE}-pc-sysv32
+	fi
+	exit 0 ;;
+    i?86:UnixWare:*:*)
+	if /bin/uname -X 2>/dev/null >/dev/null ; then
+	  (/bin/uname -X|egrep '^Machine.*Pentium' >/dev/null) \
+	    && UNAME_MACHINE=i586
+	fi
+	echo ${UNAME_MACHINE}-unixware-${UNAME_RELEASE}-${UNAME_VERSION}
+	exit 0 ;;
+    pc:*:*:*)
+        # uname -m prints for DJGPP always 'pc', but it prints nothing about
+        # the processor, so we play safe by assuming i386.
+	echo i386-pc-msdosdjgpp
+        exit 0 ;;
+    Intel:Mach:3*:*)
+	echo i386-pc-mach3
+	exit 0 ;;
+    paragon:*:*:*)
+	echo i860-intel-osf1
+	exit 0 ;;
+    i860:*:4.*:*) # i860-SVR4
+	if grep Stardent /usr/include/sys/uadmin.h >/dev/null 2>&1 ; then
+	  echo i860-stardent-sysv${UNAME_RELEASE} # Stardent Vistra i860-SVR4
+	else # Add other i860-SVR4 vendors below as they are discovered.
+	  echo i860-unknown-sysv${UNAME_RELEASE}  # Unknown i860-SVR4
+	fi
+	exit 0 ;;
+    mini*:CTIX:SYS*5:*)
+	# "miniframe"
+	echo m68010-convergent-sysv
+	exit 0 ;;
+    M68*:*:R3V[567]*:*)
+	test -r /sysV68 && echo 'm68k-motorola-sysv' && exit 0 ;;
+    3[34]??:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 4850:*:4.0:3.0)
+	OS_REL=''
+	test -r /etc/.relid \
+	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
+	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+	  && echo i486-ncr-sysv4.3${OS_REL} && exit 0
+	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
+	  && echo i586-ncr-sysv4.3${OS_REL} && exit 0 ;;
+    3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
+        /bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+          && echo i486-ncr-sysv4 && exit 0 ;;
+    m68*:LynxOS:2.*:*)
+	echo m68k-unknown-lynxos${UNAME_RELEASE}
+	exit 0 ;;
+    mc68030:UNIX_System_V:4.*:*)
+	echo m68k-atari-sysv4
+	exit 0 ;;
+    i?86:LynxOS:2.*:* | i?86:LynxOS:3.[01]*:*)
+	echo i386-unknown-lynxos${UNAME_RELEASE}
+	exit 0 ;;
+    TSUNAMI:LynxOS:2.*:*)
+	echo sparc-unknown-lynxos${UNAME_RELEASE}
+	exit 0 ;;
+    rs6000:LynxOS:2.*:* | PowerPC:LynxOS:2.*:*)
+	echo rs6000-unknown-lynxos${UNAME_RELEASE}
+	exit 0 ;;
+    SM[BE]S:UNIX_SV:*:*)
+	echo mips-dde-sysv${UNAME_RELEASE}
+	exit 0 ;;
+    RM*:ReliantUNIX-*:*:*)
+	echo mips-sni-sysv4
+	exit 0 ;;
+    RM*:SINIX-*:*:*)
+	echo mips-sni-sysv4
+	exit 0 ;;
+    *:SINIX-*:*:*)
+	if uname -p 2>/dev/null >/dev/null ; then
+		UNAME_MACHINE=`(uname -p) 2>/dev/null`
+		echo ${UNAME_MACHINE}-sni-sysv4
+	else
+		echo ns32k-sni-sysv
+	fi
+	exit 0 ;;
+    PENTIUM:CPunix:4.0*:*) # Unisys `ClearPath HMP IX 4000' SVR4/MP effort
+                           # says <Richard.M.Bartel@ccMail.Census.GOV>
+        echo i586-unisys-sysv4
+        exit 0 ;;
+    *:UNIX_System_V:4*:FTX*)
+	# From Gerald Hewes <hewes@openmarket.com>.
+	# How about differentiating between stratus architectures? -djm
+	echo hppa1.1-stratus-sysv4
+	exit 0 ;;
+    *:*:*:FTX*)
+	# From seanf@swdc.stratus.com.
+	echo i860-stratus-sysv4
+	exit 0 ;;
+    mc68*:A/UX:*:*)
+	echo m68k-apple-aux${UNAME_RELEASE}
+	exit 0 ;;
+    news*:NEWS-OS:*:6*)
+	echo mips-sony-newsos6
+	exit 0 ;;
+    R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R4000:UNIX_SV:*:*)
+	if [ -d /usr/nec ]; then
+	        echo mips-nec-sysv${UNAME_RELEASE}
+	else
+	        echo mips-unknown-sysv${UNAME_RELEASE}
+	fi
+        exit 0 ;;
+    BeBox:BeOS:*:*)	# BeOS running on hardware made by Be, PPC only.
+	echo powerpc-be-beos
+	exit 0 ;;
+    BeMac:BeOS:*:*)	# BeOS running on Mac or Mac clone, PPC only.
+	echo powerpc-apple-beos
+	exit 0 ;;
+    BePC:BeOS:*:*)	# BeOS running on Intel PC compatible.
+	echo i586-pc-beos
+	exit 0 ;;
+    SX-4:SUPER-UX:*:*)
+	echo sx4-nec-superux${UNAME_RELEASE}
+	exit 0 ;;
+    SX-5:SUPER-UX:*:*)
+	echo sx5-nec-superux${UNAME_RELEASE}
+	exit 0 ;;
+    Power*:Rhapsody:*:*)
+	echo powerpc-apple-rhapsody${UNAME_RELEASE}
+	exit 0 ;;
+    *:Rhapsody:*:*)
+	echo ${UNAME_MACHINE}-apple-rhapsody${UNAME_RELEASE}
+	exit 0 ;;
+esac
+
+#echo '(No uname command or uname output not recognized.)' 1>&2
+#echo "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" 1>&2
+
+cat >$dummy.c <<EOF
+#ifdef _SEQUENT_
+# include <sys/types.h>
+# include <sys/utsname.h>
+#endif
+main ()
+{
+#if defined (sony)
+#if defined (MIPSEB)
+  /* BFD wants "bsd" instead of "newsos".  Perhaps BFD should be changed,
+     I don't know....  */
+  printf ("mips-sony-bsd\n"); exit (0);
+#else
+#include <sys/param.h>
+  printf ("m68k-sony-newsos%s\n",
+#ifdef NEWSOS4
+          "4"
+#else
+	  ""
+#endif
+         ); exit (0);
+#endif
+#endif
+
+#if defined (__arm) && defined (__acorn) && defined (__unix)
+  printf ("arm-acorn-riscix"); exit (0);
+#endif
+
+#if defined (hp300) && !defined (hpux)
+  printf ("m68k-hp-bsd\n"); exit (0);
+#endif
+
+#if defined (NeXT)
+#if !defined (__ARCHITECTURE__)
+#define __ARCHITECTURE__ "m68k"
+#endif
+  int version;
+  version=`(hostinfo | sed -n 's/.*NeXT Mach \([0-9]*\).*/\1/p') 2>/dev/null`;
+  if (version < 4)
+    printf ("%s-next-nextstep%d\n", __ARCHITECTURE__, version);
+  else
+    printf ("%s-next-openstep%d\n", __ARCHITECTURE__, version);
+  exit (0);
+#endif
+
+#if defined (MULTIMAX) || defined (n16)
+#if defined (UMAXV)
+  printf ("ns32k-encore-sysv\n"); exit (0);
+#else
+#if defined (CMU)
+  printf ("ns32k-encore-mach\n"); exit (0);
+#else
+  printf ("ns32k-encore-bsd\n"); exit (0);
+#endif
+#endif
+#endif
+
+#if defined (__386BSD__)
+  printf ("i386-pc-bsd\n"); exit (0);
+#endif
+
+#if defined (sequent)
+#if defined (i386)
+  printf ("i386-sequent-dynix\n"); exit (0);
+#endif
+#if defined (ns32000)
+  printf ("ns32k-sequent-dynix\n"); exit (0);
+#endif
+#endif
+
+#if defined (_SEQUENT_)
+    struct utsname un;
+
+    uname(&un);
+
+    if (strncmp(un.version, "V2", 2) == 0) {
+	printf ("i386-sequent-ptx2\n"); exit (0);
+    }
+    if (strncmp(un.version, "V1", 2) == 0) { /* XXX is V1 correct? */
+	printf ("i386-sequent-ptx1\n"); exit (0);
+    }
+    printf ("i386-sequent-ptx\n"); exit (0);
+
+#endif
+
+#if defined (vax)
+#if !defined (ultrix)
+  printf ("vax-dec-bsd\n"); exit (0);
+#else
+  printf ("vax-dec-ultrix\n"); exit (0);
+#endif
+#endif
+
+#if defined (alliant) && defined (i860)
+  printf ("i860-alliant-bsd\n"); exit (0);
+#endif
+
+  exit (1);
+}
+EOF
+
+${CC-cc} $dummy.c -o $dummy 2>/dev/null && ./$dummy && rm $dummy.c $dummy && exit 0
+rm -f $dummy.c $dummy
+
+# Apollos put the system type in the environment.
+
+test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit 0; }
+
+# Convex versions that predate uname can use getsysinfo(1)
+
+if [ -x /usr/convex/getsysinfo ]
+then
+    case `getsysinfo -f cpu_type` in
+    c1*)
+	echo c1-convex-bsd
+	exit 0 ;;
+    c2*)
+	if getsysinfo -f scalar_acc
+	then echo c32-convex-bsd
+	else echo c2-convex-bsd
+	fi
+	exit 0 ;;
+    c34*)
+	echo c34-convex-bsd
+	exit 0 ;;
+    c38*)
+	echo c38-convex-bsd
+	exit 0 ;;
+    c4*)
+	echo c4-convex-bsd
+	exit 0 ;;
+    esac
+fi
+
+#echo '(Unable to guess system type)' 1>&2
+
+exit 1
diff -ruN WinQuake/config.sub sdlquake-1.0.9/config.sub
--- WinQuake/config.sub	Wed Dec 31 16:00:00 1969
+++ sdlquake-1.0.9/config.sub	Sat Dec 25 03:38:02 1999
@@ -0,0 +1,979 @@
+#! /bin/sh
+# Configuration validation subroutine script, version 1.1.
+#   Copyright (C) 1991, 92-97, 1998 Free Software Foundation, Inc.
+# This file is (in principle) common to ALL GNU software.
+# The presence of a machine in this file suggests that SOME GNU software
+# can handle that machine.  It does not imply ALL GNU software can.
+#
+# This file is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330,
+# Boston, MA 02111-1307, USA.
+
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+# Configuration subroutine to validate and canonicalize a configuration type.
+# Supply the specified configuration type as an argument.
+# If it is invalid, we print an error message on stderr and exit with code 1.
+# Otherwise, we print the canonical config type on stdout and succeed.
+
+# This file is supposed to be the same for all GNU packages
+# and recognize all the CPU types, system types and aliases
+# that are meaningful with *any* GNU software.
+# Each package is responsible for reporting which valid configurations
+# it does not support.  The user should be able to distinguish
+# a failure to support a valid configuration from a meaningless
+# configuration.
+
+# The goal of this file is to map all the various variations of a given
+# machine specification into a single specification in the form:
+#	CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM
+# or in some cases, the newer four-part form:
+#	CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
+# It is wrong to echo any other type of specification.
+
+if [ x$1 = x ]
+then
+	echo Configuration name missing. 1>&2
+	echo "Usage: $0 CPU-MFR-OPSYS" 1>&2
+	echo "or     $0 ALIAS" 1>&2
+	echo where ALIAS is a recognized configuration type. 1>&2
+	exit 1
+fi
+
+# First pass through any local machine types.
+case $1 in
+	*local*)
+		echo $1
+		exit 0
+		;;
+	*)
+	;;
+esac
+
+# Separate what the user gave into CPU-COMPANY and OS or KERNEL-OS (if any).
+# Here we must recognize all the valid KERNEL-OS combinations.
+maybe_os=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\2/'`
+case $maybe_os in
+  linux-gnu*)
+    os=-$maybe_os
+    basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
+    ;;
+  *)
+    basic_machine=`echo $1 | sed 's/-[^-]*$//'`
+    if [ $basic_machine != $1 ]
+    then os=`echo $1 | sed 's/.*-/-/'`
+    else os=; fi
+    ;;
+esac
+
+### Let's recognize common machines as not being operating systems so
+### that things like config.sub decstation-3100 work.  We also
+### recognize some manufacturers as not being operating systems, so we
+### can provide default operating systems below.
+case $os in
+	-sun*os*)
+		# Prevent following clause from handling this invalid input.
+		;;
+	-dec* | -mips* | -sequent* | -encore* | -pc532* | -sgi* | -sony* | \
+	-att* | -7300* | -3300* | -delta* | -motorola* | -sun[234]* | \
+	-unicom* | -ibm* | -next | -hp | -isi* | -apollo | -altos* | \
+	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
+	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
+	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \
+	-apple)
+		os=
+		basic_machine=$1
+		;;
+	-hiux*)
+		os=-hiuxwe2
+		;;
+	-sco5)
+		os=sco3.2v5
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco4)
+		os=-sco3.2v4
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco3.2.[4-9]*)
+		os=`echo $os | sed -e 's/sco3.2./sco3.2v/'`
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco3.2v[4-9]*)
+		# Don't forget version if it is 3.2v4 or newer.
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco*)
+		os=-sco3.2v2
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-isc)
+		os=-isc2.2
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-clix*)
+		basic_machine=clipper-intergraph
+		;;
+	-isc*)
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-lynx*)
+		os=-lynxos
+		;;
+	-ptx*)
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-sequent/'`
+		;;
+	-windowsnt*)
+		os=`echo $os | sed -e 's/windowsnt/winnt/'`
+		;;
+	-psos*)
+		os=-psos
+		;;
+esac
+
+# Decode aliases for certain CPU-COMPANY combinations.
+case $basic_machine in
+	# Recognize the basic CPU types without company name.
+	# Some are omitted here because they have special meanings below.
+	tahoe | i860 | m32r | m68k | m68000 | m88k | ns32k | arc | arm \
+		| arme[lb] | pyramid | mn10200 | mn10300 | tron | a29k \
+		| 580 | i960 | h8300 | hppa | hppa1.0 | hppa1.1 | hppa2.0 \
+		| hppa2.0w \
+		| alpha | alphaev5 | alphaev56 | we32k | ns16k | clipper \
+		| i370 | sh | powerpc | powerpcle | 1750a | dsp16xx | pdp11 \
+		| mips64 | mipsel | mips64el | mips64orion | mips64orionel \
+		| mipstx39 | mipstx39el | armv[34][lb] \
+		| sparc | sparclet | sparclite | sparc64 | v850)
+		basic_machine=$basic_machine-unknown
+		;;
+	# We use `pc' rather than `unknown'
+	# because (1) that's what they normally are, and
+	# (2) the word "unknown" tends to confuse beginning users.
+	i[34567]86)
+	  basic_machine=$basic_machine-pc
+	  ;;
+	# Object if more than one company name word.
+	*-*-*)
+		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
+		exit 1
+		;;
+	# Recognize the basic CPU types with company name.
+	vax-* | tahoe-* | i[34567]86-* | i860-* | m32r-* | m68k-* | m68000-* \
+	      | m88k-* | sparc-* | ns32k-* | fx80-* | arc-* | arm-* | c[123]* \
+	      | mips-* | pyramid-* | tron-* | a29k-* | romp-* | rs6000-* \
+	      | power-* | none-* | 580-* | cray2-* | h8300-* | i960-* \
+	      | xmp-* | ymp-* | hppa-* | hppa1.0-* | hppa1.1-* | hppa2.0-* \
+	      | hppa2.0w-* \
+	      | alpha-* | alphaev5-* | alphaev56-* | we32k-* | cydra-* \
+	      | ns16k-* | pn-* | np1-* | xps100-* | clipper-* | orion-* \
+	      | sparclite-* | pdp11-* | sh-* | powerpc-* | powerpcle-* \
+	      | sparc64-* | mips64-* | mipsel-* | armv[34][lb]-*\
+	      | mips64el-* | mips64orion-* | mips64orionel-*  \
+	      | mipstx39-* | mipstx39el-* \
+	      | f301-* | armv*-*)
+		;;
+	# Recognize the various machine names and aliases which stand
+	# for a CPU type and a company and sometimes even an OS.
+	3b1 | 7300 | 7300-att | att-7300 | pc7300 | safari | unixpc)
+		basic_machine=m68000-att
+		;;
+	3b*)
+		basic_machine=we32k-att
+		;;
+	alliant | fx80)
+		basic_machine=fx80-alliant
+		;;
+	altos | altos3068)
+		basic_machine=m68k-altos
+		;;
+	am29k)
+		basic_machine=a29k-none
+		os=-bsd
+		;;
+	amdahl)
+		basic_machine=580-amdahl
+		os=-sysv
+		;;
+	amiga | amiga-*)
+		basic_machine=m68k-cbm
+		;;
+	amigaos | amigados)
+		basic_machine=m68k-cbm
+		os=-amigaos
+		;;
+	amigaunix | amix)
+		basic_machine=m68k-cbm
+		os=-sysv4
+		;;
+	apollo68)
+		basic_machine=m68k-apollo
+		os=-sysv
+		;;
+	aux)
+		basic_machine=m68k-apple
+		os=-aux
+		;;
+	balance)
+		basic_machine=ns32k-sequent
+		os=-dynix
+		;;
+	convex-c1)
+		basic_machine=c1-convex
+		os=-bsd
+		;;
+	convex-c2)
+		basic_machine=c2-convex
+		os=-bsd
+		;;
+	convex-c32)
+		basic_machine=c32-convex
+		os=-bsd
+		;;
+	convex-c34)
+		basic_machine=c34-convex
+		os=-bsd
+		;;
+	convex-c38)
+		basic_machine=c38-convex
+		os=-bsd
+		;;
+	cray | ymp)
+		basic_machine=ymp-cray
+		os=-unicos
+		;;
+	cray2)
+		basic_machine=cray2-cray
+		os=-unicos
+		;;
+	[ctj]90-cray)
+		basic_machine=c90-cray
+		os=-unicos
+		;;
+	crds | unos)
+		basic_machine=m68k-crds
+		;;
+	da30 | da30-*)
+		basic_machine=m68k-da30
+		;;
+	decstation | decstation-3100 | pmax | pmax-* | pmin | dec3100 | decstatn)
+		basic_machine=mips-dec
+		;;
+	delta | 3300 | motorola-3300 | motorola-delta \
+	      | 3300-motorola | delta-motorola)
+		basic_machine=m68k-motorola
+		;;
+	delta88)
+		basic_machine=m88k-motorola
+		os=-sysv3
+		;;
+	dpx20 | dpx20-*)
+		basic_machine=rs6000-bull
+		os=-bosx
+		;;
+	dpx2* | dpx2*-bull)
+		basic_machine=m68k-bull
+		os=-sysv3
+		;;
+	ebmon29k)
+		basic_machine=a29k-amd
+		os=-ebmon
+		;;
+	elxsi)
+		basic_machine=elxsi-elxsi
+		os=-bsd
+		;;
+	encore | umax | mmax)
+		basic_machine=ns32k-encore
+		;;
+	fx2800)
+		basic_machine=i860-alliant
+		;;
+	genix)
+		basic_machine=ns32k-ns
+		;;
+	gmicro)
+		basic_machine=tron-gmicro
+		os=-sysv
+		;;
+	h3050r* | hiux*)
+		basic_machine=hppa1.1-hitachi
+		os=-hiuxwe2
+		;;
+	h8300hms)
+		basic_machine=h8300-hitachi
+		os=-hms
+		;;
+	harris)
+		basic_machine=m88k-harris
+		os=-sysv3
+		;;
+	hp300-*)
+		basic_machine=m68k-hp
+		;;
+	hp300bsd)
+		basic_machine=m68k-hp
+		os=-bsd
+		;;
+	hp300hpux)
+		basic_machine=m68k-hp
+		os=-hpux
+		;;
+	hp9k2[0-9][0-9] | hp9k31[0-9])
+		basic_machine=m68000-hp
+		;;
+	hp9k3[2-9][0-9])
+		basic_machine=m68k-hp
+		;;
+	hp9k7[0-9][0-9] | hp7[0-9][0-9] | hp9k8[0-9]7 | hp8[0-9]7)
+		basic_machine=hppa1.1-hp
+		;;
+	hp9k8[0-9][0-9] | hp8[0-9][0-9])
+		basic_machine=hppa1.0-hp
+		;;
+	hppa-next)
+		os=-nextstep3
+		;;
+	hp3k9[0-9][0-9] | hp9[0-9][0-9])
+		basic_machine=hppa1.0-hp
+		os=-mpeix
+		;;
+	hp3k9[0-9][0-9] | hp9[0-9][0-9])
+		basic_machine=hppa1.0-hp
+		os=-mpeix
+		;;
+	i370-ibm* | ibm*)
+		basic_machine=i370-ibm
+		os=-mvs
+		;;
+# I'm not sure what "Sysv32" means.  Should this be sysv3.2?
+	i[34567]86v32)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-sysv32
+		;;
+	i[34567]86v4*)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-sysv4
+		;;
+	i[34567]86v)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-sysv
+		;;
+	i[34567]86sol2)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-solaris2
+		;;
+	iris | iris4d)
+		basic_machine=mips-sgi
+		case $os in
+		    -irix*)
+			;;
+		    *)
+			os=-irix4
+			;;
+		esac
+		;;
+	isi68 | isi)
+		basic_machine=m68k-isi
+		os=-sysv
+		;;
+	m88k-omron*)
+		basic_machine=m88k-omron
+		;;
+	magnum | m3230)
+		basic_machine=mips-mips
+		os=-sysv
+		;;
+	merlin)
+		basic_machine=ns32k-utek
+		os=-sysv
+		;;
+	miniframe)
+		basic_machine=m68000-convergent
+		;;
+	mipsel*-linux*)
+		basic_machine=mipsel-unknown
+		os=-linux-gnu
+		;;
+	mips*-linux*)
+		basic_machine=mips-unknown
+		os=-linux-gnu
+		;;
+	mips3*-*)
+		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`
+		;;
+	mips3*)
+		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`-unknown
+		;;
+	ncr3000)
+		basic_machine=i486-ncr
+		os=-sysv4
+		;;
+	netwinder)
+		basic_machine=armv4l-corel
+		os=-linux
+		;;
+	news | news700 | news800 | news900)
+		basic_machine=m68k-sony
+		os=-newsos
+		;;
+	news1000)
+		basic_machine=m68030-sony
+		os=-newsos
+		;;
+	news-3600 | risc-news)
+		basic_machine=mips-sony
+		os=-newsos
+		;;
+	next | m*-next )
+		basic_machine=m68k-next
+		case $os in
+		    -nextstep* )
+			;;
+		    -ns2*)
+		      os=-nextstep2
+			;;
+		    *)
+		      os=-nextstep3
+			;;
+		esac
+		;;
+	nh3000)
+		basic_machine=m68k-harris
+		os=-cxux
+		;;
+	nh[45]000)
+		basic_machine=m88k-harris
+		os=-cxux
+		;;
+	nindy960)
+		basic_machine=i960-intel
+		os=-nindy
+		;;
+	np1)
+		basic_machine=np1-gould
+		;;
+	pa-hitachi)
+		basic_machine=hppa1.1-hitachi
+		os=-hiuxwe2
+		;;
+	paragon)
+		basic_machine=i860-intel
+		os=-osf
+		;;
+	pbd)
+		basic_machine=sparc-tti
+		;;
+	pbb)
+		basic_machine=m68k-tti
+		;;
+        pc532 | pc532-*)
+		basic_machine=ns32k-pc532
+		;;
+	pentium | p5 | k5 | nexen)
+		basic_machine=i586-pc
+		;;
+	pentiumpro | p6 | k6 | 6x86)
+		basic_machine=i686-pc
+		;;
+	pentiumii | pentium2)
+		basic_machine=i786-pc
+		;;
+	pentium-* | p5-* | k5-* | nexen-*)
+		basic_machine=i586-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	pentiumpro-* | p6-* | k6-* | 6x86-*)
+		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	pentiumii-* | pentium2-*)
+		basic_machine=i786-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	pn)
+		basic_machine=pn-gould
+		;;
+	power)	basic_machine=rs6000-ibm
+		;;
+	ppc)	basic_machine=powerpc-unknown
+	        ;;
+	ppc-*)	basic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	ppcle | powerpclittle | ppc-le | powerpc-little)
+		basic_machine=powerpcle-unknown
+	        ;;
+	ppcle-* | powerpclittle-*)
+		basic_machine=powerpcle-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	ps2)
+		basic_machine=i386-ibm
+		;;
+	rm[46]00)
+		basic_machine=mips-siemens
+		;;
+	rtpc | rtpc-*)
+		basic_machine=romp-ibm
+		;;
+	sequent)
+		basic_machine=i386-sequent
+		;;
+	sh)
+		basic_machine=sh-hitachi
+		os=-hms
+		;;
+	sps7)
+		basic_machine=m68k-bull
+		os=-sysv2
+		;;
+	spur)
+		basic_machine=spur-unknown
+		;;
+	sun2)
+		basic_machine=m68000-sun
+		;;
+	sun2os3)
+		basic_machine=m68000-sun
+		os=-sunos3
+		;;
+	sun2os4)
+		basic_machine=m68000-sun
+		os=-sunos4
+		;;
+	sun3os3)
+		basic_machine=m68k-sun
+		os=-sunos3
+		;;
+	sun3os4)
+		basic_machine=m68k-sun
+		os=-sunos4
+		;;
+	sun4os3)
+		basic_machine=sparc-sun
+		os=-sunos3
+		;;
+	sun4os4)
+		basic_machine=sparc-sun
+		os=-sunos4
+		;;
+	sun4sol2)
+		basic_machine=sparc-sun
+		os=-solaris2
+		;;
+	sun3 | sun3-*)
+		basic_machine=m68k-sun
+		;;
+	sun4)
+		basic_machine=sparc-sun
+		;;
+	sun386 | sun386i | roadrunner)
+		basic_machine=i386-sun
+		;;
+	symmetry)
+		basic_machine=i386-sequent
+		os=-dynix
+		;;
+	tx39)
+		basic_machine=mipstx39-unknown
+		;;
+	tx39el)
+		basic_machine=mipstx39el-unknown
+		;;
+	tower | tower-32)
+		basic_machine=m68k-ncr
+		;;
+	udi29k)
+		basic_machine=a29k-amd
+		os=-udi
+		;;
+	ultra3)
+		basic_machine=a29k-nyu
+		os=-sym1
+		;;
+	vaxv)
+		basic_machine=vax-dec
+		os=-sysv
+		;;
+	vms)
+		basic_machine=vax-dec
+		os=-vms
+		;;
+	vpp*|vx|vx-*)
+               basic_machine=f301-fujitsu
+               ;;
+	vxworks960)
+		basic_machine=i960-wrs
+		os=-vxworks
+		;;
+	vxworks68)
+		basic_machine=m68k-wrs
+		os=-vxworks
+		;;
+	vxworks29k)
+		basic_machine=a29k-wrs
+		os=-vxworks
+		;;
+	xmp)
+		basic_machine=xmp-cray
+		os=-unicos
+		;;
+        xps | xps100)
+		basic_machine=xps100-honeywell
+		;;
+	none)
+		basic_machine=none-none
+		os=-none
+		;;
+
+# Here we handle the default manufacturer of certain CPU types.  It is in
+# some cases the only manufacturer, in others, it is the most popular.
+	mips)
+		if [ x$os = x-linux-gnu ]; then
+			basic_machine=mips-unknown
+		else
+			basic_machine=mips-mips
+		fi
+		;;
+	romp)
+		basic_machine=romp-ibm
+		;;
+	rs6000)
+		basic_machine=rs6000-ibm
+		;;
+	vax)
+		basic_machine=vax-dec
+		;;
+	pdp11)
+		basic_machine=pdp11-dec
+		;;
+	we32k)
+		basic_machine=we32k-att
+		;;
+	sparc)
+		basic_machine=sparc-sun
+		;;
+        cydra)
+		basic_machine=cydra-cydrome
+		;;
+	orion)
+		basic_machine=orion-highlevel
+		;;
+	orion105)
+		basic_machine=clipper-highlevel
+		;;
+	*)
+		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
+		exit 1
+		;;
+esac
+
+# Here we canonicalize certain aliases for manufacturers.
+case $basic_machine in
+	*-digital*)
+		basic_machine=`echo $basic_machine | sed 's/digital.*/dec/'`
+		;;
+	*-commodore*)
+		basic_machine=`echo $basic_machine | sed 's/commodore.*/cbm/'`
+		;;
+	*)
+		;;
+esac
+
+# Decode manufacturer-specific aliases for certain operating systems.
+
+if [ x"$os" != x"" ]
+then
+case $os in
+        # First match some system type aliases
+        # that might get confused with valid system types.
+	# -solaris* is a basic system type, with this one exception.
+	-solaris1 | -solaris1.*)
+		os=`echo $os | sed -e 's|solaris1|sunos4|'`
+		;;
+	-solaris)
+		os=-solaris2
+		;;
+	-svr4*)
+		os=-sysv4
+		;;
+	-unixware*)
+		os=-sysv4.2uw
+		;;
+	-gnu/linux*)
+		os=`echo $os | sed -e 's|gnu/linux|linux-gnu|'`
+		;;
+	# First accept the basic system types.
+	# The portable systems comes first.
+	# Each alternative MUST END IN A *, to match a version number.
+	# -sysv* is not here because it comes later, after sysvr4.
+	-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \
+	      | -*vms* | -sco* | -esix* | -isc* | -aix* | -sunos | -sunos[34]*\
+	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -solaris* | -sym* \
+	      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \
+	      | -aos* \
+	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
+	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
+	      | -hiux* | -386bsd* | -netbsd* | -openbsd* | -freebsd* | -riscix* \
+	      | -lynxos* | -bosx* | -nextstep* | -cxux* | -aout* | -elf* \
+	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
+	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
+	      | -cygwin* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
+	      | -mingw32* | -linux-gnu* | -uxpv* | -beos* | -rhapsody* \
+	      | -openstep* | -mpeix* | -oskit*)
+	# Remember, each alternative MUST END IN *, to match a version number.
+		;;
+	-linux*)
+		os=`echo $os | sed -e 's|linux|linux-gnu|'`
+		;;
+	-sunos5*)
+		os=`echo $os | sed -e 's|sunos5|solaris2|'`
+		;;
+	-sunos6*)
+		os=`echo $os | sed -e 's|sunos6|solaris3|'`
+		;;
+	-osfrose*)
+		os=-osfrose
+		;;
+	-osf*)
+		os=-osf
+		;;
+	-utek*)
+		os=-bsd
+		;;
+	-dynix*)
+		os=-bsd
+		;;
+	-acis*)
+		os=-aos
+		;;
+	-ctix* | -uts*)
+		os=-sysv
+		;;
+	-ns2 )
+	        os=-nextstep2
+		;;
+	# Preserve the version number of sinix5.
+	-sinix5.*)
+		os=`echo $os | sed -e 's|sinix|sysv|'`
+		;;
+	-sinix*)
+		os=-sysv4
+		;;
+	-triton*)
+		os=-sysv3
+		;;
+	-oss*)
+		os=-sysv3
+		;;
+	-svr4)
+		os=-sysv4
+		;;
+	-svr3)
+		os=-sysv3
+		;;
+	-sysvr4)
+		os=-sysv4
+		;;
+	# This must come after -sysvr4.
+	-sysv*)
+		;;
+	-xenix)
+		os=-xenix
+		;;
+	-none)
+		;;
+	*)
+		# Get rid of the `-' at the beginning of $os.
+		os=`echo $os | sed 's/[^-]*-//'`
+		echo Invalid configuration \`$1\': system \`$os\' not recognized 1>&2
+		exit 1
+		;;
+esac
+else
+
+# Here we handle the default operating systems that come with various machines.
+# The value should be what the vendor currently ships out the door with their
+# machine or put another way, the most popular os provided with the machine.
+
+# Note that if you're going to try to match "-MANUFACTURER" here (say,
+# "-sun"), then you have to tell the case statement up towards the top
+# that MANUFACTURER isn't an operating system.  Otherwise, code above
+# will signal an error saying that MANUFACTURER isn't an operating
+# system, and we'll never get to this point.
+
+case $basic_machine in
+	*-acorn)
+		os=-riscix1.2
+		;;
+	arm*-corel)
+		os=-linux
+		;;
+	arm*-semi)
+		os=-aout
+		;;
+        pdp11-*)
+		os=-none
+		;;
+	*-dec | vax-*)
+		os=-ultrix4.2
+		;;
+	m68*-apollo)
+		os=-domain
+		;;
+	i386-sun)
+		os=-sunos4.0.2
+		;;
+	m68000-sun)
+		os=-sunos3
+		# This also exists in the configure program, but was not the
+		# default.
+		# os=-sunos4
+		;;
+	*-tti)	# must be before sparc entry or we get the wrong os.
+		os=-sysv3
+		;;
+	sparc-* | *-sun)
+		os=-sunos4.1.1
+		;;
+	*-be)
+		os=-beos
+		;;
+	*-ibm)
+		os=-aix
+		;;
+	*-hp)
+		os=-hpux
+		;;
+	*-hitachi)
+		os=-hiux
+		;;
+	i860-* | *-att | *-ncr | *-altos | *-motorola | *-convergent)
+		os=-sysv
+		;;
+	*-cbm)
+		os=-amigaos
+		;;
+	*-dg)
+		os=-dgux
+		;;
+	*-dolphin)
+		os=-sysv3
+		;;
+	m68k-ccur)
+		os=-rtu
+		;;
+	m88k-omron*)
+		os=-luna
+		;;
+	*-next )
+		os=-nextstep
+		;;
+	*-sequent)
+		os=-ptx
+		;;
+	*-crds)
+		os=-unos
+		;;
+	*-ns)
+		os=-genix
+		;;
+	i370-*)
+		os=-mvs
+		;;
+	*-next)
+		os=-nextstep3
+		;;
+        *-gould)
+		os=-sysv
+		;;
+        *-highlevel)
+		os=-bsd
+		;;
+	*-encore)
+		os=-bsd
+		;;
+        *-sgi)
+		os=-irix
+		;;
+        *-siemens)
+		os=-sysv4
+		;;
+	*-masscomp)
+		os=-rtu
+		;;
+	f301-fujitsu)
+		os=-uxpv
+		;;
+	*)
+		os=-none
+		;;
+esac
+fi
+
+# Here we handle the case where we know the os, and the CPU type, but not the
+# manufacturer.  We pick the logical manufacturer.
+vendor=unknown
+case $basic_machine in
+	*-unknown)
+		case $os in
+			-riscix*)
+				vendor=acorn
+				;;
+			-sunos*)
+				vendor=sun
+				;;
+			-aix*)
+				vendor=ibm
+				;;
+			-hpux*)
+				vendor=hp
+				;;
+			-mpeix*)
+				vendor=hp
+				;;
+			-mpeix*)
+				vendor=hp
+				;;
+			-hiux*)
+				vendor=hitachi
+				;;
+			-unos*)
+				vendor=crds
+				;;
+			-dgux*)
+				vendor=dg
+				;;
+			-luna*)
+				vendor=omron
+				;;
+			-genix*)
+				vendor=ns
+				;;
+			-mvs*)
+				vendor=ibm
+				;;
+			-ptx*)
+				vendor=sequent
+				;;
+			-vxsim* | -vxworks*)
+				vendor=wrs
+				;;
+			-aux*)
+				vendor=apple
+				;;
+		esac
+		basic_machine=`echo $basic_machine | sed "s/unknown/$vendor/"`
+		;;
+esac
+
+echo $basic_machine$os
diff -ruN WinQuake/configure sdlquake-1.0.9/configure
--- WinQuake/configure	Wed Dec 31 16:00:00 1969
+++ sdlquake-1.0.9/configure	Tue Dec 28 10:54:25 1999
@@ -0,0 +1,1745 @@
+#! /bin/sh
+
+# Guess values for system-dependent variables and create Makefiles.
+# Generated automatically using autoconf version 2.13 
+# Copyright (C) 1992, 93, 94, 95, 96 Free Software Foundation, Inc.
+#
+# This configure script is free software; the Free Software Foundation
+# gives unlimited permission to copy, distribute and modify it.
+
+# Defaults:
+ac_help=
+ac_default_prefix=/usr/local
+# Any additions from configure.in:
+ac_help="$ac_help
+  --with-sdl-prefix=PFX   Prefix where SDL is installed (optional)"
+ac_help="$ac_help
+  --with-sdl-exec-prefix=PFX Exec prefix where SDL is installed (optional)"
+ac_help="$ac_help
+  --disable-sdltest       Do not try to compile and run a test SDL program"
+ac_help="$ac_help
+  --enable-asm            enable i686 assembly routines [default=no]"
+
+# Initialize some variables set by options.
+# The variables have the same names as the options, with
+# dashes changed to underlines.
+build=NONE
+cache_file=./config.cache
+exec_prefix=NONE
+host=NONE
+no_create=
+nonopt=NONE
+no_recursion=
+prefix=NONE
+program_prefix=NONE
+program_suffix=NONE
+program_transform_name=s,x,x,
+silent=
+site=
+srcdir=
+target=NONE
+verbose=
+x_includes=NONE
+x_libraries=NONE
+bindir='${exec_prefix}/bin'
+sbindir='${exec_prefix}/sbin'
+libexecdir='${exec_prefix}/libexec'
+datadir='${prefix}/share'
+sysconfdir='${prefix}/etc'
+sharedstatedir='${prefix}/com'
+localstatedir='${prefix}/var'
+libdir='${exec_prefix}/lib'
+includedir='${prefix}/include'
+oldincludedir='/usr/include'
+infodir='${prefix}/info'
+mandir='${prefix}/man'
+
+# Initialize some other variables.
+subdirs=
+MFLAGS= MAKEFLAGS=
+SHELL=${CONFIG_SHELL-/bin/sh}
+# Maximum number of lines to put in a shell here document.
+ac_max_here_lines=12
+
+ac_prev=
+for ac_option
+do
+
+  # If the previous option needs an argument, assign it.
+  if test -n "$ac_prev"; then
+    eval "$ac_prev=\$ac_option"
+    ac_prev=
+    continue
+  fi
+
+  case "$ac_option" in
+  -*=*) ac_optarg=`echo "$ac_option" | sed 's/[-_a-zA-Z0-9]*=//'` ;;
+  *) ac_optarg= ;;
+  esac
+
+  # Accept the important Cygnus configure options, so we can diagnose typos.
+
+  case "$ac_option" in
+
+  -bindir | --bindir | --bindi | --bind | --bin | --bi)
+    ac_prev=bindir ;;
+  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
+    bindir="$ac_optarg" ;;
+
+  -build | --build | --buil | --bui | --bu)
+    ac_prev=build ;;
+  -build=* | --build=* | --buil=* | --bui=* | --bu=*)
+    build="$ac_optarg" ;;
+
+  -cache-file | --cache-file | --cache-fil | --cache-fi \
+  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
+    ac_prev=cache_file ;;
+  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
+  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
+    cache_file="$ac_optarg" ;;
+
+  -datadir | --datadir | --datadi | --datad | --data | --dat | --da)
+    ac_prev=datadir ;;
+  -datadir=* | --datadir=* | --datadi=* | --datad=* | --data=* | --dat=* \
+  | --da=*)
+    datadir="$ac_optarg" ;;
+
+  -disable-* | --disable-*)
+    ac_feature=`echo $ac_option|sed -e 's/-*disable-//'`
+    # Reject names that are not valid shell variable names.
+    if test -n "`echo $ac_feature| sed 's/[-a-zA-Z0-9_]//g'`"; then
+      { echo "configure: error: $ac_feature: invalid feature name" 1>&2; exit 1; }
+    fi
+    ac_feature=`echo $ac_feature| sed 's/-/_/g'`
+    eval "enable_${ac_feature}=no" ;;
+
+  -enable-* | --enable-*)
+    ac_feature=`echo $ac_option|sed -e 's/-*enable-//' -e 's/=.*//'`
+    # Reject names that are not valid shell variable names.
+    if test -n "`echo $ac_feature| sed 's/[-_a-zA-Z0-9]//g'`"; then
+      { echo "configure: error: $ac_feature: invalid feature name" 1>&2; exit 1; }
+    fi
+    ac_feature=`echo $ac_feature| sed 's/-/_/g'`
+    case "$ac_option" in
+      *=*) ;;
+      *) ac_optarg=yes ;;
+    esac
+    eval "enable_${ac_feature}='$ac_optarg'" ;;
+
+  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
+  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
+  | --exec | --exe | --ex)
+    ac_prev=exec_prefix ;;
+  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
+  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
+  | --exec=* | --exe=* | --ex=*)
+    exec_prefix="$ac_optarg" ;;
+
+  -gas | --gas | --ga | --g)
+    # Obsolete; use --with-gas.
+    with_gas=yes ;;
+
+  -help | --help | --hel | --he)
+    # Omit some internal or obsolete options to make the list less imposing.
+    # This message is too long to be a string in the A/UX 3.1 sh.
+    cat << EOF
+Usage: configure [options] [host]
+Options: [defaults in brackets after descriptions]
+Configuration:
+  --cache-file=FILE       cache test results in FILE
+  --help                  print this message
+  --no-create             do not create output files
+  --quiet, --silent       do not print \`checking...' messages
+  --version               print the version of autoconf that created configure
+Directory and file names:
+  --prefix=PREFIX         install architecture-independent files in PREFIX
+                          [$ac_default_prefix]
+  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
+                          [same as prefix]
+  --bindir=DIR            user executables in DIR [EPREFIX/bin]
+  --sbindir=DIR           system admin executables in DIR [EPREFIX/sbin]
+  --libexecdir=DIR        program executables in DIR [EPREFIX/libexec]
+  --datadir=DIR           read-only architecture-independent data in DIR
+                          [PREFIX/share]
+  --sysconfdir=DIR        read-only single-machine data in DIR [PREFIX/etc]
+  --sharedstatedir=DIR    modifiable architecture-independent data in DIR
+                          [PREFIX/com]
+  --localstatedir=DIR     modifiable single-machine data in DIR [PREFIX/var]
+  --libdir=DIR            object code libraries in DIR [EPREFIX/lib]
+  --includedir=DIR        C header files in DIR [PREFIX/include]
+  --oldincludedir=DIR     C header files for non-gcc in DIR [/usr/include]
+  --infodir=DIR           info documentation in DIR [PREFIX/info]
+  --mandir=DIR            man documentation in DIR [PREFIX/man]
+  --srcdir=DIR            find the sources in DIR [configure dir or ..]
+  --program-prefix=PREFIX prepend PREFIX to installed program names
+  --program-suffix=SUFFIX append SUFFIX to installed program names
+  --program-transform-name=PROGRAM
+                          run sed PROGRAM on installed program names
+EOF
+    cat << EOF
+Host type:
+  --build=BUILD           configure for building on BUILD [BUILD=HOST]
+  --host=HOST             configure for HOST [guessed]
+  --target=TARGET         configure for TARGET [TARGET=HOST]
+Features and packages:
+  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
+  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
+  --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
+  --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
+  --x-includes=DIR        X include files are in DIR
+  --x-libraries=DIR       X library files are in DIR
+EOF
+    if test -n "$ac_help"; then
+      echo "--enable and --with options recognized:$ac_help"
+    fi
+    exit 0 ;;
+
+  -host | --host | --hos | --ho)
+    ac_prev=host ;;
+  -host=* | --host=* | --hos=* | --ho=*)
+    host="$ac_optarg" ;;
+
+  -includedir | --includedir | --includedi | --included | --include \
+  | --includ | --inclu | --incl | --inc)
+    ac_prev=includedir ;;
+  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
+  | --includ=* | --inclu=* | --incl=* | --inc=*)
+    includedir="$ac_optarg" ;;
+
+  -infodir | --infodir | --infodi | --infod | --info | --inf)
+    ac_prev=infodir ;;
+  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
+    infodir="$ac_optarg" ;;
+
+  -libdir | --libdir | --libdi | --libd)
+    ac_prev=libdir ;;
+  -libdir=* | --libdir=* | --libdi=* | --libd=*)
+    libdir="$ac_optarg" ;;
+
+  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
+  | --libexe | --libex | --libe)
+    ac_prev=libexecdir ;;
+  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
+  | --libexe=* | --libex=* | --libe=*)
+    libexecdir="$ac_optarg" ;;
+
+  -localstatedir | --localstatedir | --localstatedi | --localstated \
+  | --localstate | --localstat | --localsta | --localst \
+  | --locals | --local | --loca | --loc | --lo)
+    ac_prev=localstatedir ;;
+  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
+  | --localstate=* | --localstat=* | --localsta=* | --localst=* \
+  | --locals=* | --local=* | --loca=* | --loc=* | --lo=*)
+    localstatedir="$ac_optarg" ;;
+
+  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
+    ac_prev=mandir ;;
+  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
+    mandir="$ac_optarg" ;;
+
+  -nfp | --nfp | --nf)
+    # Obsolete; use --without-fp.
+    with_fp=no ;;
+
+  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
+  | --no-cr | --no-c)
+    no_create=yes ;;
+
+  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
+  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
+    no_recursion=yes ;;
+
+  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \
+  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \
+  | --oldin | --oldi | --old | --ol | --o)
+    ac_prev=oldincludedir ;;
+  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \
+  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
+  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
+    oldincludedir="$ac_optarg" ;;
+
+  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
+    ac_prev=prefix ;;
+  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
+    prefix="$ac_optarg" ;;
+
+  -program-prefix | --program-prefix | --program-prefi | --program-pref \
+  | --program-pre | --program-pr | --program-p)
+    ac_prev=program_prefix ;;
+  -program-prefix=* | --program-prefix=* | --program-prefi=* \
+  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
+    program_prefix="$ac_optarg" ;;
+
+  -program-suffix | --program-suffix | --program-suffi | --program-suff \
+  | --program-suf | --program-su | --program-s)
+    ac_prev=program_suffix ;;
+  -program-suffix=* | --program-suffix=* | --program-suffi=* \
+  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
+    program_suffix="$ac_optarg" ;;
+
+  -program-transform-name | --program-transform-name \
+  | --program-transform-nam | --program-transform-na \
+  | --program-transform-n | --program-transform- \
+  | --program-transform | --program-transfor \
+  | --program-transfo | --program-transf \
+  | --program-trans | --program-tran \
+  | --progr-tra | --program-tr | --program-t)
+    ac_prev=program_transform_name ;;
+  -program-transform-name=* | --program-transform-name=* \
+  | --program-transform-nam=* | --program-transform-na=* \
+  | --program-transform-n=* | --program-transform-=* \
+  | --program-transform=* | --program-transfor=* \
+  | --program-transfo=* | --program-transf=* \
+  | --program-trans=* | --program-tran=* \
+  | --progr-tra=* | --program-tr=* | --program-t=*)
+    program_transform_name="$ac_optarg" ;;
+
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil)
+    silent=yes ;;
+
+  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
+    ac_prev=sbindir ;;
+  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
+  | --sbi=* | --sb=*)
+    sbindir="$ac_optarg" ;;
+
+  -sharedstatedir | --sharedstatedir | --sharedstatedi \
+  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \
+  | --sharedst | --shareds | --shared | --share | --shar \
+  | --sha | --sh)
+    ac_prev=sharedstatedir ;;
+  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \
+  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \
+  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
+  | --sha=* | --sh=*)
+    sharedstatedir="$ac_optarg" ;;
+
+  -site | --site | --sit)
+    ac_prev=site ;;
+  -site=* | --site=* | --sit=*)
+    site="$ac_optarg" ;;
+
+  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
+    ac_prev=srcdir ;;
+  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
+    srcdir="$ac_optarg" ;;
+
+  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
+  | --syscon | --sysco | --sysc | --sys | --sy)
+    ac_prev=sysconfdir ;;
+  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
+  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
+    sysconfdir="$ac_optarg" ;;
+
+  -target | --target | --targe | --targ | --tar | --ta | --t)
+    ac_prev=target ;;
+  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
+    target="$ac_optarg" ;;
+
+  -v | -verbose | --verbose | --verbos | --verbo | --verb)
+    verbose=yes ;;
+
+  -version | --version | --versio | --versi | --vers)
+    echo "configure generated by autoconf version 2.13"
+    exit 0 ;;
+
+  -with-* | --with-*)
+    ac_package=`echo $ac_option|sed -e 's/-*with-//' -e 's/=.*//'`
+    # Reject names that are not valid shell variable names.
+    if test -n "`echo $ac_package| sed 's/[-_a-zA-Z0-9]//g'`"; then
+      { echo "configure: error: $ac_package: invalid package name" 1>&2; exit 1; }
+    fi
+    ac_package=`echo $ac_package| sed 's/-/_/g'`
+    case "$ac_option" in
+      *=*) ;;
+      *) ac_optarg=yes ;;
+    esac
+    eval "with_${ac_package}='$ac_optarg'" ;;
+
+  -without-* | --without-*)
+    ac_package=`echo $ac_option|sed -e 's/-*without-//'`
+    # Reject names that are not valid shell variable names.
+    if test -n "`echo $ac_package| sed 's/[-a-zA-Z0-9_]//g'`"; then
+      { echo "configure: error: $ac_package: invalid package name" 1>&2; exit 1; }
+    fi
+    ac_package=`echo $ac_package| sed 's/-/_/g'`
+    eval "with_${ac_package}=no" ;;
+
+  --x)
+    # Obsolete; use --with-x.
+    with_x=yes ;;
+
+  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
+  | --x-incl | --x-inc | --x-in | --x-i)
+    ac_prev=x_includes ;;
+  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
+  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
+    x_includes="$ac_optarg" ;;
+
+  -x-libraries | --x-libraries | --x-librarie | --x-librari \
+  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
+    ac_prev=x_libraries ;;
+  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
+  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
+    x_libraries="$ac_optarg" ;;
+
+  -*) { echo "configure: error: $ac_option: invalid option; use --help to show usage" 1>&2; exit 1; }
+    ;;
+
+  *)
+    if test -n "`echo $ac_option| sed 's/[-a-z0-9.]//g'`"; then
+      echo "configure: warning: $ac_option: invalid host type" 1>&2
+    fi
+    if test "x$nonopt" != xNONE; then
+      { echo "configure: error: can only configure for one host and one target at a time" 1>&2; exit 1; }
+    fi
+    nonopt="$ac_option"
+    ;;
+
+  esac
+done
+
+if test -n "$ac_prev"; then
+  { echo "configure: error: missing argument to --`echo $ac_prev | sed 's/_/-/g'`" 1>&2; exit 1; }
+fi
+
+trap 'rm -fr conftest* confdefs* core core.* *.core $ac_clean_files; exit 1' 1 2 15
+
+# File descriptor usage:
+# 0 standard input
+# 1 file creation
+# 2 errors and warnings
+# 3 some systems may open it to /dev/tty
+# 4 used on the Kubota Titan
+# 6 checking for... messages and results
+# 5 compiler messages saved in config.log
+if test "$silent" = yes; then
+  exec 6>/dev/null
+else
+  exec 6>&1
+fi
+exec 5>./config.log
+
+echo "\
+This file contains any messages produced by compilers while
+running configure, to aid debugging if configure makes a mistake.
+" 1>&5
+
+# Strip out --no-create and --no-recursion so they do not pile up.
+# Also quote any args containing shell metacharacters.
+ac_configure_args=
+for ac_arg
+do
+  case "$ac_arg" in
+  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
+  | --no-cr | --no-c) ;;
+  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
+  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r) ;;
+  *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?]*)
+  ac_configure_args="$ac_configure_args '$ac_arg'" ;;
+  *) ac_configure_args="$ac_configure_args $ac_arg" ;;
+  esac
+done
+
+# NLS nuisances.
+# Only set these to C if already set.  These must not be set unconditionally
+# because not all systems understand e.g. LANG=C (notably SCO).
+# Fixing LC_MESSAGES prevents Solaris sh from translating var values in `set'!
+# Non-C LC_CTYPE values break the ctype check.
+if test "${LANG+set}"   = set; then LANG=C;   export LANG;   fi
+if test "${LC_ALL+set}" = set; then LC_ALL=C; export LC_ALL; fi
+if test "${LC_MESSAGES+set}" = set; then LC_MESSAGES=C; export LC_MESSAGES; fi
+if test "${LC_CTYPE+set}"    = set; then LC_CTYPE=C;    export LC_CTYPE;    fi
+
+# confdefs.h avoids OS command line length limits that DEFS can exceed.
+rm -rf conftest* confdefs.h
+# AIX cpp loses on an empty file, so make sure it contains at least a newline.
+echo > confdefs.h
+
+# A filename unique to this package, relative to the directory that
+# configure is in, which we can look for to find out if srcdir is correct.
+ac_unique_file=README.SDL
+
+# Find the source files, if location was not specified.
+if test -z "$srcdir"; then
+  ac_srcdir_defaulted=yes
+  # Try the directory containing this script, then its parent.
+  ac_prog=$0
+  ac_confdir=`echo $ac_prog|sed 's%/[^/][^/]*$%%'`
+  test "x$ac_confdir" = "x$ac_prog" && ac_confdir=.
+  srcdir=$ac_confdir
+  if test ! -r $srcdir/$ac_unique_file; then
+    srcdir=..
+  fi
+else
+  ac_srcdir_defaulted=no
+fi
+if test ! -r $srcdir/$ac_unique_file; then
+  if test "$ac_srcdir_defaulted" = yes; then
+    { echo "configure: error: can not find sources in $ac_confdir or .." 1>&2; exit 1; }
+  else
+    { echo "configure: error: can not find sources in $srcdir" 1>&2; exit 1; }
+  fi
+fi
+srcdir=`echo "${srcdir}" | sed 's%\([^/]\)/*$%\1%'`
+
+# Prefer explicitly selected file to automatically selected ones.
+if test -z "$CONFIG_SITE"; then
+  if test "x$prefix" != xNONE; then
+    CONFIG_SITE="$prefix/share/config.site $prefix/etc/config.site"
+  else
+    CONFIG_SITE="$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site"
+  fi
+fi
+for ac_site_file in $CONFIG_SITE; do
+  if test -r "$ac_site_file"; then
+    echo "loading site script $ac_site_file"
+    . "$ac_site_file"
+  fi
+done
+
+if test -r "$cache_file"; then
+  echo "loading cache $cache_file"
+  . $cache_file
+else
+  echo "creating cache $cache_file"
+  > $cache_file
+fi
+
+ac_ext=c
+# CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='${CC-cc} -c $CFLAGS $CPPFLAGS conftest.$ac_ext 1>&5'
+ac_link='${CC-cc} -o conftest${ac_exeext} $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
+cross_compiling=$ac_cv_prog_cc_cross
+
+ac_exeext=
+ac_objext=o
+if (echo "testing\c"; echo 1,2,3) | grep c >/dev/null; then
+  # Stardent Vistra SVR4 grep lacks -e, says ghazi@caip.rutgers.edu.
+  if (echo -n testing; echo 1,2,3) | sed s/-n/xn/ | grep xn >/dev/null; then
+    ac_n= ac_c='
+' ac_t='	'
+  else
+    ac_n=-n ac_c= ac_t=
+  fi
+else
+  ac_n= ac_c='\c' ac_t=
+fi
+
+
+
+ac_aux_dir=
+for ac_dir in $srcdir $srcdir/.. $srcdir/../..; do
+  if test -f $ac_dir/install-sh; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install-sh -c"
+    break
+  elif test -f $ac_dir/install.sh; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install.sh -c"
+    break
+  fi
+done
+if test -z "$ac_aux_dir"; then
+  { echo "configure: error: can not find install-sh or install.sh in $srcdir $srcdir/.. $srcdir/../.." 1>&2; exit 1; }
+fi
+ac_config_guess=$ac_aux_dir/config.guess
+ac_config_sub=$ac_aux_dir/config.sub
+ac_configure=$ac_aux_dir/configure # This should be Cygnus configure.
+
+# Find a good install program.  We prefer a C program (faster),
+# so one script is as good as another.  But avoid the broken or
+# incompatible versions:
+# SysV /etc/install, /usr/sbin/install
+# SunOS /usr/etc/install
+# IRIX /sbin/install
+# AIX /bin/install
+# AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
+# AFS /usr/afsws/bin/install, which mishandles nonexistent args
+# SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
+# ./install, which can be erroneously created by make from ./install.sh.
+echo $ac_n "checking for a BSD compatible install""... $ac_c" 1>&6
+echo "configure:565: checking for a BSD compatible install" >&5
+if test -z "$INSTALL"; then
+if eval "test \"`echo '$''{'ac_cv_path_install'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+    IFS="${IFS= 	}"; ac_save_IFS="$IFS"; IFS=":"
+  for ac_dir in $PATH; do
+    # Account for people who put trailing slashes in PATH elements.
+    case "$ac_dir/" in
+    /|./|.//|/etc/*|/usr/sbin/*|/usr/etc/*|/sbin/*|/usr/afsws/bin/*|/usr/ucb/*) ;;
+    *)
+      # OSF1 and SCO ODT 3.0 have their own names for install.
+      # Don't use installbsd from OSF since it installs stuff as root
+      # by default.
+      for ac_prog in ginstall scoinst install; do
+        if test -f $ac_dir/$ac_prog; then
+	  if test $ac_prog = install &&
+            grep dspmsg $ac_dir/$ac_prog >/dev/null 2>&1; then
+	    # AIX install.  It has an incompatible calling convention.
+	    :
+	  else
+	    ac_cv_path_install="$ac_dir/$ac_prog -c"
+	    break 2
+	  fi
+	fi
+      done
+      ;;
+    esac
+  done
+  IFS="$ac_save_IFS"
+
+fi
+  if test "${ac_cv_path_install+set}" = set; then
+    INSTALL="$ac_cv_path_install"
+  else
+    # As a last resort, use the slow shell script.  We don't cache a
+    # path for INSTALL within a source directory, because that will
+    # break other packages using the cache if that directory is
+    # removed, or if the path is relative.
+    INSTALL="$ac_install_sh"
+  fi
+fi
+echo "$ac_t""$INSTALL" 1>&6
+
+# Use test -z because SunOS4 sh mishandles braces in ${var-val}.
+# It thinks the first close brace ends the variable substitution.
+test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
+
+test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL_PROGRAM}'
+
+test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
+
+echo $ac_n "checking whether build environment is sane""... $ac_c" 1>&6
+echo "configure:618: checking whether build environment is sane" >&5
+# Just in case
+sleep 1
+echo timestamp > conftestfile
+# Do `set' in a subshell so we don't clobber the current shell's
+# arguments.  Must try -L first in case configure is actually a
+# symlink; some systems play weird games with the mod time of symlinks
+# (eg FreeBSD returns the mod time of the symlink's containing
+# directory).
+if (
+   set X `ls -Lt $srcdir/configure conftestfile 2> /dev/null`
+   if test "$*" = "X"; then
+      # -L didn't work.
+      set X `ls -t $srcdir/configure conftestfile`
+   fi
+   if test "$*" != "X $srcdir/configure conftestfile" \
+      && test "$*" != "X conftestfile $srcdir/configure"; then
+
+      # If neither matched, then we have a broken ls.  This can happen
+      # if, for instance, CONFIG_SHELL is bash and it inherits a
+      # broken ls alias from the environment.  This has actually
+      # happened.  Such a system could not be considered "sane".
+      { echo "configure: error: ls -t appears to fail.  Make sure there is not a broken
+alias in your environment" 1>&2; exit 1; }
+   fi
+
+   test "$2" = conftestfile
+   )
+then
+   # Ok.
+   :
+else
+   { echo "configure: error: newly created file is older than distributed files!
+Check your system clock" 1>&2; exit 1; }
+fi
+rm -f conftest*
+echo "$ac_t""yes" 1>&6
+if test "$program_transform_name" = s,x,x,; then
+  program_transform_name=
+else
+  # Double any \ or $.  echo might interpret backslashes.
+  cat <<\EOF_SED > conftestsed
+s,\\,\\\\,g; s,\$,$$,g
+EOF_SED
+  program_transform_name="`echo $program_transform_name|sed -f conftestsed`"
+  rm -f conftestsed
+fi
+test "$program_prefix" != NONE &&
+  program_transform_name="s,^,${program_prefix},; $program_transform_name"
+# Use a double $ so make ignores it.
+test "$program_suffix" != NONE &&
+  program_transform_name="s,\$\$,${program_suffix},; $program_transform_name"
+
+# sed with no file args requires a program.
+test "$program_transform_name" = "" && program_transform_name="s,x,x,"
+
+echo $ac_n "checking whether ${MAKE-make} sets \${MAKE}""... $ac_c" 1>&6
+echo "configure:675: checking whether ${MAKE-make} sets \${MAKE}" >&5
+set dummy ${MAKE-make}; ac_make=`echo "$2" | sed 'y%./+-%__p_%'`
+if eval "test \"`echo '$''{'ac_cv_prog_make_${ac_make}_set'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftestmake <<\EOF
+all:
+	@echo 'ac_maketemp="${MAKE}"'
+EOF
+# GNU make sometimes prints "make[1]: Entering...", which would confuse us.
+eval `${MAKE-make} -f conftestmake 2>/dev/null | grep temp=`
+if test -n "$ac_maketemp"; then
+  eval ac_cv_prog_make_${ac_make}_set=yes
+else
+  eval ac_cv_prog_make_${ac_make}_set=no
+fi
+rm -f conftestmake
+fi
+if eval "test \"`echo '$ac_cv_prog_make_'${ac_make}_set`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+  SET_MAKE=
+else
+  echo "$ac_t""no" 1>&6
+  SET_MAKE="MAKE=${MAKE-make}"
+fi
+
+
+PACKAGE=sdlquake
+
+VERSION=1.0.9
+
+if test "`cd $srcdir && pwd`" != "`pwd`" && test -f $srcdir/config.status; then
+  { echo "configure: error: source directory already configured; run "make distclean" there first" 1>&2; exit 1; }
+fi
+cat >> confdefs.h <<EOF
+#define PACKAGE "$PACKAGE"
+EOF
+
+cat >> confdefs.h <<EOF
+#define VERSION "$VERSION"
+EOF
+
+
+
+missing_dir=`cd $ac_aux_dir && pwd`
+echo $ac_n "checking for working aclocal""... $ac_c" 1>&6
+echo "configure:721: checking for working aclocal" >&5
+# Run test in a subshell; some versions of sh will print an error if
+# an executable is not found, even if stderr is redirected.
+# Redirect stdin to placate older versions of autoconf.  Sigh.
+if (aclocal --version) < /dev/null > /dev/null 2>&1; then
+   ACLOCAL=aclocal
+   echo "$ac_t""found" 1>&6
+else
+   ACLOCAL="$missing_dir/missing aclocal"
+   echo "$ac_t""missing" 1>&6
+fi
+
+echo $ac_n "checking for working autoconf""... $ac_c" 1>&6
+echo "configure:734: checking for working autoconf" >&5
+# Run test in a subshell; some versions of sh will print an error if
+# an executable is not found, even if stderr is redirected.
+# Redirect stdin to placate older versions of autoconf.  Sigh.
+if (autoconf --version) < /dev/null > /dev/null 2>&1; then
+   AUTOCONF=autoconf
+   echo "$ac_t""found" 1>&6
+else
+   AUTOCONF="$missing_dir/missing autoconf"
+   echo "$ac_t""missing" 1>&6
+fi
+
+echo $ac_n "checking for working automake""... $ac_c" 1>&6
+echo "configure:747: checking for working automake" >&5
+# Run test in a subshell; some versions of sh will print an error if
+# an executable is not found, even if stderr is redirected.
+# Redirect stdin to placate older versions of autoconf.  Sigh.
+if (automake --version) < /dev/null > /dev/null 2>&1; then
+   AUTOMAKE=automake
+   echo "$ac_t""found" 1>&6
+else
+   AUTOMAKE="$missing_dir/missing automake"
+   echo "$ac_t""missing" 1>&6
+fi
+
+echo $ac_n "checking for working autoheader""... $ac_c" 1>&6
+echo "configure:760: checking for working autoheader" >&5
+# Run test in a subshell; some versions of sh will print an error if
+# an executable is not found, even if stderr is redirected.
+# Redirect stdin to placate older versions of autoconf.  Sigh.
+if (autoheader --version) < /dev/null > /dev/null 2>&1; then
+   AUTOHEADER=autoheader
+   echo "$ac_t""found" 1>&6
+else
+   AUTOHEADER="$missing_dir/missing autoheader"
+   echo "$ac_t""missing" 1>&6
+fi
+
+echo $ac_n "checking for working makeinfo""... $ac_c" 1>&6
+echo "configure:773: checking for working makeinfo" >&5
+# Run test in a subshell; some versions of sh will print an error if
+# an executable is not found, even if stderr is redirected.
+# Redirect stdin to placate older versions of autoconf.  Sigh.
+if (makeinfo --version) < /dev/null > /dev/null 2>&1; then
+   MAKEINFO=makeinfo
+   echo "$ac_t""found" 1>&6
+else
+   MAKEINFO="$missing_dir/missing makeinfo"
+   echo "$ac_t""missing" 1>&6
+fi
+
+
+
+
+# Make sure we can run config.sub.
+if ${CONFIG_SHELL-/bin/sh} $ac_config_sub sun4 >/dev/null 2>&1; then :
+else { echo "configure: error: can not run $ac_config_sub" 1>&2; exit 1; }
+fi
+
+echo $ac_n "checking host system type""... $ac_c" 1>&6
+echo "configure:794: checking host system type" >&5
+
+host_alias=$host
+case "$host_alias" in
+NONE)
+  case $nonopt in
+  NONE)
+    if host_alias=`${CONFIG_SHELL-/bin/sh} $ac_config_guess`; then :
+    else { echo "configure: error: can not guess host type; you must specify one" 1>&2; exit 1; }
+    fi ;;
+  *) host_alias=$nonopt ;;
+  esac ;;
+esac
+
+host=`${CONFIG_SHELL-/bin/sh} $ac_config_sub $host_alias`
+host_cpu=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+host_vendor=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+host_os=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+echo "$ac_t""$host" 1>&6
+
+echo $ac_n "checking target system type""... $ac_c" 1>&6
+echo "configure:815: checking target system type" >&5
+
+target_alias=$target
+case "$target_alias" in
+NONE)
+  case $nonopt in
+  NONE) target_alias=$host_alias ;;
+  *) target_alias=$nonopt ;;
+  esac ;;
+esac
+
+target=`${CONFIG_SHELL-/bin/sh} $ac_config_sub $target_alias`
+target_cpu=`echo $target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+target_vendor=`echo $target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+target_os=`echo $target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+echo "$ac_t""$target" 1>&6
+
+
+
+echo $ac_n "checking whether ${MAKE-make} sets \${MAKE}""... $ac_c" 1>&6
+echo "configure:835: checking whether ${MAKE-make} sets \${MAKE}" >&5
+set dummy ${MAKE-make}; ac_make=`echo "$2" | sed 'y%./+-%__p_%'`
+if eval "test \"`echo '$''{'ac_cv_prog_make_${ac_make}_set'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftestmake <<\EOF
+all:
+	@echo 'ac_maketemp="${MAKE}"'
+EOF
+# GNU make sometimes prints "make[1]: Entering...", which would confuse us.
+eval `${MAKE-make} -f conftestmake 2>/dev/null | grep temp=`
+if test -n "$ac_maketemp"; then
+  eval ac_cv_prog_make_${ac_make}_set=yes
+else
+  eval ac_cv_prog_make_${ac_make}_set=no
+fi
+rm -f conftestmake
+fi
+if eval "test \"`echo '$ac_cv_prog_make_'${ac_make}_set`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+  SET_MAKE=
+else
+  echo "$ac_t""no" 1>&6
+  SET_MAKE="MAKE=${MAKE-make}"
+fi
+
+# Extract the first word of "gcc", so it can be a program name with args.
+set dummy gcc; ac_word=$2
+echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
+echo "configure:864: checking for $ac_word" >&5
+if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
+  ac_dummy="$PATH"
+  for ac_dir in $ac_dummy; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      ac_cv_prog_CC="gcc"
+      break
+    fi
+  done
+  IFS="$ac_save_ifs"
+fi
+fi
+CC="$ac_cv_prog_CC"
+if test -n "$CC"; then
+  echo "$ac_t""$CC" 1>&6
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+if test -z "$CC"; then
+  # Extract the first word of "cc", so it can be a program name with args.
+set dummy cc; ac_word=$2
+echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
+echo "configure:894: checking for $ac_word" >&5
+if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
+  ac_prog_rejected=no
+  ac_dummy="$PATH"
+  for ac_dir in $ac_dummy; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      if test "$ac_dir/$ac_word" = "/usr/ucb/cc"; then
+        ac_prog_rejected=yes
+	continue
+      fi
+      ac_cv_prog_CC="cc"
+      break
+    fi
+  done
+  IFS="$ac_save_ifs"
+if test $ac_prog_rejected = yes; then
+  # We found a bogon in the path, so make sure we never use it.
+  set dummy $ac_cv_prog_CC
+  shift
+  if test $# -gt 0; then
+    # We chose a different compiler from the bogus one.
+    # However, it has the same basename, so the bogon will be chosen
+    # first if we set CC to just the basename; use the full file name.
+    shift
+    set dummy "$ac_dir/$ac_word" "$@"
+    shift
+    ac_cv_prog_CC="$@"
+  fi
+fi
+fi
+fi
+CC="$ac_cv_prog_CC"
+if test -n "$CC"; then
+  echo "$ac_t""$CC" 1>&6
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+  if test -z "$CC"; then
+    case "`uname -s`" in
+    *win32* | *WIN32*)
+      # Extract the first word of "cl", so it can be a program name with args.
+set dummy cl; ac_word=$2
+echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
+echo "configure:945: checking for $ac_word" >&5
+if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
+  ac_dummy="$PATH"
+  for ac_dir in $ac_dummy; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      ac_cv_prog_CC="cl"
+      break
+    fi
+  done
+  IFS="$ac_save_ifs"
+fi
+fi
+CC="$ac_cv_prog_CC"
+if test -n "$CC"; then
+  echo "$ac_t""$CC" 1>&6
+else
+  echo "$ac_t""no" 1>&6
+fi
+ ;;
+    esac
+  fi
+  test -z "$CC" && { echo "configure: error: no acceptable cc found in \$PATH" 1>&2; exit 1; }
+fi
+
+echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works""... $ac_c" 1>&6
+echo "configure:977: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
+
+ac_ext=c
+# CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='${CC-cc} -c $CFLAGS $CPPFLAGS conftest.$ac_ext 1>&5'
+ac_link='${CC-cc} -o conftest${ac_exeext} $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
+cross_compiling=$ac_cv_prog_cc_cross
+
+cat > conftest.$ac_ext << EOF
+
+#line 988 "configure"
+#include "confdefs.h"
+
+main(){return(0);}
+EOF
+if { (eval echo configure:993: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  ac_cv_prog_cc_works=yes
+  # If we can't run a trivial program, we are probably using a cross compiler.
+  if (./conftest; exit) 2>/dev/null; then
+    ac_cv_prog_cc_cross=no
+  else
+    ac_cv_prog_cc_cross=yes
+  fi
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  ac_cv_prog_cc_works=no
+fi
+rm -fr conftest*
+ac_ext=c
+# CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='${CC-cc} -c $CFLAGS $CPPFLAGS conftest.$ac_ext 1>&5'
+ac_link='${CC-cc} -o conftest${ac_exeext} $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
+cross_compiling=$ac_cv_prog_cc_cross
+
+echo "$ac_t""$ac_cv_prog_cc_works" 1>&6
+if test $ac_cv_prog_cc_works = no; then
+  { echo "configure: error: installation or configuration problem: C compiler cannot create executables." 1>&2; exit 1; }
+fi
+echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler""... $ac_c" 1>&6
+echo "configure:1019: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
+echo "$ac_t""$ac_cv_prog_cc_cross" 1>&6
+cross_compiling=$ac_cv_prog_cc_cross
+
+echo $ac_n "checking whether we are using GNU C""... $ac_c" 1>&6
+echo "configure:1024: checking whether we are using GNU C" >&5
+if eval "test \"`echo '$''{'ac_cv_prog_gcc'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.c <<EOF
+#ifdef __GNUC__
+  yes;
+#endif
+EOF
+if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1033: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
+  ac_cv_prog_gcc=yes
+else
+  ac_cv_prog_gcc=no
+fi
+fi
+
+echo "$ac_t""$ac_cv_prog_gcc" 1>&6
+
+if test $ac_cv_prog_gcc = yes; then
+  GCC=yes
+else
+  GCC=
+fi
+
+ac_test_CFLAGS="${CFLAGS+set}"
+ac_save_CFLAGS="$CFLAGS"
+CFLAGS=
+echo $ac_n "checking whether ${CC-cc} accepts -g""... $ac_c" 1>&6
+echo "configure:1052: checking whether ${CC-cc} accepts -g" >&5
+if eval "test \"`echo '$''{'ac_cv_prog_cc_g'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  echo 'void f(){}' > conftest.c
+if test -z "`${CC-cc} -g -c conftest.c 2>&1`"; then
+  ac_cv_prog_cc_g=yes
+else
+  ac_cv_prog_cc_g=no
+fi
+rm -f conftest*
+
+fi
+
+echo "$ac_t""$ac_cv_prog_cc_g" 1>&6
+if test "$ac_test_CFLAGS" = set; then
+  CFLAGS="$ac_save_CFLAGS"
+elif test $ac_cv_prog_cc_g = yes; then
+  if test "$GCC" = yes; then
+    CFLAGS="-g -O2"
+  else
+    CFLAGS="-g"
+  fi
+else
+  if test "$GCC" = yes; then
+    CFLAGS="-O2"
+  else
+    CFLAGS=
+  fi
+fi
+
+# Find a good install program.  We prefer a C program (faster),
+# so one script is as good as another.  But avoid the broken or
+# incompatible versions:
+# SysV /etc/install, /usr/sbin/install
+# SunOS /usr/etc/install
+# IRIX /sbin/install
+# AIX /bin/install
+# AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
+# AFS /usr/afsws/bin/install, which mishandles nonexistent args
+# SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
+# ./install, which can be erroneously created by make from ./install.sh.
+echo $ac_n "checking for a BSD compatible install""... $ac_c" 1>&6
+echo "configure:1095: checking for a BSD compatible install" >&5
+if test -z "$INSTALL"; then
+if eval "test \"`echo '$''{'ac_cv_path_install'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+    IFS="${IFS= 	}"; ac_save_IFS="$IFS"; IFS=":"
+  for ac_dir in $PATH; do
+    # Account for people who put trailing slashes in PATH elements.
+    case "$ac_dir/" in
+    /|./|.//|/etc/*|/usr/sbin/*|/usr/etc/*|/sbin/*|/usr/afsws/bin/*|/usr/ucb/*) ;;
+    *)
+      # OSF1 and SCO ODT 3.0 have their own names for install.
+      # Don't use installbsd from OSF since it installs stuff as root
+      # by default.
+      for ac_prog in ginstall scoinst install; do
+        if test -f $ac_dir/$ac_prog; then
+	  if test $ac_prog = install &&
+            grep dspmsg $ac_dir/$ac_prog >/dev/null 2>&1; then
+	    # AIX install.  It has an incompatible calling convention.
+	    :
+	  else
+	    ac_cv_path_install="$ac_dir/$ac_prog -c"
+	    break 2
+	  fi
+	fi
+      done
+      ;;
+    esac
+  done
+  IFS="$ac_save_IFS"
+
+fi
+  if test "${ac_cv_path_install+set}" = set; then
+    INSTALL="$ac_cv_path_install"
+  else
+    # As a last resort, use the slow shell script.  We don't cache a
+    # path for INSTALL within a source directory, because that will
+    # break other packages using the cache if that directory is
+    # removed, or if the path is relative.
+    INSTALL="$ac_install_sh"
+  fi
+fi
+echo "$ac_t""$INSTALL" 1>&6
+
+# Use test -z because SunOS4 sh mishandles braces in ${var-val}.
+# It thinks the first close brace ends the variable substitution.
+test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
+
+test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL_PROGRAM}'
+
+test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
+
+
+echo $ac_n "checking target system type""... $ac_c" 1>&6
+echo "configure:1149: checking target system type" >&5
+
+target_alias=$target
+case "$target_alias" in
+NONE)
+  case $nonopt in
+  NONE) target_alias=$host_alias ;;
+  *) target_alias=$nonopt ;;
+  esac ;;
+esac
+
+target=`${CONFIG_SHELL-/bin/sh} $ac_config_sub $target_alias`
+target_cpu=`echo $target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+target_vendor=`echo $target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+target_os=`echo $target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+echo "$ac_t""$target" 1>&6
+
+case "$target" in
+    i686-*-linux*)
+        CFLAGS="-g -mpentiumpro -O6 -ffast-math -funroll-loops -fomit-frame-pointer -fexpensive-optimizations"
+        #CFLAGS="-g -mpentiumpro -O6 -ffast-math -funroll-loops -fexpensive-optimizations"
+        ;;
+    alpha*-*-linux*)
+        CFLAGS="$CFLAGS -mcpu=ev4 -Wa,-mall"
+        ;;
+esac
+
+case "$target" in
+    *-*-mingw32*)
+        MATHLIB=""
+        INETLIB="-lwsock32"
+        ;;
+    *-*-beos*)
+        MATHLIB=""
+        INETLIB=""
+        ;;
+    *)
+        MATHLIB="-lm"
+        INETLIB=""
+        ;;
+esac
+
+
+
+SDL_VERSION=1.0.1
+# Check whether --with-sdl-prefix or --without-sdl-prefix was given.
+if test "${with_sdl_prefix+set}" = set; then
+  withval="$with_sdl_prefix"
+  sdl_prefix="$withval"
+else
+  sdl_prefix=""
+fi
+
+# Check whether --with-sdl-exec-prefix or --without-sdl-exec-prefix was given.
+if test "${with_sdl_exec_prefix+set}" = set; then
+  withval="$with_sdl_exec_prefix"
+  sdl_exec_prefix="$withval"
+else
+  sdl_exec_prefix=""
+fi
+
+# Check whether --enable-sdltest or --disable-sdltest was given.
+if test "${enable_sdltest+set}" = set; then
+  enableval="$enable_sdltest"
+  :
+else
+  enable_sdltest=yes
+fi
+
+
+  if test x$sdl_exec_prefix != x ; then
+     sdl_args="$sdl_args --exec-prefix=$sdl_exec_prefix"
+     if test x${SDL_CONFIG+set} != xset ; then
+        SDL_CONFIG=$sdl_exec_prefix/bin/sdl-config
+     fi
+  fi
+  if test x$sdl_prefix != x ; then
+     sdl_args="$sdl_args --prefix=$sdl_prefix"
+     if test x${SDL_CONFIG+set} != xset ; then
+        SDL_CONFIG=$sdl_prefix/bin/sdl-config
+     fi
+  fi
+
+  # Extract the first word of "sdl-config", so it can be a program name with args.
+set dummy sdl-config; ac_word=$2
+echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
+echo "configure:1235: checking for $ac_word" >&5
+if eval "test \"`echo '$''{'ac_cv_path_SDL_CONFIG'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  case "$SDL_CONFIG" in
+  /*)
+  ac_cv_path_SDL_CONFIG="$SDL_CONFIG" # Let the user override the test with a path.
+  ;;
+  ?:/*)			 
+  ac_cv_path_SDL_CONFIG="$SDL_CONFIG" # Let the user override the test with a dos path.
+  ;;
+  *)
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
+  ac_dummy="$PATH"
+  for ac_dir in $ac_dummy; do 
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      ac_cv_path_SDL_CONFIG="$ac_dir/$ac_word"
+      break
+    fi
+  done
+  IFS="$ac_save_ifs"
+  test -z "$ac_cv_path_SDL_CONFIG" && ac_cv_path_SDL_CONFIG="no"
+  ;;
+esac
+fi
+SDL_CONFIG="$ac_cv_path_SDL_CONFIG"
+if test -n "$SDL_CONFIG"; then
+  echo "$ac_t""$SDL_CONFIG" 1>&6
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+  min_sdl_version=$SDL_VERSION
+  echo $ac_n "checking for SDL - version >= $min_sdl_version""... $ac_c" 1>&6
+echo "configure:1270: checking for SDL - version >= $min_sdl_version" >&5
+  no_sdl=""
+  if test "$SDL_CONFIG" = "no" ; then
+    no_sdl=yes
+  else
+    SDL_CFLAGS=`$SDL_CONFIG $sdlconf_args --cflags`
+    SDL_LIBS=`$SDL_CONFIG $sdlconf_args --libs`
+
+    sdl_major_version=`$SDL_CONFIG $sdl_args --version | \
+           sed 's/\([0-9]*\).\([0-9]*\).\([0-9]*\)/\1/'`
+    sdl_minor_version=`$SDL_CONFIG $sdl_args --version | \
+           sed 's/\([0-9]*\).\([0-9]*\).\([0-9]*\)/\2/'`
+    sdl_micro_version=`$SDL_CONFIG $sdl_config_args --version | \
+           sed 's/\([0-9]*\).\([0-9]*\).\([0-9]*\)/\3/'`
+    if test "x$enable_sdltest" = "xyes" ; then
+      ac_save_CFLAGS="$CFLAGS"
+      ac_save_LIBS="$LIBS"
+      CFLAGS="$CFLAGS $SDL_CFLAGS"
+      LIBS="$LIBS $SDL_LIBS"
+      rm -f conf.sdltest
+      if test "$cross_compiling" = yes; then
+  echo $ac_n "cross compiling; assumed OK... $ac_c"
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1294 "configure"
+#include "confdefs.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "SDL.h"
+
+char*
+my_strdup (char *str)
+{
+  char *new_str;
+  
+  if (str)
+    {
+      new_str = malloc ((strlen (str) + 1) * sizeof(char));
+      strcpy (new_str, str);
+    }
+  else
+    new_str = NULL;
+  
+  return new_str;
+}
+
+int main ()
+{
+  int major, minor, micro;
+  char *tmp_version;
+
+  system ("touch conf.sdltest");
+
+  /* HP/UX 9 (%@#!) writes to sscanf strings */
+  tmp_version = my_strdup("$min_sdl_version");
+  if (sscanf(tmp_version, "%d.%d.%d", &major, &minor, &micro) != 3) {
+     printf("%s, bad version string\n", "$min_sdl_version");
+     exit(1);
+   }
+
+   if (($sdl_major_version > major) ||
+      (($sdl_major_version == major) && ($sdl_minor_version > minor)) ||
+      (($sdl_major_version == major) && ($sdl_minor_version == minor) && ($sdl_micro_version >= micro)))
+    {
+      return 0;
+    }
+  else
+    {
+      printf("\n*** 'sdl-config --version' returned %d.%d.%d, but the minimum version\n", $sdl_major_version, $sdl_minor_version, $sdl_micro_version);
+      printf("*** of SDL required is %d.%d.%d. If sdl-config is correct, then it is\n", major, minor, micro);
+      printf("*** best to upgrade to the required version.\n");
+      printf("*** If sdl-config was wrong, set the environment variable SDL_CONFIG\n");
+      printf("*** to point to the correct copy of sdl-config, and remove the file\n");
+      printf("*** config.cache before re-running configure\n");
+      return 1;
+    }
+}
+
+
+EOF
+if { (eval echo configure:1352: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+then
+  :
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -fr conftest*
+  no_sdl=yes
+fi
+rm -fr conftest*
+fi
+
+       CFLAGS="$ac_save_CFLAGS"
+       LIBS="$ac_save_LIBS"
+     fi
+  fi
+  if test "x$no_sdl" = x ; then
+     echo "$ac_t""yes" 1>&6
+     :     
+  else
+     echo "$ac_t""no" 1>&6
+     if test "$SDL_CONFIG" = "no" ; then
+       echo "*** The sdl-config script installed by SDL could not be found"
+       echo "*** If SDL was installed in PREFIX, make sure PREFIX/bin is in"
+       echo "*** your path, or set the SDL_CONFIG environment variable to the"
+       echo "*** full path to sdl-config."
+     else
+       if test -f conf.sdltest ; then
+        :
+       else
+          echo "*** Could not run SDL test program, checking why..."
+          CFLAGS="$CFLAGS $SDL_CFLAGS"
+          LIBS="$LIBS $SDL_LIBS"
+          cat > conftest.$ac_ext <<EOF
+#line 1386 "configure"
+#include "confdefs.h"
+
+#include <stdio.h>
+#include "SDL.h"
+
+int main() {
+ return 0; 
+; return 0; }
+EOF
+if { (eval echo configure:1396: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+   echo "*** The test program compiled, but did not run. This usually means"
+          echo "*** that the run-time linker is not finding SDL or finding the wrong"
+          echo "*** version of SDL. If it is not finding SDL, you'll need to set your"
+          echo "*** LD_LIBRARY_PATH environment variable, or edit /etc/ld.so.conf to point"
+          echo "*** to the installed location  Also, make sure you have run ldconfig if that"
+          echo "*** is required on your system"
+	  echo "***"
+          echo "*** If you have an old version installed, it is best to remove it, although"
+          echo "*** you may also be able to get things to work by modifying LD_LIBRARY_PATH"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+   echo "*** The test program failed to compile or link. See the file config.log for the"
+          echo "*** exact error that occured. This usually means SDL was incorrectly installed"
+          echo "*** or that you have moved SDL since it was installed. In the latter case, you"
+          echo "*** may want to edit the sdl-config script: $SDL_CONFIG" 
+fi
+rm -f conftest*
+          CFLAGS="$ac_save_CFLAGS"
+          LIBS="$ac_save_LIBS"
+       fi
+     fi
+     SDL_CFLAGS=""
+     SDL_LIBS=""
+     { echo "configure: error: *** SDL version $SDL_VERSION not found!" 1>&2; exit 1; }
+
+  fi
+  
+  
+  rm -f conf.sdltest
+
+CFLAGS="$CFLAGS $SDL_CFLAGS -DSDL"
+LIBS="$LIBS $SDL_LIBS"
+
+case "$target" in
+    *-*-mingw32*)
+        cp ico_o ico.o
+	ICONOBJ="ico.o"
+        ;;
+    *)
+	ICONOBJ=""
+        ;;
+esac
+
+
+# Check whether --enable-asm or --disable-asm was given.
+if test "${enable_asm+set}" = set; then
+  enableval="$enable_asm"
+  :
+else
+  enable_asm=no
+fi
+
+if test x$enable_asm = xyes; then
+    CFLAGS="$CFLAGS -DUSE_ASM"
+fi
+
+CFLAGS="$CFLAGS -DELF"
+
+# Finally create all the generated files
+trap '' 1 2 15
+cat > confcache <<\EOF
+# This file is a shell script that caches the results of configure
+# tests run on this system so they can be shared between configure
+# scripts and configure runs.  It is not useful on other systems.
+# If it contains results you don't want to keep, you may remove or edit it.
+#
+# By default, configure uses ./config.cache as the cache file,
+# creating it if it does not exist already.  You can give configure
+# the --cache-file=FILE option to use a different cache file; that is
+# what configure does when it calls configure scripts in
+# subdirectories, so they share the cache.
+# Giving --cache-file=/dev/null disables caching, for debugging configure.
+# config.status only pays attention to the cache file if you give it the
+# --recheck option to rerun configure.
+#
+EOF
+# The following way of writing the cache mishandles newlines in values,
+# but we know of no workaround that is simple, portable, and efficient.
+# So, don't put newlines in cache variables' values.
+# Ultrix sh set writes to stderr and can't be redirected directly,
+# and sets the high bit in the cache file unless we assign to the vars.
+(set) 2>&1 |
+  case `(ac_space=' '; set | grep ac_space) 2>&1` in
+  *ac_space=\ *)
+    # `set' does not quote correctly, so add quotes (double-quote substitution
+    # turns \\\\ into \\, and sed turns \\ into \).
+    sed -n \
+      -e "s/'/'\\\\''/g" \
+      -e "s/^\\([a-zA-Z0-9_]*_cv_[a-zA-Z0-9_]*\\)=\\(.*\\)/\\1=\${\\1='\\2'}/p"
+    ;;
+  *)
+    # `set' quotes correctly as required by POSIX, so do not add quotes.
+    sed -n -e 's/^\([a-zA-Z0-9_]*_cv_[a-zA-Z0-9_]*\)=\(.*\)/\1=${\1=\2}/p'
+    ;;
+  esac >> confcache
+if cmp -s $cache_file confcache; then
+  :
+else
+  if test -w $cache_file; then
+    echo "updating cache $cache_file"
+    cat confcache > $cache_file
+  else
+    echo "not updating unwritable cache $cache_file"
+  fi
+fi
+rm -f confcache
+
+trap 'rm -fr conftest* confdefs* core core.* *.core $ac_clean_files; exit 1' 1 2 15
+
+test "x$prefix" = xNONE && prefix=$ac_default_prefix
+# Let make expand exec_prefix.
+test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
+
+# Any assignment to VPATH causes Sun make to only execute
+# the first set of double-colon rules, so remove it if not needed.
+# If there is a colon in the path, we need to keep it.
+if test "x$srcdir" = x.; then
+  ac_vpsub='/^[ 	]*VPATH[ 	]*=[^:]*$/d'
+fi
+
+trap 'rm -f $CONFIG_STATUS conftest*; exit 1' 1 2 15
+
+# Transform confdefs.h into DEFS.
+# Protect against shell expansion while executing Makefile rules.
+# Protect against Makefile macro expansion.
+cat > conftest.defs <<\EOF
+s%#define \([A-Za-z_][A-Za-z0-9_]*\) *\(.*\)%-D\1=\2%g
+s%[ 	`~#$^&*(){}\\|;'"<>?]%\\&%g
+s%\[%\\&%g
+s%\]%\\&%g
+s%\$%$$%g
+EOF
+DEFS=`sed -f conftest.defs confdefs.h | tr '\012' ' '`
+rm -f conftest.defs
+
+
+# Without the "./", some shells look in PATH for config.status.
+: ${CONFIG_STATUS=./config.status}
+
+echo creating $CONFIG_STATUS
+rm -f $CONFIG_STATUS
+cat > $CONFIG_STATUS <<EOF
+#! /bin/sh
+# Generated automatically by configure.
+# Run this file to recreate the current configuration.
+# This directory was configured as follows,
+# on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
+#
+# $0 $ac_configure_args
+#
+# Compiler output produced by configure, useful for debugging
+# configure, is in ./config.log if it exists.
+
+ac_cs_usage="Usage: $CONFIG_STATUS [--recheck] [--version] [--help]"
+for ac_option
+do
+  case "\$ac_option" in
+  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
+    echo "running \${CONFIG_SHELL-/bin/sh} $0 $ac_configure_args --no-create --no-recursion"
+    exec \${CONFIG_SHELL-/bin/sh} $0 $ac_configure_args --no-create --no-recursion ;;
+  -version | --version | --versio | --versi | --vers | --ver | --ve | --v)
+    echo "$CONFIG_STATUS generated by autoconf version 2.13"
+    exit 0 ;;
+  -help | --help | --hel | --he | --h)
+    echo "\$ac_cs_usage"; exit 0 ;;
+  *) echo "\$ac_cs_usage"; exit 1 ;;
+  esac
+done
+
+ac_given_srcdir=$srcdir
+ac_given_INSTALL="$INSTALL"
+
+trap 'rm -fr `echo "
+Makefile
+" | sed "s/:[^ ]*//g"` conftest*; exit 1' 1 2 15
+EOF
+cat >> $CONFIG_STATUS <<EOF
+
+# Protect against being on the right side of a sed subst in config.status.
+sed 's/%@/@@/; s/@%/@@/; s/%g\$/@g/; /@g\$/s/[\\\\&%]/\\\\&/g;
+ s/@@/%@/; s/@@/@%/; s/@g\$/%g/' > conftest.subs <<\\CEOF
+$ac_vpsub
+$extrasub
+s%@SHELL@%$SHELL%g
+s%@CFLAGS@%$CFLAGS%g
+s%@CPPFLAGS@%$CPPFLAGS%g
+s%@CXXFLAGS@%$CXXFLAGS%g
+s%@FFLAGS@%$FFLAGS%g
+s%@DEFS@%$DEFS%g
+s%@LDFLAGS@%$LDFLAGS%g
+s%@LIBS@%$LIBS%g
+s%@exec_prefix@%$exec_prefix%g
+s%@prefix@%$prefix%g
+s%@program_transform_name@%$program_transform_name%g
+s%@bindir@%$bindir%g
+s%@sbindir@%$sbindir%g
+s%@libexecdir@%$libexecdir%g
+s%@datadir@%$datadir%g
+s%@sysconfdir@%$sysconfdir%g
+s%@sharedstatedir@%$sharedstatedir%g
+s%@localstatedir@%$localstatedir%g
+s%@libdir@%$libdir%g
+s%@includedir@%$includedir%g
+s%@oldincludedir@%$oldincludedir%g
+s%@infodir@%$infodir%g
+s%@mandir@%$mandir%g
+s%@INSTALL_PROGRAM@%$INSTALL_PROGRAM%g
+s%@INSTALL_SCRIPT@%$INSTALL_SCRIPT%g
+s%@INSTALL_DATA@%$INSTALL_DATA%g
+s%@PACKAGE@%$PACKAGE%g
+s%@VERSION@%$VERSION%g
+s%@ACLOCAL@%$ACLOCAL%g
+s%@AUTOCONF@%$AUTOCONF%g
+s%@AUTOMAKE@%$AUTOMAKE%g
+s%@AUTOHEADER@%$AUTOHEADER%g
+s%@MAKEINFO@%$MAKEINFO%g
+s%@SET_MAKE@%$SET_MAKE%g
+s%@host@%$host%g
+s%@host_alias@%$host_alias%g
+s%@host_cpu@%$host_cpu%g
+s%@host_vendor@%$host_vendor%g
+s%@host_os@%$host_os%g
+s%@target@%$target%g
+s%@target_alias@%$target_alias%g
+s%@target_cpu@%$target_cpu%g
+s%@target_vendor@%$target_vendor%g
+s%@target_os@%$target_os%g
+s%@CC@%$CC%g
+s%@MATHLIB@%$MATHLIB%g
+s%@INETLIB@%$INETLIB%g
+s%@SDL_CONFIG@%$SDL_CONFIG%g
+s%@SDL_CFLAGS@%$SDL_CFLAGS%g
+s%@SDL_LIBS@%$SDL_LIBS%g
+s%@ICONOBJ@%$ICONOBJ%g
+
+CEOF
+EOF
+
+cat >> $CONFIG_STATUS <<\EOF
+
+# Split the substitutions into bite-sized pieces for seds with
+# small command number limits, like on Digital OSF/1 and HP-UX.
+ac_max_sed_cmds=90 # Maximum number of lines to put in a sed script.
+ac_file=1 # Number of current file.
+ac_beg=1 # First line for current file.
+ac_end=$ac_max_sed_cmds # Line after last line for current file.
+ac_more_lines=:
+ac_sed_cmds=""
+while $ac_more_lines; do
+  if test $ac_beg -gt 1; then
+    sed "1,${ac_beg}d; ${ac_end}q" conftest.subs > conftest.s$ac_file
+  else
+    sed "${ac_end}q" conftest.subs > conftest.s$ac_file
+  fi
+  if test ! -s conftest.s$ac_file; then
+    ac_more_lines=false
+    rm -f conftest.s$ac_file
+  else
+    if test -z "$ac_sed_cmds"; then
+      ac_sed_cmds="sed -f conftest.s$ac_file"
+    else
+      ac_sed_cmds="$ac_sed_cmds | sed -f conftest.s$ac_file"
+    fi
+    ac_file=`expr $ac_file + 1`
+    ac_beg=$ac_end
+    ac_end=`expr $ac_end + $ac_max_sed_cmds`
+  fi
+done
+if test -z "$ac_sed_cmds"; then
+  ac_sed_cmds=cat
+fi
+EOF
+
+cat >> $CONFIG_STATUS <<EOF
+
+CONFIG_FILES=\${CONFIG_FILES-"Makefile
+"}
+EOF
+cat >> $CONFIG_STATUS <<\EOF
+for ac_file in .. $CONFIG_FILES; do if test "x$ac_file" != x..; then
+  # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
+  case "$ac_file" in
+  *:*) ac_file_in=`echo "$ac_file"|sed 's%[^:]*:%%'`
+       ac_file=`echo "$ac_file"|sed 's%:.*%%'` ;;
+  *) ac_file_in="${ac_file}.in" ;;
+  esac
+
+  # Adjust a relative srcdir, top_srcdir, and INSTALL for subdirectories.
+
+  # Remove last slash and all that follows it.  Not all systems have dirname.
+  ac_dir=`echo $ac_file|sed 's%/[^/][^/]*$%%'`
+  if test "$ac_dir" != "$ac_file" && test "$ac_dir" != .; then
+    # The file is in a subdirectory.
+    test ! -d "$ac_dir" && mkdir "$ac_dir"
+    ac_dir_suffix="/`echo $ac_dir|sed 's%^\./%%'`"
+    # A "../" for each directory in $ac_dir_suffix.
+    ac_dots=`echo $ac_dir_suffix|sed 's%/[^/]*%../%g'`
+  else
+    ac_dir_suffix= ac_dots=
+  fi
+
+  case "$ac_given_srcdir" in
+  .)  srcdir=.
+      if test -z "$ac_dots"; then top_srcdir=.
+      else top_srcdir=`echo $ac_dots|sed 's%/$%%'`; fi ;;
+  /*) srcdir="$ac_given_srcdir$ac_dir_suffix"; top_srcdir="$ac_given_srcdir" ;;
+  *) # Relative path.
+    srcdir="$ac_dots$ac_given_srcdir$ac_dir_suffix"
+    top_srcdir="$ac_dots$ac_given_srcdir" ;;
+  esac
+
+  case "$ac_given_INSTALL" in
+  [/$]*) INSTALL="$ac_given_INSTALL" ;;
+  *) INSTALL="$ac_dots$ac_given_INSTALL" ;;
+  esac
+
+  echo creating "$ac_file"
+  rm -f "$ac_file"
+  configure_input="Generated automatically from `echo $ac_file_in|sed 's%.*/%%'` by configure."
+  case "$ac_file" in
+  *Makefile*) ac_comsub="1i\\
+# $configure_input" ;;
+  *) ac_comsub= ;;
+  esac
+
+  ac_file_inputs=`echo $ac_file_in|sed -e "s%^%$ac_given_srcdir/%" -e "s%:% $ac_given_srcdir/%g"`
+  sed -e "$ac_comsub
+s%@configure_input@%$configure_input%g
+s%@srcdir@%$srcdir%g
+s%@top_srcdir@%$top_srcdir%g
+s%@INSTALL@%$INSTALL%g
+" $ac_file_inputs | (eval "$ac_sed_cmds") > $ac_file
+fi; done
+rm -f conftest.s*
+
+EOF
+cat >> $CONFIG_STATUS <<EOF
+
+EOF
+cat >> $CONFIG_STATUS <<\EOF
+
+exit 0
+EOF
+chmod +x $CONFIG_STATUS
+rm -fr confdefs* $ac_clean_files
+test "$no_create" = yes || ${CONFIG_SHELL-/bin/sh} $CONFIG_STATUS || exit 1
+
diff -ruN WinQuake/configure.in sdlquake-1.0.9/configure.in
--- WinQuake/configure.in	Wed Dec 31 16:00:00 1969
+++ sdlquake-1.0.9/configure.in	Tue Dec 28 10:54:22 1999
@@ -0,0 +1,81 @@
+dnl Process this file with autoconf to produce a configure script.
+AC_INIT(README.SDL)
+
+dnl Setup for automake
+AM_INIT_AUTOMAKE(sdlquake, 1.0.9)
+
+dnl Detect the canonical target build environment
+AC_CANONICAL_HOST
+AC_CANONICAL_TARGET
+
+dnl Check for tools
+
+AC_PROG_MAKE_SET
+AC_PROG_CC
+AC_PROG_INSTALL
+
+dnl The alpha architecture needs special flags for binary portability
+AC_CANONICAL_TARGET
+case "$target" in
+    i686-*-linux*)
+        CFLAGS="-g -mpentiumpro -O6 -ffast-math -funroll-loops -fomit-frame-pointer -fexpensive-optimizations"
+        #CFLAGS="-g -mpentiumpro -O6 -ffast-math -funroll-loops -fexpensive-optimizations"
+        ;;
+    alpha*-*-linux*)
+        CFLAGS="$CFLAGS -mcpu=ev4 -Wa,-mall"
+        ;;
+esac
+
+dnl Figure out which math and networking libraries to use
+case "$target" in
+    *-*-mingw32*)
+        MATHLIB=""
+        INETLIB="-lwsock32"
+        ;;
+    *-*-beos*)
+        MATHLIB=""
+        INETLIB=""
+        ;;
+    *)
+        MATHLIB="-lm"
+        INETLIB=""
+        ;;
+esac
+AC_SUBST(MATHLIB)
+AC_SUBST(INETLIB)
+
+dnl Check for SDL
+SDL_VERSION=1.0.1
+AM_PATH_SDL($SDL_VERSION,
+            :,
+            AC_MSG_ERROR([*** SDL version $SDL_VERSION not found!])
+)
+CFLAGS="$CFLAGS $SDL_CFLAGS -DSDL"
+LIBS="$LIBS $SDL_LIBS"
+
+dnl Set up the icon object file, for Mingw32
+case "$target" in
+    *-*-mingw32*)
+        cp ico_o ico.o
+	ICONOBJ="ico.o"
+        ;;
+    *)
+	ICONOBJ=""
+        ;;
+esac
+AC_SUBST(ICONOBJ)
+
+dnl Enable/disable the i686 asm
+AC_ARG_ENABLE(asm,
+[  --enable-asm            enable i686 assembly routines [default=no]],
+                  , enable_asm=no)
+if test x$enable_asm = xyes; then
+    CFLAGS="$CFLAGS -DUSE_ASM"
+fi
+
+CFLAGS="$CFLAGS -DELF"
+
+# Finally create all the generated files
+AC_OUTPUT([
+Makefile
+])
diff -ruN WinQuake/console.c sdlquake-1.0.9/console.c
--- WinQuake/console.c	Tue Dec 21 15:53:24 1999
+++ sdlquake-1.0.9/console.c	Sat Dec 25 03:38:02 1999
@@ -253,6 +253,7 @@
 */
 void Con_Linefeed (void)
 {
+	if ( ! con_initialized ) return;
 	con_x = 0;
 	con_current++;
 	Q_memset (&con_text[(con_current%con_totallines)*con_linewidth]
@@ -275,6 +276,7 @@
 	static int	cr;
 	int		mask;
 	
+	if ( ! con_initialized ) return;
 	con_backscroll = 0;
 
 	if (txt[0] == 1)
diff -ruN WinQuake/d_copy.S sdlquake-1.0.9/d_copy.S
--- WinQuake/d_copy.S	Wed Dec 31 16:00:00 1969
+++ sdlquake-1.0.9/d_copy.S	Sat Dec 25 03:38:02 1999
@@ -0,0 +1,149 @@
+//
+// d_copy.s
+// x86 assembly-language screen copying code.
+//
+
+#include "asm_i386.h"
+#include "quakeasm.h"
+#include "asm_draw.h"
+
+	.data
+
+LCopyWidth:		.long	0
+LBlockSrcStep:	.long	0
+LBlockDestStep:	.long	0
+LSrcDelta:		.long	0
+LDestDelta:		.long	0
+
+#define bufptr	4+16
+
+// copies 16 rows per plane at a pop; idea is that 16*512 = 8k, and since
+// no Mode X mode is wider than 360, all the data should fit in the cache for
+// the passes for the next 3 planes
+
+	.text
+
+.globl C(VGA_UpdatePlanarScreen)
+C(VGA_UpdatePlanarScreen):
+	pushl	%ebp				// preserve caller's stack frame
+	pushl	%edi
+	pushl	%esi				// preserve register variables
+	pushl	%ebx
+
+	movl	C(VGA_bufferrowbytes),%eax
+	shll	$1,%eax
+	movl	%eax,LBlockSrcStep
+	movl	C(VGA_rowbytes),%eax
+	shll	$1,%eax
+	movl	%eax,LBlockDestStep
+
+	movl	$0x3C4,%edx
+	movb	$2,%al
+	outb	%al,%dx		// point the SC to the Map Mask
+	incl	%edx
+
+	movl	bufptr(%esp),%esi
+	movl	C(VGA_pagebase),%edi
+	movl	C(VGA_height),%ebp
+	shrl	$1,%ebp
+
+	movl	C(VGA_width),%ecx
+	movl	C(VGA_bufferrowbytes),%eax
+	subl	%ecx,%eax
+	movl	%eax,LSrcDelta
+	movl	C(VGA_rowbytes),%eax
+	shll	$2,%eax
+	subl	%ecx,%eax
+	movl	%eax,LDestDelta
+	shrl	$4,%ecx
+	movl	%ecx,LCopyWidth
+
+LRowLoop:
+	movb	$1,%al
+
+LPlaneLoop:
+	outb	%al,%dx
+	movb	$2,%ah
+
+	pushl	%esi
+	pushl	%edi
+LRowSetLoop:
+	movl	LCopyWidth,%ecx
+LColumnLoop:
+	movb	12(%esi),%bh
+	movb	8(%esi),%bl
+	shll	$16,%ebx
+	movb	4(%esi),%bh
+	movb	(%esi),%bl
+	movl	%ebx,(%edi)
+	addl	$16,%esi
+	addl	$4,%edi
+	decl	%ecx
+	jnz		LColumnLoop
+
+	addl	LDestDelta,%edi
+	addl	LSrcDelta,%esi
+	decb	%ah
+	jnz		LRowSetLoop
+
+	popl	%edi
+	popl	%esi
+	incl	%esi
+
+	shlb	$1,%al
+	cmpb	$16,%al
+	jnz		LPlaneLoop
+
+	subl	$4,%esi
+	addl	LBlockSrcStep,%esi
+	addl	LBlockDestStep,%edi
+	decl	%ebp
+	jnz		LRowLoop
+
+	popl	%ebx				// restore register variables
+	popl	%esi
+	popl	%edi
+	popl	%ebp				// restore the caller's stack frame
+
+	ret
+
+
+#define srcptr			4+16
+#define destptr			8+16
+#define width			12+16
+#define height			16+16
+#define srcrowbytes		20+16
+#define destrowbytes	24+16
+
+.globl C(VGA_UpdateLinearScreen)
+C(VGA_UpdateLinearScreen):
+	pushl	%ebp				// preserve caller's stack frame
+	pushl	%edi
+	pushl	%esi				// preserve register variables
+	pushl	%ebx
+
+	cld
+	movl	srcptr(%esp),%esi
+	movl	destptr(%esp),%edi
+	movl	width(%esp),%ebx
+	movl	srcrowbytes(%esp),%eax
+	subl	%ebx,%eax
+	movl	destrowbytes(%esp),%edx
+	subl	%ebx,%edx
+	shrl	$2,%ebx
+	movl	height(%esp),%ebp
+LLRowLoop:
+	movl	%ebx,%ecx
+	rep/movsl	(%esi),(%edi)
+	addl	%eax,%esi
+	addl	%edx,%edi
+	decl	%ebp
+	jnz		LLRowLoop
+
+	popl	%ebx				// restore register variables
+	popl	%esi
+	popl	%edi
+	popl	%ebp				// restore the caller's stack frame
+
+	ret
+
diff -ruN WinQuake/d_copy.s sdlquake-1.0.9/d_copy.s
--- WinQuake/d_copy.s	Wed Aug 12 12:44:22 1998
+++ sdlquake-1.0.9/d_copy.s	Wed Dec 31 16:00:00 1969
@@ -1,149 +0,0 @@
-//
-// d_copy.s
-// x86 assembly-language screen copying code.
-//
-
-#include "asm_i386.h"
-#include "quakeasm.h"
-#include "asm_draw.h"
-
-	.data
-
-LCopyWidth:		.long	0
-LBlockSrcStep:	.long	0
-LBlockDestStep:	.long	0
-LSrcDelta:		.long	0
-LDestDelta:		.long	0
-
-#define bufptr	4+16
-
-// copies 16 rows per plane at a pop; idea is that 16*512 = 8k, and since
-// no Mode X mode is wider than 360, all the data should fit in the cache for
-// the passes for the next 3 planes
-
-	.text
-
-.globl C(VGA_UpdatePlanarScreen)
-C(VGA_UpdatePlanarScreen):
-	pushl	%ebp				// preserve caller's stack frame
-	pushl	%edi
-	pushl	%esi				// preserve register variables
-	pushl	%ebx
-
-	movl	C(VGA_bufferrowbytes),%eax
-	shll	$1,%eax
-	movl	%eax,LBlockSrcStep
-	movl	C(VGA_rowbytes),%eax
-	shll	$1,%eax
-	movl	%eax,LBlockDestStep
-
-	movl	$0x3C4,%edx
-	movb	$2,%al
-	outb	%al,%dx		// point the SC to the Map Mask
-	incl	%edx
-
-	movl	bufptr(%esp),%esi
-	movl	C(VGA_pagebase),%edi
-	movl	C(VGA_height),%ebp
-	shrl	$1,%ebp
-
-	movl	C(VGA_width),%ecx
-	movl	C(VGA_bufferrowbytes),%eax
-	subl	%ecx,%eax
-	movl	%eax,LSrcDelta
-	movl	C(VGA_rowbytes),%eax
-	shll	$2,%eax
-	subl	%ecx,%eax
-	movl	%eax,LDestDelta
-	shrl	$4,%ecx
-	movl	%ecx,LCopyWidth
-
-LRowLoop:
-	movb	$1,%al
-
-LPlaneLoop:
-	outb	%al,%dx
-	movb	$2,%ah
-
-	pushl	%esi
-	pushl	%edi
-LRowSetLoop:
-	movl	LCopyWidth,%ecx
-LColumnLoop:
-	movb	12(%esi),%bh
-	movb	8(%esi),%bl
-	shll	$16,%ebx
-	movb	4(%esi),%bh
-	movb	(%esi),%bl
-	movl	%ebx,(%edi)
-	addl	$16,%esi
-	addl	$4,%edi
-	decl	%ecx
-	jnz		LColumnLoop
-
-	addl	LDestDelta,%edi
-	addl	LSrcDelta,%esi
-	decb	%ah
-	jnz		LRowSetLoop
-
-	popl	%edi
-	popl	%esi
-	incl	%esi
-
-	shlb	$1,%al
-	cmpb	$16,%al
-	jnz		LPlaneLoop
-
-	subl	$4,%esi
-	addl	LBlockSrcStep,%esi
-	addl	LBlockDestStep,%edi
-	decl	%ebp
-	jnz		LRowLoop
-
-	popl	%ebx				// restore register variables
-	popl	%esi
-	popl	%edi
-	popl	%ebp				// restore the caller's stack frame
-
-	ret
-
-
-#define srcptr			4+16
-#define destptr			8+16
-#define width			12+16
-#define height			16+16
-#define srcrowbytes		20+16
-#define destrowbytes	24+16
-
-.globl C(VGA_UpdateLinearScreen)
-C(VGA_UpdateLinearScreen):
-	pushl	%ebp				// preserve caller's stack frame
-	pushl	%edi
-	pushl	%esi				// preserve register variables
-	pushl	%ebx
-
-	cld
-	movl	srcptr(%esp),%esi
-	movl	destptr(%esp),%edi
-	movl	width(%esp),%ebx
-	movl	srcrowbytes(%esp),%eax
-	subl	%ebx,%eax
-	movl	destrowbytes(%esp),%edx
-	subl	%ebx,%edx
-	shrl	$2,%ebx
-	movl	height(%esp),%ebp
-LLRowLoop:
-	movl	%ebx,%ecx
-	rep/movsl	(%esi),(%edi)
-	addl	%eax,%esi
-	addl	%edx,%edi
-	decl	%ebp
-	jnz		LLRowLoop
-
-	popl	%ebx				// restore register variables
-	popl	%esi
-	popl	%edi
-	popl	%ebp				// restore the caller's stack frame
-
-	ret
-
diff -ruN WinQuake/d_draw.S sdlquake-1.0.9/d_draw.S
--- WinQuake/d_draw.S	Wed Dec 31 16:00:00 1969
+++ sdlquake-1.0.9/d_draw.S	Sat Dec 25 03:38:02 1999
@@ -0,0 +1,1037 @@
+/*
+Copyright (C) 1996-1997 Id Software, Inc.
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation; either version 2
+of the License, or (at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
+
+See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+//
+// d_draw.s
+// x86 assembly-language horizontal 8-bpp span-drawing code.
+//
+
+#include "asm_i386.h"
+#include "quakeasm.h"
+#include "asm_draw.h"
+#include "d_ifacea.h"
+
+#if	id386
+
+//----------------------------------------------------------------------
+// 8-bpp horizontal span drawing code for polygons, with no transparency.
+//
+// Assumes there is at least one span in pspans, and that every span
+// contains at least one pixel
+//----------------------------------------------------------------------
+
+	.text
+
+// out-of-line, rarely-needed clamping code
+
+LClampHigh0:
+	movl	C(bbextents),%esi
+	jmp		LClampReentry0
+LClampHighOrLow0:
+	jg		LClampHigh0
+	xorl	%esi,%esi
+	jmp		LClampReentry0
+
+LClampHigh1:
+	movl	C(bbextentt),%edx
+	jmp		LClampReentry1
+LClampHighOrLow1:
+	jg		LClampHigh1
+	xorl	%edx,%edx
+	jmp		LClampReentry1
+
+LClampLow2:
+	movl	$2048,%ebp
+	jmp		LClampReentry2
+LClampHigh2:
+	movl	C(bbextents),%ebp
+	jmp		LClampReentry2
+
+LClampLow3:
+	movl	$2048,%ecx
+	jmp		LClampReentry3
+LClampHigh3:
+	movl	C(bbextentt),%ecx
+	jmp		LClampReentry3
+
+LClampLow4:
+	movl	$2048,%eax
+	jmp		LClampReentry4
+LClampHigh4:
+	movl	C(bbextents),%eax
+	jmp		LClampReentry4
+
+LClampLow5:
+	movl	$2048,%ebx
+	jmp		LClampReentry5
+LClampHigh5:
+	movl	C(bbextentt),%ebx
+	jmp		LClampReentry5
+
+
+#define pspans	4+16
+
+	.align 4
+.globl C(D_DrawSpans8)
+C(D_DrawSpans8):
+	pushl	%ebp				// preserve caller's stack frame
+	pushl	%edi
+	pushl	%esi				// preserve register variables
+	pushl	%ebx
+
+//
+// set up scaled-by-8 steps, for 8-long segments; also set up cacheblock
+// and span list pointers
+//
+// TODO: any overlap from rearranging?
+	flds	C(d_sdivzstepu)
+	fmuls	fp_8
+	movl	C(cacheblock),%edx
+	flds	C(d_tdivzstepu)
+	fmuls	fp_8
+	movl	pspans(%esp),%ebx	// point to the first span descriptor
+	flds	C(d_zistepu)
+	fmuls	fp_8
+	movl	%edx,pbase			// pbase = cacheblock
+	fstps	zi8stepu
+	fstps	tdivz8stepu
+	fstps	sdivz8stepu
+
+LSpanLoop:
+//
+// set up the initial s/z, t/z, and 1/z on the FP stack, and generate the
+// initial s and t values
+//
+// FIXME: pipeline FILD?
+	fildl	espan_t_v(%ebx)
+	fildl	espan_t_u(%ebx)
+
+	fld		%st(1)			// dv | du | dv
+	fmuls	C(d_sdivzstepv)	// dv*d_sdivzstepv | du | dv
+	fld		%st(1)			// du | dv*d_sdivzstepv | du | dv
+	fmuls	C(d_sdivzstepu)	// du*d_sdivzstepu | dv*d_sdivzstepv | du | dv
+	fld		%st(2)			// du | du*d_sdivzstepu | dv*d_sdivzstepv | du | dv
+	fmuls	C(d_tdivzstepu)	// du*d_tdivzstepu | du*d_sdivzstepu |
+							//  dv*d_sdivzstepv | du | dv
+	fxch	%st(1)			// du*d_sdivzstepu | du*d_tdivzstepu |
+							//  dv*d_sdivzstepv | du | dv
+	faddp	%st(0),%st(2)	// du*d_tdivzstepu |
+							//  du*d_sdivzstepu + dv*d_sdivzstepv | du | dv
+	fxch	%st(1)			// du*d_sdivzstepu + dv*d_sdivzstepv |
+							//  du*d_tdivzstepu | du | dv
+	fld		%st(3)			// dv | du*d_sdivzstepu + dv*d_sdivzstepv |
+							//  du*d_tdivzstepu | du | dv
+	fmuls	C(d_tdivzstepv)	// dv*d_tdivzstepv |
+							//  du*d_sdivzstepu + dv*d_sdivzstepv |
+							//  du*d_tdivzstepu | du | dv
+	fxch	%st(1)			// du*d_sdivzstepu + dv*d_sdivzstepv |
+							//  dv*d_tdivzstepv | du*d_tdivzstepu | du | dv
+	fadds	C(d_sdivzorigin)	// sdivz = d_sdivzorigin + dv*d_sdivzstepv +
+							//  du*d_sdivzstepu; stays in %st(2) at end
+	fxch	%st(4)			// dv | dv*d_tdivzstepv | du*d_tdivzstepu | du |
+							//  s/z
+	fmuls	C(d_zistepv)		// dv*d_zistepv | dv*d_tdivzstepv |
+							//  du*d_tdivzstepu | du | s/z
+	fxch	%st(1)			// dv*d_tdivzstepv |  dv*d_zistepv |
+							//  du*d_tdivzstepu | du | s/z
+	faddp	%st(0),%st(2)	// dv*d_zistepv |
+							//  dv*d_tdivzstepv + du*d_tdivzstepu | du | s/z
+	fxch	%st(2)			// du | dv*d_tdivzstepv + du*d_tdivzstepu |
+							//  dv*d_zistepv | s/z
+	fmuls	C(d_zistepu)		// du*d_zistepu |
+							//  dv*d_tdivzstepv + du*d_tdivzstepu |
+							//  dv*d_zistepv | s/z
+	fxch	%st(1)			// dv*d_tdivzstepv + du*d_tdivzstepu |
+							//  du*d_zistepu | dv*d_zistepv | s/z
+	fadds	C(d_tdivzorigin)	// tdivz = d_tdivzorigin + dv*d_tdivzstepv +
+							//  du*d_tdivzstepu; stays in %st(1) at end
+	fxch	%st(2)			// dv*d_zistepv | du*d_zistepu | t/z | s/z
+	faddp	%st(0),%st(1)	// dv*d_zistepv + du*d_zistepu | t/z | s/z
+
+	flds	fp_64k			// fp_64k | dv*d_zistepv + du*d_zistepu | t/z | s/z
+	fxch	%st(1)			// dv*d_zistepv + du*d_zistepu | fp_64k | t/z | s/z
+	fadds	C(d_ziorigin)		// zi = d_ziorigin + dv*d_zistepv +
+							//  du*d_zistepu; stays in %st(0) at end
+							// 1/z | fp_64k | t/z | s/z
+//
+// calculate and clamp s & t
+//
+	fdivr	%st(0),%st(1)	// 1/z | z*64k | t/z | s/z
+
+//
+// point %edi to the first pixel in the span
+//
+	movl	C(d_viewbuffer),%ecx
+	movl	espan_t_v(%ebx),%eax
+	movl	%ebx,pspantemp	// preserve spans pointer
+
+	movl	C(tadjust),%edx
+	movl	C(sadjust),%esi
+	movl	C(d_scantable)(,%eax,4),%edi	// v * screenwidth
+	addl	%ecx,%edi
+	movl	espan_t_u(%ebx),%ecx
+	addl	%ecx,%edi				// pdest = &pdestspan[scans->u];
+	movl	espan_t_count(%ebx),%ecx
+
+//
+// now start the FDIV for the end of the span
+//
+	cmpl	$8,%ecx
+	ja		LSetupNotLast1
+
+	decl	%ecx
+	jz		LCleanup1		// if only one pixel, no need to start an FDIV
+	movl	%ecx,spancountminus1
+
+// finish up the s and t calcs
+	fxch	%st(1)			// z*64k | 1/z | t/z | s/z
+
+	fld		%st(0)			// z*64k | z*64k | 1/z | t/z | s/z
+	fmul	%st(4),%st(0)	// s | z*64k | 1/z | t/z | s/z
+	fxch	%st(1)			// z*64k | s | 1/z | t/z | s/z
+	fmul	%st(3),%st(0)	// t | s | 1/z | t/z | s/z
+	fxch	%st(1)			// s | t | 1/z | t/z | s/z
+	fistpl	s				// 1/z | t | t/z | s/z
+	fistpl	t				// 1/z | t/z | s/z
+
+	fildl	spancountminus1
+
+	flds	C(d_tdivzstepu)	// C(d_tdivzstepu) | spancountminus1
+	flds	C(d_zistepu)		// C(d_zistepu) | C(d_tdivzstepu) | spancountminus1
+	fmul	%st(2),%st(0)	// C(d_zistepu)*scm1 | C(d_tdivzstepu) | scm1
+	fxch	%st(1)			// C(d_tdivzstepu) | C(d_zistepu)*scm1 | scm1
+	fmul	%st(2),%st(0)	// C(d_tdivzstepu)*scm1 | C(d_zistepu)*scm1 | scm1
+	fxch	%st(2)			// scm1 | C(d_zistepu)*scm1 | C(d_tdivzstepu)*scm1
+	fmuls	C(d_sdivzstepu)	// C(d_sdivzstepu)*scm1 | C(d_zistepu)*scm1 |
+							//  C(d_tdivzstepu)*scm1
+	fxch	%st(1)			// C(d_zistepu)*scm1 | C(d_sdivzstepu)*scm1 |
+							//  C(d_tdivzstepu)*scm1
+	faddp	%st(0),%st(3)	// C(d_sdivzstepu)*scm1 | C(d_tdivzstepu)*scm1
+	fxch	%st(1)			// C(d_tdivzstepu)*scm1 | C(d_sdivzstepu)*scm1
+	faddp	%st(0),%st(3)	// C(d_sdivzstepu)*scm1
+	faddp	%st(0),%st(3)
+
+	flds	fp_64k
+	fdiv	%st(1),%st(0)	// this is what we've gone to all this trouble to
+							//  overlap
+	jmp		LFDIVInFlight1
+
+LCleanup1:
+// finish up the s and t calcs
+	fxch	%st(1)			// z*64k | 1/z | t/z | s/z
+
+	fld		%st(0)			// z*64k | z*64k | 1/z | t/z | s/z
+	fmul	%st(4),%st(0)	// s | z*64k | 1/z | t/z | s/z
+	fxch	%st(1)			// z*64k | s | 1/z | t/z | s/z
+	fmul	%st(3),%st(0)	// t | s | 1/z | t/z | s/z
+	fxch	%st(1)			// s | t | 1/z | t/z | s/z
+	fistpl	s				// 1/z | t | t/z | s/z
+	fistpl	t				// 1/z | t/z | s/z
+	jmp		LFDIVInFlight1
+
+	.align	4
+LSetupNotLast1:
+// finish up the s and t calcs
+	fxch	%st(1)			// z*64k | 1/z | t/z | s/z
+
+	fld		%st(0)			// z*64k | z*64k | 1/z | t/z | s/z
+	fmul	%st(4),%st(0)	// s | z*64k | 1/z | t/z | s/z
+	fxch	%st(1)			// z*64k | s | 1/z | t/z | s/z
+	fmul	%st(3),%st(0)	// t | s | 1/z | t/z | s/z
+	fxch	%st(1)			// s | t | 1/z | t/z | s/z
+	fistpl	s				// 1/z | t | t/z | s/z
+	fistpl	t				// 1/z | t/z | s/z
+
+	fadds	zi8stepu
+	fxch	%st(2)
+	fadds	sdivz8stepu
+	fxch	%st(2)
+	flds	tdivz8stepu
+	faddp	%st(0),%st(2)
+	flds	fp_64k
+	fdiv	%st(1),%st(0)	// z = 1/1/z
+							// this is what we've gone to all this trouble to
+							//  overlap
+LFDIVInFlight1:
+
+	addl	s,%esi
+	addl	t,%edx
+	movl	C(bbextents),%ebx
+	movl	C(bbextentt),%ebp
+	cmpl	%ebx,%esi
+	ja		LClampHighOrLow0
+LClampReentry0:
+	movl	%esi,s
+	movl	pbase,%ebx
+	shll	$16,%esi
+	cmpl	%ebp,%edx
+	movl	%esi,sfracf
+	ja		LClampHighOrLow1
+LClampReentry1:
+	movl	%edx,t
+	movl	s,%esi					// sfrac = scans->sfrac;
+	shll	$16,%edx
+	movl	t,%eax					// tfrac = scans->tfrac;
+	sarl	$16,%esi
+	movl	%edx,tfracf
+
+//
+// calculate the texture starting address
+//
+	sarl	$16,%eax
+	movl	C(cachewidth),%edx
+	imull	%edx,%eax				// (tfrac >> 16) * cachewidth
+	addl	%ebx,%esi
+	addl	%eax,%esi				// psource = pbase + (sfrac >> 16) +
+									//           ((tfrac >> 16) * cachewidth);
+
+//
+// determine whether last span or not
+//
+	cmpl	$8,%ecx
+	jna		LLastSegment
+
+//
+// not the last segment; do full 8-wide segment
+//
+LNotLastSegment:
+
+//
+// advance s/z, t/z, and 1/z, and calculate s & t at end of span and steps to
+// get there
+//
+
+// pick up after the FDIV that was left in flight previously
+
+	fld		%st(0)			// duplicate it
+	fmul	%st(4),%st(0)	// s = s/z * z
+	fxch	%st(1)
+	fmul	%st(3),%st(0)	// t = t/z * z
+	fxch	%st(1)
+	fistpl	snext
+	fistpl	tnext
+	movl	snext,%eax
+	movl	tnext,%edx
+
+	movb	(%esi),%bl	// get first source texel
+	subl	$8,%ecx		// count off this segments' pixels
+	movl	C(sadjust),%ebp
+	movl	%ecx,counttemp	// remember count of remaining pixels
+
+	movl	C(tadjust),%ecx
+	movb	%bl,(%edi)	// store first dest pixel
+
+	addl	%eax,%ebp
+	addl	%edx,%ecx
+
+	movl	C(bbextents),%eax
+	movl	C(bbextentt),%edx
+
+	cmpl	$2048,%ebp
+	jl		LClampLow2
+	cmpl	%eax,%ebp
+	ja		LClampHigh2
+LClampReentry2:
+
+	cmpl	$2048,%ecx
+	jl		LClampLow3
+	cmpl	%edx,%ecx
+	ja		LClampHigh3
+LClampReentry3:
+
+	movl	%ebp,snext
+	movl	%ecx,tnext
+
+	subl	s,%ebp
+	subl	t,%ecx
+	
+//
+// set up advancetable
+//
+	movl	%ecx,%eax
+	movl	%ebp,%edx
+	sarl	$19,%eax			// tstep >>= 16;
+	jz		LZero
+	sarl	$19,%edx			// sstep >>= 16;
+	movl	C(cachewidth),%ebx
+	imull	%ebx,%eax
+	jmp		LSetUp1
+
+LZero:
+	sarl	$19,%edx			// sstep >>= 16;
+	movl	C(cachewidth),%ebx
+
+LSetUp1:
+
+	addl	%edx,%eax			// add in sstep
+								// (tstep >> 16) * cachewidth + (sstep >> 16);
+	movl	tfracf,%edx
+	movl	%eax,advancetable+4	// advance base in t
+	addl	%ebx,%eax			// ((tstep >> 16) + 1) * cachewidth +
+								//  (sstep >> 16);
+	shll	$13,%ebp			// left-justify sstep fractional part
+	movl	sfracf,%ebx
+	shll	$13,%ecx			// left-justify tstep fractional part
+	movl	%eax,advancetable	// advance extra in t
+
+	movl	%ecx,tstep
+	addl	%ecx,%edx			// advance tfrac fractional part by tstep frac
+
+	sbbl	%ecx,%ecx			// turn tstep carry into -1 (0 if none)
+	addl	%ebp,%ebx			// advance sfrac fractional part by sstep frac
+	adcl	advancetable+4(,%ecx,4),%esi	// point to next source texel
+
+	addl	tstep,%edx
+	sbbl	%ecx,%ecx
+	movb	(%esi),%al
+	addl	%ebp,%ebx
+	movb	%al,1(%edi)
+	adcl	advancetable+4(,%ecx,4),%esi
+
+	addl	tstep,%edx
+	sbbl	%ecx,%ecx
+	addl	%ebp,%ebx
+	movb	(%esi),%al
+	adcl	advancetable+4(,%ecx,4),%esi
+
+	addl	tstep,%edx
+	sbbl	%ecx,%ecx
+	movb	%al,2(%edi)
+	addl	%ebp,%ebx
+	movb	(%esi),%al
+	adcl	advancetable+4(,%ecx,4),%esi
+
+	addl	tstep,%edx
+	sbbl	%ecx,%ecx
+	movb	%al,3(%edi)
+	addl	%ebp,%ebx
+	movb	(%esi),%al
+	adcl	advancetable+4(,%ecx,4),%esi
+
+
+//
+// start FDIV for end of next segment in flight, so it can overlap
+//
+	movl	counttemp,%ecx
+	cmpl	$8,%ecx			// more than one segment after this?
+	ja		LSetupNotLast2	// yes
+
+	decl	%ecx
+	jz		LFDIVInFlight2	// if only one pixel, no need to start an FDIV
+	movl	%ecx,spancountminus1
+	fildl	spancountminus1
+
+	flds	C(d_zistepu)		// C(d_zistepu) | spancountminus1
+	fmul	%st(1),%st(0)	// C(d_zistepu)*scm1 | scm1
+	flds	C(d_tdivzstepu)	// C(d_tdivzstepu) | C(d_zistepu)*scm1 | scm1
+	fmul	%st(2),%st(0)	// C(d_tdivzstepu)*scm1 | C(d_zistepu)*scm1 | scm1
+	fxch	%st(1)			// C(d_zistepu)*scm1 | C(d_tdivzstepu)*scm1 | scm1
+	faddp	%st(0),%st(3)	// C(d_tdivzstepu)*scm1 | scm1
+	fxch	%st(1)			// scm1 | C(d_tdivzstepu)*scm1
+	fmuls	C(d_sdivzstepu)	// C(d_sdivzstepu)*scm1 | C(d_tdivzstepu)*scm1
+	fxch	%st(1)			// C(d_tdivzstepu)*scm1 | C(d_sdivzstepu)*scm1
+	faddp	%st(0),%st(3)	// C(d_sdivzstepu)*scm1
+	flds	fp_64k			// 64k | C(d_sdivzstepu)*scm1
+	fxch	%st(1)			// C(d_sdivzstepu)*scm1 | 64k
+	faddp	%st(0),%st(4)	// 64k
+
+	fdiv	%st(1),%st(0)	// this is what we've gone to all this trouble to
+							//  overlap
+	jmp		LFDIVInFlight2
+
+	.align	4
+LSetupNotLast2:
+	fadds	zi8stepu
+	fxch	%st(2)
+	fadds	sdivz8stepu
+	fxch	%st(2)
+	flds	tdivz8stepu
+	faddp	%st(0),%st(2)
+	flds	fp_64k
+	fdiv	%st(1),%st(0)	// z = 1/1/z
+							// this is what we've gone to all this trouble to
+							//  overlap
+LFDIVInFlight2:
+	movl	%ecx,counttemp
+
+	addl	tstep,%edx
+	sbbl	%ecx,%ecx
+	movb	%al,4(%edi)
+	addl	%ebp,%ebx
+	movb	(%esi),%al
+	adcl	advancetable+4(,%ecx,4),%esi
+
+	addl	tstep,%edx
+	sbbl	%ecx,%ecx
+	movb	%al,5(%edi)
+	addl	%ebp,%ebx
+	movb	(%esi),%al
+	adcl	advancetable+4(,%ecx,4),%esi
+
+	addl	tstep,%edx
+	sbbl	%ecx,%ecx
+	movb	%al,6(%edi)
+	addl	%ebp,%ebx
+	movb	(%esi),%al
+	adcl	advancetable+4(,%ecx,4),%esi
+
+	addl	$8,%edi
+	movl	%edx,tfracf
+	movl	snext,%edx
+	movl	%ebx,sfracf
+	movl	tnext,%ebx
+	movl	%edx,s
+	movl	%ebx,t
+
+	movl	counttemp,%ecx		// retrieve count
+
+//
+// determine whether last span or not
+//
+	cmpl	$8,%ecx				// are there multiple segments remaining?
+	movb	%al,-1(%edi)
+	ja		LNotLastSegment		// yes
+
+//
+// last segment of scan
+//
+LLastSegment:
+
+//
+// advance s/z, t/z, and 1/z, and calculate s & t at end of span and steps to
+// get there. The number of pixels left is variable, and we want to land on the
+// last pixel, not step one past it, so we can't run into arithmetic problems
+//
+	testl	%ecx,%ecx
+	jz		LNoSteps		// just draw the last pixel and we're done
+
+// pick up after the FDIV that was left in flight previously
+
+
+	fld		%st(0)			// duplicate it
+	fmul	%st(4),%st(0)	// s = s/z * z
+	fxch	%st(1)
+	fmul	%st(3),%st(0)	// t = t/z * z
+	fxch	%st(1)
+	fistpl	snext
+	fistpl	tnext
+
+	movb	(%esi),%al		// load first texel in segment
+	movl	C(tadjust),%ebx
+	movb	%al,(%edi)		// store first pixel in segment
+	movl	C(sadjust),%eax
+
+	addl	snext,%eax
+	addl	tnext,%ebx
+
+	movl	C(bbextents),%ebp
+	movl	C(bbextentt),%edx
+
+	cmpl	$2048,%eax
+	jl		LClampLow4
+	cmpl	%ebp,%eax
+	ja		LClampHigh4
+LClampReentry4:
+	movl	%eax,snext
+
+	cmpl	$2048,%ebx
+	jl		LClampLow5
+	cmpl	%edx,%ebx
+	ja		LClampHigh5
+LClampReentry5:
+
+	cmpl	$1,%ecx			// don't bother 
+	je		LOnlyOneStep	// if two pixels in segment, there's only one step,
+							//  of the segment length
+	subl	s,%eax
+	subl	t,%ebx
+
+	addl	%eax,%eax		// convert to 15.17 format so multiply by 1.31
+	addl	%ebx,%ebx		//  reciprocal yields 16.48
+
+	imull	reciprocal_table-8(,%ecx,4) // sstep = (snext - s) / (spancount-1)
+	movl	%edx,%ebp
+
+	movl	%ebx,%eax
+	imull	reciprocal_table-8(,%ecx,4) // tstep = (tnext - t) / (spancount-1)
+
+LSetEntryvec:
+//
+// set up advancetable
+//
+	movl	entryvec_table(,%ecx,4),%ebx
+	movl	%edx,%eax
+	movl	%ebx,jumptemp		// entry point into code for RET later
+	movl	%ebp,%ecx
+	sarl	$16,%edx			// tstep >>= 16;
+	movl	C(cachewidth),%ebx
+	sarl	$16,%ecx			// sstep >>= 16;
+	imull	%ebx,%edx
+
+	addl	%ecx,%edx			// add in sstep
+								// (tstep >> 16) * cachewidth + (sstep >> 16);
+	movl	tfracf,%ecx
+	movl	%edx,advancetable+4	// advance base in t
+	addl	%ebx,%edx			// ((tstep >> 16) + 1) * cachewidth +
+								//  (sstep >> 16);
+	shll	$16,%ebp			// left-justify sstep fractional part
+	movl	sfracf,%ebx
+	shll	$16,%eax			// left-justify tstep fractional part
+	movl	%edx,advancetable	// advance extra in t
+
+	movl	%eax,tstep
+	movl	%ecx,%edx
+	addl	%eax,%edx
+	sbbl	%ecx,%ecx
+	addl	%ebp,%ebx
+	adcl	advancetable+4(,%ecx,4),%esi
+
+	jmp		*jumptemp			// jump to the number-of-pixels handler
+
+//----------------------------------------
+
+LNoSteps:
+	movb	(%esi),%al		// load first texel in segment
+	subl	$7,%edi			// adjust for hardwired offset
+	jmp		LEndSpan
+
+
+LOnlyOneStep:
+	subl	s,%eax
+	subl	t,%ebx
+	movl	%eax,%ebp
+	movl	%ebx,%edx
+	jmp		LSetEntryvec
+
+//----------------------------------------
+
+.globl	Entry2_8
+Entry2_8:
+	subl	$6,%edi		// adjust for hardwired offsets
+	movb	(%esi),%al
+	jmp		LLEntry2_8
+
+//----------------------------------------
+
+.globl	Entry3_8
+Entry3_8:
+	subl	$5,%edi		// adjust for hardwired offsets
+	addl	%eax,%edx
+	movb	(%esi),%al
+	sbbl	%ecx,%ecx
+	addl	%ebp,%ebx
+	adcl	advancetable+4(,%ecx,4),%esi
+	jmp		LLEntry3_8
+
+//----------------------------------------
+
+.globl	Entry4_8
+Entry4_8:
+	subl	$4,%edi		// adjust for hardwired offsets
+	addl	%eax,%edx
+	movb	(%esi),%al
+	sbbl	%ecx,%ecx
+	addl	%ebp,%ebx
+	adcl	advancetable+4(,%ecx,4),%esi
+	addl	tstep,%edx
+	jmp		LLEntry4_8
+
+//----------------------------------------
+
+.globl	Entry5_8
+Entry5_8:
+	subl	$3,%edi		// adjust for hardwired offsets
+	addl	%eax,%edx
+	movb	(%esi),%al
+	sbbl	%ecx,%ecx
+	addl	%ebp,%ebx
+	adcl	advancetable+4(,%ecx,4),%esi
+	addl	tstep,%edx
+	jmp		LLEntry5_8
+
+//----------------------------------------
+
+.globl	Entry6_8
+Entry6_8:
+	subl	$2,%edi		// adjust for hardwired offsets
+	addl	%eax,%edx
+	movb	(%esi),%al
+	sbbl	%ecx,%ecx
+	addl	%ebp,%ebx
+	adcl	advancetable+4(,%ecx,4),%esi
+	addl	tstep,%edx
+	jmp		LLEntry6_8
+
+//----------------------------------------
+
+.globl	Entry7_8
+Entry7_8:
+	decl	%edi		// adjust for hardwired offsets
+	addl	%eax,%edx
+	movb	(%esi),%al
+	sbbl	%ecx,%ecx
+	addl	%ebp,%ebx
+	adcl	advancetable+4(,%ecx,4),%esi
+	addl	tstep,%edx
+	jmp		LLEntry7_8
+
+//----------------------------------------
+
+.globl	Entry8_8
+Entry8_8:
+	addl	%eax,%edx
+	movb	(%esi),%al
+	sbbl	%ecx,%ecx
+	addl	%ebp,%ebx
+	adcl	advancetable+4(,%ecx,4),%esi
+
+	addl	tstep,%edx
+	sbbl	%ecx,%ecx
+	movb	%al,1(%edi)
+	addl	%ebp,%ebx
+	movb	(%esi),%al
+	adcl	advancetable+4(,%ecx,4),%esi
+	addl	tstep,%edx
+LLEntry7_8:
+	sbbl	%ecx,%ecx
+	movb	%al,2(%edi)
+	addl	%ebp,%ebx
+	movb	(%esi),%al
+	adcl	advancetable+4(,%ecx,4),%esi
+	addl	tstep,%edx
+LLEntry6_8:
+	sbbl	%ecx,%ecx
+	movb	%al,3(%edi)
+	addl	%ebp,%ebx
+	movb	(%esi),%al
+	adcl	advancetable+4(,%ecx,4),%esi
+	addl	tstep,%edx
+LLEntry5_8:
+	sbbl	%ecx,%ecx
+	movb	%al,4(%edi)
+	addl	%ebp,%ebx
+	movb	(%esi),%al
+	adcl	advancetable+4(,%ecx,4),%esi
+	addl	tstep,%edx
+LLEntry4_8:
+	sbbl	%ecx,%ecx
+	movb	%al,5(%edi)
+	addl	%ebp,%ebx
+	movb	(%esi),%al
+	adcl	advancetable+4(,%ecx,4),%esi
+LLEntry3_8:
+	movb	%al,6(%edi)
+	movb	(%esi),%al
+LLEntry2_8:
+
+LEndSpan:
+
+//
+// clear s/z, t/z, 1/z from FP stack
+//
+	fstp %st(0)
+	fstp %st(0)
+	fstp %st(0)
+
+	movl	pspantemp,%ebx				// restore spans pointer
+	movl	espan_t_pnext(%ebx),%ebx	// point to next span
+	testl	%ebx,%ebx			// any more spans?
+	movb	%al,7(%edi)
+	jnz		LSpanLoop			// more spans
+
+	popl	%ebx				// restore register variables
+	popl	%esi
+	popl	%edi
+	popl	%ebp				// restore the caller's stack frame
+	ret
+
+//----------------------------------------------------------------------
+// 8-bpp horizontal span z drawing codefor polygons, with no transparency.
+//
+// Assumes there is at least one span in pzspans, and that every span
+// contains at least one pixel
+//----------------------------------------------------------------------
+
+	.text
+
+// z-clamp on a non-negative gradient span
+LClamp:
+	movl	$0x40000000,%edx
+	xorl	%ebx,%ebx
+	fstp	%st(0)
+	jmp		LZDraw
+
+// z-clamp on a negative gradient span
+LClampNeg:
+	movl	$0x40000000,%edx
+	xorl	%ebx,%ebx
+	fstp	%st(0)
+	jmp		LZDrawNeg
+
+
+#define pzspans	4+16
+
+.globl C(D_DrawZSpans)
+C(D_DrawZSpans):
+	pushl	%ebp				// preserve caller's stack frame
+	pushl	%edi
+	pushl	%esi				// preserve register variables
+	pushl	%ebx
+
+	flds	C(d_zistepu)
+	movl	C(d_zistepu),%eax
+	movl	pzspans(%esp),%esi
+	testl	%eax,%eax
+	jz		LFNegSpan
+
+	fmuls	Float2ToThe31nd
+	fistpl	izistep		// note: we are relying on FP exceptions being turned
+						// off here to avoid range problems
+	movl	izistep,%ebx	// remains loaded for all spans
+
+LFSpanLoop:
+// set up the initial 1/z value
+	fildl	espan_t_v(%esi)
+	fildl	espan_t_u(%esi)
+	movl	espan_t_v(%esi),%ecx
+	movl	C(d_pzbuffer),%edi
+	fmuls	C(d_zistepu)
+	fxch	%st(1)
+	fmuls	C(d_zistepv)
+	fxch	%st(1)
+	fadds	C(d_ziorigin)
+	imull	C(d_zrowbytes),%ecx
+	faddp	%st(0),%st(1)
+
+// clamp if z is nearer than 2 (1/z > 0.5)
+	fcoms	float_point5
+	addl	%ecx,%edi
+	movl	espan_t_u(%esi),%edx
+	addl	%edx,%edx				// word count
+	movl	espan_t_count(%esi),%ecx
+	addl	%edx,%edi				// pdest = &pdestspan[scans->u];
+	pushl	%esi		// preserve spans pointer
+	fnstsw	%ax
+	testb	$0x45,%ah
+	jz		LClamp
+
+	fmuls	Float2ToThe31nd
+	fistpl	izi			// note: we are relying on FP exceptions being turned
+						// off here to avoid problems when the span is closer
+						// than 1/(2**31)
+	movl	izi,%edx
+
+// at this point:
+// %ebx = izistep
+// %ecx = count
+// %edx = izi
+// %edi = pdest
+
+LZDraw:
+
+// do a single pixel up front, if necessary to dword align the destination
+	testl	$2,%edi
+	jz		LFMiddle
+	movl	%edx,%eax
+	addl	%ebx,%edx
+	shrl	$16,%eax
+	decl	%ecx
+	movw	%ax,(%edi)
+	addl	$2,%edi
+
+// do middle a pair of aligned dwords at a time
+LFMiddle:
+	pushl	%ecx
+	shrl	$1,%ecx				// count / 2
+	jz		LFLast				// no aligned dwords to do
+	shrl	$1,%ecx				// (count / 2) / 2
+	jnc		LFMiddleLoop		// even number of aligned dwords to do
+
+	movl	%edx,%eax
+	addl	%ebx,%edx
+	shrl	$16,%eax
+	movl	%edx,%esi
+	addl	%ebx,%edx
+	andl	$0xFFFF0000,%esi
+	orl		%esi,%eax
+	movl	%eax,(%edi)
+	addl	$4,%edi
+	andl	%ecx,%ecx
+	jz		LFLast
+
+LFMiddleLoop:
+	movl	%edx,%eax
+	addl	%ebx,%edx
+	shrl	$16,%eax
+	movl	%edx,%esi
+	addl	%ebx,%edx
+	andl	$0xFFFF0000,%esi
+	orl		%esi,%eax
+	movl	%edx,%ebp
+	movl	%eax,(%edi)
+	addl	%ebx,%edx
+	shrl	$16,%ebp
+	movl	%edx,%esi
+	addl	%ebx,%edx
+	andl	$0xFFFF0000,%esi
+	orl		%esi,%ebp
+	movl	%ebp,4(%edi)	// FIXME: eliminate register contention
+	addl	$8,%edi
+
+	decl	%ecx
+	jnz		LFMiddleLoop
+
+LFLast:
+	popl	%ecx			// retrieve count
+	popl	%esi			// retrieve span pointer
+
+// do the last, unaligned pixel, if there is one
+	andl	$1,%ecx			// is there an odd pixel left to do?
+	jz		LFSpanDone		// no
+	shrl	$16,%edx
+	movw	%dx,(%edi)		// do the final pixel's z
+
+LFSpanDone:
+	movl	espan_t_pnext(%esi),%esi
+	testl	%esi,%esi
+	jnz		LFSpanLoop
+
+	jmp		LFDone
+
+LFNegSpan:
+	fmuls	FloatMinus2ToThe31nd
+	fistpl	izistep		// note: we are relying on FP exceptions being turned
+						// off here to avoid range problems
+	movl	izistep,%ebx	// remains loaded for all spans
+
+LFNegSpanLoop:
+// set up the initial 1/z value
+	fildl	espan_t_v(%esi)
+	fildl	espan_t_u(%esi)
+	movl	espan_t_v(%esi),%ecx
+	movl	C(d_pzbuffer),%edi
+	fmuls	C(d_zistepu)
+	fxch	%st(1)
+	fmuls	C(d_zistepv)
+	fxch	%st(1)
+	fadds	C(d_ziorigin)
+	imull	C(d_zrowbytes),%ecx
+	faddp	%st(0),%st(1)
+
+// clamp if z is nearer than 2 (1/z > 0.5)
+	fcoms	float_point5
+	addl	%ecx,%edi
+	movl	espan_t_u(%esi),%edx
+	addl	%edx,%edx				// word count
+	movl	espan_t_count(%esi),%ecx
+	addl	%edx,%edi				// pdest = &pdestspan[scans->u];
+	pushl	%esi		// preserve spans pointer
+	fnstsw	%ax
+	testb	$0x45,%ah
+	jz		LClampNeg
+
+	fmuls	Float2ToThe31nd
+	fistpl	izi			// note: we are relying on FP exceptions being turned
+						// off here to avoid problems when the span is closer
+						// than 1/(2**31)
+	movl	izi,%edx
+
+// at this point:
+// %ebx = izistep
+// %ecx = count
+// %edx = izi
+// %edi = pdest
+
+LZDrawNeg:
+
+// do a single pixel up front, if necessary to dword align the destination
+	testl	$2,%edi
+	jz		LFNegMiddle
+	movl	%edx,%eax
+	subl	%ebx,%edx
+	shrl	$16,%eax
+	decl	%ecx
+	movw	%ax,(%edi)
+	addl	$2,%edi
+
+// do middle a pair of aligned dwords at a time
+LFNegMiddle:
+	pushl	%ecx
+	shrl	$1,%ecx				// count / 2
+	jz		LFNegLast			// no aligned dwords to do
+	shrl	$1,%ecx				// (count / 2) / 2
+	jnc		LFNegMiddleLoop		// even number of aligned dwords to do
+
+	movl	%edx,%eax
+	subl	%ebx,%edx
+	shrl	$16,%eax
+	movl	%edx,%esi
+	subl	%ebx,%edx
+	andl	$0xFFFF0000,%esi
+	orl		%esi,%eax
+	movl	%eax,(%edi)
+	addl	$4,%edi
+	andl	%ecx,%ecx
+	jz		LFNegLast
+
+LFNegMiddleLoop:
+	movl	%edx,%eax
+	subl	%ebx,%edx
+	shrl	$16,%eax
+	movl	%edx,%esi
+	subl	%ebx,%edx
+	andl	$0xFFFF0000,%esi
+	orl		%esi,%eax
+	movl	%edx,%ebp
+	movl	%eax,(%edi)
+	subl	%ebx,%edx
+	shrl	$16,%ebp
+	movl	%edx,%esi
+	subl	%ebx,%edx
+	andl	$0xFFFF0000,%esi
+	orl		%esi,%ebp
+	movl	%ebp,4(%edi)	// FIXME: eliminate register contention
+	addl	$8,%edi
+
+	decl	%ecx
+	jnz		LFNegMiddleLoop
+
+LFNegLast:
+	popl	%ecx			// retrieve count
+	popl	%esi			// retrieve span pointer
+
+// do the last, unaligned pixel, if there is one
+	andl	$1,%ecx			// is there an odd pixel left to do?
+	jz		LFNegSpanDone	// no
+	shrl	$16,%edx
+	movw	%dx,(%edi)		// do the final pixel's z
+
+LFNegSpanDone:
+	movl	espan_t_pnext(%esi),%esi
+	testl	%esi,%esi
+	jnz		LFNegSpanLoop
+
+LFDone:
+	popl	%ebx				// restore register variables
+	popl	%esi
+	popl	%edi
+	popl	%ebp				// restore the caller's stack frame
+	ret
+
+#endif	// id386
diff -ruN WinQuake/d_draw.s sdlquake-1.0.9/d_draw.s
--- WinQuake/d_draw.s	Tue Dec 21 15:53:24 1999
+++ sdlquake-1.0.9/d_draw.s	Wed Dec 31 16:00:00 1969
@@ -1,1037 +0,0 @@
-/*
-Copyright (C) 1996-1997 Id Software, Inc.
-
-This program is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License
-as published by the Free Software Foundation; either version 2
-of the License, or (at your option) any later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
-
-See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-*/
-//
-// d_draw.s
-// x86 assembly-language horizontal 8-bpp span-drawing code.
-//
-
-#include "asm_i386.h"
-#include "quakeasm.h"
-#include "asm_draw.h"
-#include "d_ifacea.h"
-
-#if	id386
-
-//----------------------------------------------------------------------
-// 8-bpp horizontal span drawing code for polygons, with no transparency.
-//
-// Assumes there is at least one span in pspans, and that every span
-// contains at least one pixel
-//----------------------------------------------------------------------
-
-	.text
-
-// out-of-line, rarely-needed clamping code
-
-LClampHigh0:
-	movl	C(bbextents),%esi
-	jmp		LClampReentry0
-LClampHighOrLow0:
-	jg		LClampHigh0
-	xorl	%esi,%esi
-	jmp		LClampReentry0
-
-LClampHigh1:
-	movl	C(bbextentt),%edx
-	jmp		LClampReentry1
-LClampHighOrLow1:
-	jg		LClampHigh1
-	xorl	%edx,%edx
-	jmp		LClampReentry1
-
-LClampLow2:
-	movl	$2048,%ebp
-	jmp		LClampReentry2
-LClampHigh2:
-	movl	C(bbextents),%ebp
-	jmp		LClampReentry2
-
-LClampLow3:
-	movl	$2048,%ecx
-	jmp		LClampReentry3
-LClampHigh3:
-	movl	C(bbextentt),%ecx
-	jmp		LClampReentry3
-
-LClampLow4:
-	movl	$2048,%eax
-	jmp		LClampReentry4
-LClampHigh4:
-	movl	C(bbextents),%eax
-	jmp		LClampReentry4
-
-LClampLow5:
-	movl	$2048,%ebx
-	jmp		LClampReentry5
-LClampHigh5:
-	movl	C(bbextentt),%ebx
-	jmp		LClampReentry5
-
-
-#define pspans	4+16
-
-	.align 4
-.globl C(D_DrawSpans8)
-C(D_DrawSpans8):
-	pushl	%ebp				// preserve caller's stack frame
-	pushl	%edi
-	pushl	%esi				// preserve register variables
-	pushl	%ebx
-
-//
-// set up scaled-by-8 steps, for 8-long segments; also set up cacheblock
-// and span list pointers
-//
-// TODO: any overlap from rearranging?
-	flds	C(d_sdivzstepu)
-	fmuls	fp_8
-	movl	C(cacheblock),%edx
-	flds	C(d_tdivzstepu)
-	fmuls	fp_8
-	movl	pspans(%esp),%ebx	// point to the first span descriptor
-	flds	C(d_zistepu)
-	fmuls	fp_8
-	movl	%edx,pbase			// pbase = cacheblock
-	fstps	zi8stepu
-	fstps	tdivz8stepu
-	fstps	sdivz8stepu
-
-LSpanLoop:
-//
-// set up the initial s/z, t/z, and 1/z on the FP stack, and generate the
-// initial s and t values
-//
-// FIXME: pipeline FILD?
-	fildl	espan_t_v(%ebx)
-	fildl	espan_t_u(%ebx)
-
-	fld		%st(1)			// dv | du | dv
-	fmuls	C(d_sdivzstepv)	// dv*d_sdivzstepv | du | dv
-	fld		%st(1)			// du | dv*d_sdivzstepv | du | dv
-	fmuls	C(d_sdivzstepu)	// du*d_sdivzstepu | dv*d_sdivzstepv | du | dv
-	fld		%st(2)			// du | du*d_sdivzstepu | dv*d_sdivzstepv | du | dv
-	fmuls	C(d_tdivzstepu)	// du*d_tdivzstepu | du*d_sdivzstepu |
-							//  dv*d_sdivzstepv | du | dv
-	fxch	%st(1)			// du*d_sdivzstepu | du*d_tdivzstepu |
-							//  dv*d_sdivzstepv | du | dv
-	faddp	%st(0),%st(2)	// du*d_tdivzstepu |
-							//  du*d_sdivzstepu + dv*d_sdivzstepv | du | dv
-	fxch	%st(1)			// du*d_sdivzstepu + dv*d_sdivzstepv |
-							//  du*d_tdivzstepu | du | dv
-	fld		%st(3)			// dv | du*d_sdivzstepu + dv*d_sdivzstepv |
-							//  du*d_tdivzstepu | du | dv
-	fmuls	C(d_tdivzstepv)	// dv*d_tdivzstepv |
-							//  du*d_sdivzstepu + dv*d_sdivzstepv |
-							//  du*d_tdivzstepu | du | dv
-	fxch	%st(1)			// du*d_sdivzstepu + dv*d_sdivzstepv |
-							//  dv*d_tdivzstepv | du*d_tdivzstepu | du | dv
-	fadds	C(d_sdivzorigin)	// sdivz = d_sdivzorigin + dv*d_sdivzstepv +
-							//  du*d_sdivzstepu; stays in %st(2) at end
-	fxch	%st(4)			// dv | dv*d_tdivzstepv | du*d_tdivzstepu | du |
-							//  s/z
-	fmuls	C(d_zistepv)		// dv*d_zistepv | dv*d_tdivzstepv |
-							//  du*d_tdivzstepu | du | s/z
-	fxch	%st(1)			// dv*d_tdivzstepv |  dv*d_zistepv |
-							//  du*d_tdivzstepu | du | s/z
-	faddp	%st(0),%st(2)	// dv*d_zistepv |
-							//  dv*d_tdivzstepv + du*d_tdivzstepu | du | s/z
-	fxch	%st(2)			// du | dv*d_tdivzstepv + du*d_tdivzstepu |
-							//  dv*d_zistepv | s/z
-	fmuls	C(d_zistepu)		// du*d_zistepu |
-							//  dv*d_tdivzstepv + du*d_tdivzstepu |
-							//  dv*d_zistepv | s/z
-	fxch	%st(1)			// dv*d_tdivzstepv + du*d_tdivzstepu |
-							//  du*d_zistepu | dv*d_zistepv | s/z
-	fadds	C(d_tdivzorigin)	// tdivz = d_tdivzorigin + dv*d_tdivzstepv +
-							//  du*d_tdivzstepu; stays in %st(1) at end
-	fxch	%st(2)			// dv*d_zistepv | du*d_zistepu | t/z | s/z
-	faddp	%st(0),%st(1)	// dv*d_zistepv + du*d_zistepu | t/z | s/z
-
-	flds	fp_64k			// fp_64k | dv*d_zistepv + du*d_zistepu | t/z | s/z
-	fxch	%st(1)			// dv*d_zistepv + du*d_zistepu | fp_64k | t/z | s/z
-	fadds	C(d_ziorigin)		// zi = d_ziorigin + dv*d_zistepv +
-							//  du*d_zistepu; stays in %st(0) at end
-							// 1/z | fp_64k | t/z | s/z
-//
-// calculate and clamp s & t
-//
-	fdivr	%st(0),%st(1)	// 1/z | z*64k | t/z | s/z
-
-//
-// point %edi to the first pixel in the span
-//
-	movl	C(d_viewbuffer),%ecx
-	movl	espan_t_v(%ebx),%eax
-	movl	%ebx,pspantemp	// preserve spans pointer
-
-	movl	C(tadjust),%edx
-	movl	C(sadjust),%esi
-	movl	C(d_scantable)(,%eax,4),%edi	// v * screenwidth
-	addl	%ecx,%edi
-	movl	espan_t_u(%ebx),%ecx
-	addl	%ecx,%edi				// pdest = &pdestspan[scans->u];
-	movl	espan_t_count(%ebx),%ecx
-
-//
-// now start the FDIV for the end of the span
-//
-	cmpl	$8,%ecx
-	ja		LSetupNotLast1
-
-	decl	%ecx
-	jz		LCleanup1		// if only one pixel, no need to start an FDIV
-	movl	%ecx,spancountminus1
-
-// finish up the s and t calcs
-	fxch	%st(1)			// z*64k | 1/z | t/z | s/z
-
-	fld		%st(0)			// z*64k | z*64k | 1/z | t/z | s/z
-	fmul	%st(4),%st(0)	// s | z*64k | 1/z | t/z | s/z
-	fxch	%st(1)			// z*64k | s | 1/z | t/z | s/z
-	fmul	%st(3),%st(0)	// t | s | 1/z | t/z | s/z
-	fxch	%st(1)			// s | t | 1/z | t/z | s/z
-	fistpl	s				// 1/z | t | t/z | s/z
-	fistpl	t				// 1/z | t/z | s/z
-
-	fildl	spancountminus1
-
-	flds	C(d_tdivzstepu)	// C(d_tdivzstepu) | spancountminus1
-	flds	C(d_zistepu)		// C(d_zistepu) | C(d_tdivzstepu) | spancountminus1
-	fmul	%st(2),%st(0)	// C(d_zistepu)*scm1 | C(d_tdivzstepu) | scm1
-	fxch	%st(1)			// C(d_tdivzstepu) | C(d_zistepu)*scm1 | scm1
-	fmul	%st(2),%st(0)	// C(d_tdivzstepu)*scm1 | C(d_zistepu)*scm1 | scm1
-	fxch	%st(2)			// scm1 | C(d_zistepu)*scm1 | C(d_tdivzstepu)*scm1
-	fmuls	C(d_sdivzstepu)	// C(d_sdivzstepu)*scm1 | C(d_zistepu)*scm1 |
-							//  C(d_tdivzstepu)*scm1
-	fxch	%st(1)			// C(d_zistepu)*scm1 | C(d_sdivzstepu)*scm1 |
-							//  C(d_tdivzstepu)*scm1
-	faddp	%st(0),%st(3)	// C(d_sdivzstepu)*scm1 | C(d_tdivzstepu)*scm1
-	fxch	%st(1)			// C(d_tdivzstepu)*scm1 | C(d_sdivzstepu)*scm1
-	faddp	%st(0),%st(3)	// C(d_sdivzstepu)*scm1
-	faddp	%st(0),%st(3)
-
-	flds	fp_64k
-	fdiv	%st(1),%st(0)	// this is what we've gone to all this trouble to
-							//  overlap
-	jmp		LFDIVInFlight1
-
-LCleanup1:
-// finish up the s and t calcs
-	fxch	%st(1)			// z*64k | 1/z | t/z | s/z
-
-	fld		%st(0)			// z*64k | z*64k | 1/z | t/z | s/z
-	fmul	%st(4),%st(0)	// s | z*64k | 1/z | t/z | s/z
-	fxch	%st(1)			// z*64k | s | 1/z | t/z | s/z
-	fmul	%st(3),%st(0)	// t | s | 1/z | t/z | s/z
-	fxch	%st(1)			// s | t | 1/z | t/z | s/z
-	fistpl	s				// 1/z | t | t/z | s/z
-	fistpl	t				// 1/z | t/z | s/z
-	jmp		LFDIVInFlight1
-
-	.align	4
-LSetupNotLast1:
-// finish up the s and t calcs
-	fxch	%st(1)			// z*64k | 1/z | t/z | s/z
-
-	fld		%st(0)			// z*64k | z*64k | 1/z | t/z | s/z
-	fmul	%st(4),%st(0)	// s | z*64k | 1/z | t/z | s/z
-	fxch	%st(1)			// z*64k | s | 1/z | t/z | s/z
-	fmul	%st(3),%st(0)	// t | s | 1/z | t/z | s/z
-	fxch	%st(1)			// s | t | 1/z | t/z | s/z
-	fistpl	s				// 1/z | t | t/z | s/z
-	fistpl	t				// 1/z | t/z | s/z
-
-	fadds	zi8stepu
-	fxch	%st(2)
-	fadds	sdivz8stepu
-	fxch	%st(2)
-	flds	tdivz8stepu
-	faddp	%st(0),%st(2)
-	flds	fp_64k
-	fdiv	%st(1),%st(0)	// z = 1/1/z
-							// this is what we've gone to all this trouble to
-							//  overlap
-LFDIVInFlight1:
-
-	addl	s,%esi
-	addl	t,%edx
-	movl	C(bbextents),%ebx
-	movl	C(bbextentt),%ebp
-	cmpl	%ebx,%esi
-	ja		LClampHighOrLow0
-LClampReentry0:
-	movl	%esi,s
-	movl	pbase,%ebx
-	shll	$16,%esi
-	cmpl	%ebp,%edx
-	movl	%esi,sfracf
-	ja		LClampHighOrLow1
-LClampReentry1:
-	movl	%edx,t
-	movl	s,%esi					// sfrac = scans->sfrac;
-	shll	$16,%edx
-	movl	t,%eax					// tfrac = scans->tfrac;
-	sarl	$16,%esi
-	movl	%edx,tfracf
-
-//
-// calculate the texture starting address
-//
-	sarl	$16,%eax
-	movl	C(cachewidth),%edx
-	imull	%edx,%eax				// (tfrac >> 16) * cachewidth
-	addl	%ebx,%esi
-	addl	%eax,%esi				// psource = pbase + (sfrac >> 16) +
-									//           ((tfrac >> 16) * cachewidth);
-
-//
-// determine whether last span or not
-//
-	cmpl	$8,%ecx
-	jna		LLastSegment
-
-//
-// not the last segment; do full 8-wide segment
-//
-LNotLastSegment:
-
-//
-// advance s/z, t/z, and 1/z, and calculate s & t at end of span and steps to
-// get there
-//
-
-// pick up after the FDIV that was left in flight previously
-
-	fld		%st(0)			// duplicate it
-	fmul	%st(4),%st(0)	// s = s/z * z
-	fxch	%st(1)
-	fmul	%st(3),%st(0)	// t = t/z * z
-	fxch	%st(1)
-	fistpl	snext
-	fistpl	tnext
-	movl	snext,%eax
-	movl	tnext,%edx
-
-	movb	(%esi),%bl	// get first source texel
-	subl	$8,%ecx		// count off this segments' pixels
-	movl	C(sadjust),%ebp
-	movl	%ecx,counttemp	// remember count of remaining pixels
-
-	movl	C(tadjust),%ecx
-	movb	%bl,(%edi)	// store first dest pixel
-
-	addl	%eax,%ebp
-	addl	%edx,%ecx
-
-	movl	C(bbextents),%eax
-	movl	C(bbextentt),%edx
-
-	cmpl	$2048,%ebp
-	jl		LClampLow2
-	cmpl	%eax,%ebp
-	ja		LClampHigh2
-LClampReentry2:
-
-	cmpl	$2048,%ecx
-	jl		LClampLow3
-	cmpl	%edx,%ecx
-	ja		LClampHigh3
-LClampReentry3:
-
-	movl	%ebp,snext
-	movl	%ecx,tnext
-
-	subl	s,%ebp
-	subl	t,%ecx
-	
-//
-// set up advancetable
-//
-	movl	%ecx,%eax
-	movl	%ebp,%edx
-	sarl	$19,%eax			// tstep >>= 16;
-	jz		LZero
-	sarl	$19,%edx			// sstep >>= 16;
-	movl	C(cachewidth),%ebx
-	imull	%ebx,%eax
-	jmp		LSetUp1
-
-LZero:
-	sarl	$19,%edx			// sstep >>= 16;
-	movl	C(cachewidth),%ebx
-
-LSetUp1:
-
-	addl	%edx,%eax			// add in sstep
-								// (tstep >> 16) * cachewidth + (sstep >> 16);
-	movl	tfracf,%edx
-	movl	%eax,advancetable+4	// advance base in t
-	addl	%ebx,%eax			// ((tstep >> 16) + 1) * cachewidth +
-								//  (sstep >> 16);
-	shll	$13,%ebp			// left-justify sstep fractional part
-	movl	sfracf,%ebx
-	shll	$13,%ecx			// left-justify tstep fractional part
-	movl	%eax,advancetable	// advance extra in t
-
-	movl	%ecx,tstep
-	addl	%ecx,%edx			// advance tfrac fractional part by tstep frac
-
-	sbbl	%ecx,%ecx			// turn tstep carry into -1 (0 if none)
-	addl	%ebp,%ebx			// advance sfrac fractional part by sstep frac
-	adcl	advancetable+4(,%ecx,4),%esi	// point to next source texel
-
-	addl	tstep,%edx
-	sbbl	%ecx,%ecx
-	movb	(%esi),%al
-	addl	%ebp,%ebx
-	movb	%al,1(%edi)
-	adcl	advancetable+4(,%ecx,4),%esi
-
-	addl	tstep,%edx
-	sbbl	%ecx,%ecx
-	addl	%ebp,%ebx
-	movb	(%esi),%al
-	adcl	advancetable+4(,%ecx,4),%esi
-
-	addl	tstep,%edx
-	sbbl	%ecx,%ecx
-	movb	%al,2(%edi)
-	addl	%ebp,%ebx
-	movb	(%esi),%al
-	adcl	advancetable+4(,%ecx,4),%esi
-
-	addl	tstep,%edx
-	sbbl	%ecx,%ecx
-	movb	%al,3(%edi)
-	addl	%ebp,%ebx
-	movb	(%esi),%al
-	adcl	advancetable+4(,%ecx,4),%esi
-
-
-//
-// start FDIV for end of next segment in flight, so it can overlap
-//
-	movl	counttemp,%ecx
-	cmpl	$8,%ecx			// more than one segment after this?
-	ja		LSetupNotLast2	// yes
-
-	decl	%ecx
-	jz		LFDIVInFlight2	// if only one pixel, no need to start an FDIV
-	movl	%ecx,spancountminus1
-	fildl	spancountminus1
-
-	flds	C(d_zistepu)		// C(d_zistepu) | spancountminus1
-	fmul	%st(1),%st(0)	// C(d_zistepu)*scm1 | scm1
-	flds	C(d_tdivzstepu)	// C(d_tdivzstepu) | C(d_zistepu)*scm1 | scm1
-	fmul	%st(2),%st(0)	// C(d_tdivzstepu)*scm1 | C(d_zistepu)*scm1 | scm1
-	fxch	%st(1)			// C(d_zistepu)*scm1 | C(d_tdivzstepu)*scm1 | scm1
-	faddp	%st(0),%st(3)	// C(d_tdivzstepu)*scm1 | scm1
-	fxch	%st(1)			// scm1 | C(d_tdivzstepu)*scm1
-	fmuls	C(d_sdivzstepu)	// C(d_sdivzstepu)*scm1 | C(d_tdivzstepu)*scm1
-	fxch	%st(1)			// C(d_tdivzstepu)*scm1 | C(d_sdivzstepu)*scm1
-	faddp	%st(0),%st(3)	// C(d_sdivzstepu)*scm1
-	flds	fp_64k			// 64k | C(d_sdivzstepu)*scm1
-	fxch	%st(1)			// C(d_sdivzstepu)*scm1 | 64k
-	faddp	%st(0),%st(4)	// 64k
-
-	fdiv	%st(1),%st(0)	// this is what we've gone to all this trouble to
-							//  overlap
-	jmp		LFDIVInFlight2
-
-	.align	4
-LSetupNotLast2:
-	fadds	zi8stepu
-	fxch	%st(2)
-	fadds	sdivz8stepu
-	fxch	%st(2)
-	flds	tdivz8stepu
-	faddp	%st(0),%st(2)
-	flds	fp_64k
-	fdiv	%st(1),%st(0)	// z = 1/1/z
-							// this is what we've gone to all this trouble to
-							//  overlap
-LFDIVInFlight2:
-	movl	%ecx,counttemp
-
-	addl	tstep,%edx
-	sbbl	%ecx,%ecx
-	movb	%al,4(%edi)
-	addl	%ebp,%ebx
-	movb	(%esi),%al
-	adcl	advancetable+4(,%ecx,4),%esi
-
-	addl	tstep,%edx
-	sbbl	%ecx,%ecx
-	movb	%al,5(%edi)
-	addl	%ebp,%ebx
-	movb	(%esi),%al
-	adcl	advancetable+4(,%ecx,4),%esi
-
-	addl	tstep,%edx
-	sbbl	%ecx,%ecx
-	movb	%al,6(%edi)
-	addl	%ebp,%ebx
-	movb	(%esi),%al
-	adcl	advancetable+4(,%ecx,4),%esi
-
-	addl	$8,%edi
-	movl	%edx,tfracf
-	movl	snext,%edx
-	movl	%ebx,sfracf
-	movl	tnext,%ebx
-	movl	%edx,s
-	movl	%ebx,t
-
-	movl	counttemp,%ecx		// retrieve count
-
-//
-// determine whether last span or not
-//
-	cmpl	$8,%ecx				// are there multiple segments remaining?
-	movb	%al,-1(%edi)
-	ja		LNotLastSegment		// yes
-
-//
-// last segment of scan
-//
-LLastSegment:
-
-//
-// advance s/z, t/z, and 1/z, and calculate s & t at end of span and steps to
-// get there. The number of pixels left is variable, and we want to land on the
-// last pixel, not step one past it, so we can't run into arithmetic problems
-//
-	testl	%ecx,%ecx
-	jz		LNoSteps		// just draw the last pixel and we're done
-
-// pick up after the FDIV that was left in flight previously
-
-
-	fld		%st(0)			// duplicate it
-	fmul	%st(4),%st(0)	// s = s/z * z
-	fxch	%st(1)
-	fmul	%st(3),%st(0)	// t = t/z * z
-	fxch	%st(1)
-	fistpl	snext
-	fistpl	tnext
-
-	movb	(%esi),%al		// load first texel in segment
-	movl	C(tadjust),%ebx
-	movb	%al,(%edi)		// store first pixel in segment
-	movl	C(sadjust),%eax
-
-	addl	snext,%eax
-	addl	tnext,%ebx
-
-	movl	C(bbextents),%ebp
-	movl	C(bbextentt),%edx
-
-	cmpl	$2048,%eax
-	jl		LClampLow4
-	cmpl	%ebp,%eax
-	ja		LClampHigh4
-LClampReentry4:
-	movl	%eax,snext
-
-	cmpl	$2048,%ebx
-	jl		LClampLow5
-	cmpl	%edx,%ebx
-	ja		LClampHigh5
-LClampReentry5:
-
-	cmpl	$1,%ecx			// don't bother 
-	je		LOnlyOneStep	// if two pixels in segment, there's only one step,
-							//  of the segment length
-	subl	s,%eax
-	subl	t,%ebx
-
-	addl	%eax,%eax		// convert to 15.17 format so multiply by 1.31
-	addl	%ebx,%ebx		//  reciprocal yields 16.48
-
-	imull	reciprocal_table-8(,%ecx,4) // sstep = (snext - s) / (spancount-1)
-	movl	%edx,%ebp
-
-	movl	%ebx,%eax
-	imull	reciprocal_table-8(,%ecx,4) // tstep = (tnext - t) / (spancount-1)
-
-LSetEntryvec:
-//
-// set up advancetable
-//
-	movl	entryvec_table(,%ecx,4),%ebx
-	movl	%edx,%eax
-	movl	%ebx,jumptemp		// entry point into code for RET later
-	movl	%ebp,%ecx
-	sarl	$16,%edx			// tstep >>= 16;
-	movl	C(cachewidth),%ebx
-	sarl	$16,%ecx			// sstep >>= 16;
-	imull	%ebx,%edx
-
-	addl	%ecx,%edx			// add in sstep
-								// (tstep >> 16) * cachewidth + (sstep >> 16);
-	movl	tfracf,%ecx
-	movl	%edx,advancetable+4	// advance base in t
-	addl	%ebx,%edx			// ((tstep >> 16) + 1) * cachewidth +
-								//  (sstep >> 16);
-	shll	$16,%ebp			// left-justify sstep fractional part
-	movl	sfracf,%ebx
-	shll	$16,%eax			// left-justify tstep fractional part
-	movl	%edx,advancetable	// advance extra in t
-
-	movl	%eax,tstep
-	movl	%ecx,%edx
-	addl	%eax,%edx
-	sbbl	%ecx,%ecx
-	addl	%ebp,%ebx
-	adcl	advancetable+4(,%ecx,4),%esi
-
-	jmp		*jumptemp			// jump to the number-of-pixels handler
-
-//----------------------------------------
-
-LNoSteps:
-	movb	(%esi),%al		// load first texel in segment
-	subl	$7,%edi			// adjust for hardwired offset
-	jmp		LEndSpan
-
-
-LOnlyOneStep:
-	subl	s,%eax
-	subl	t,%ebx
-	movl	%eax,%ebp
-	movl	%ebx,%edx
-	jmp		LSetEntryvec
-
-//----------------------------------------
-
-.globl	Entry2_8
-Entry2_8:
-	subl	$6,%edi		// adjust for hardwired offsets
-	movb	(%esi),%al
-	jmp		LLEntry2_8
-
-//----------------------------------------
-
-.globl	Entry3_8
-Entry3_8:
-	subl	$5,%edi		// adjust for hardwired offsets
-	addl	%eax,%edx
-	movb	(%esi),%al
-	sbbl	%ecx,%ecx
-	addl	%ebp,%ebx
-	adcl	advancetable+4(,%ecx,4),%esi
-	jmp		LLEntry3_8
-
-//----------------------------------------
-
-.globl	Entry4_8
-Entry4_8:
-	subl	$4,%edi		// adjust for hardwired offsets
-	addl	%eax,%edx
-	movb	(%esi),%al
-	sbbl	%ecx,%ecx
-	addl	%ebp,%ebx
-	adcl	advancetable+4(,%ecx,4),%esi
-	addl	tstep,%edx
-	jmp		LLEntry4_8
-
-//----------------------------------------
-
-.globl	Entry5_8
-Entry5_8:
-	subl	$3,%edi		// adjust for hardwired offsets
-	addl	%eax,%edx
-	movb	(%esi),%al
-	sbbl	%ecx,%ecx
-	addl	%ebp,%ebx
-	adcl	advancetable+4(,%ecx,4),%esi
-	addl	tstep,%edx
-	jmp		LLEntry5_8
-
-//----------------------------------------
-
-.globl	Entry6_8
-Entry6_8:
-	subl	$2,%edi		// adjust for hardwired offsets
-	addl	%eax,%edx
-	movb	(%esi),%al
-	sbbl	%ecx,%ecx
-	addl	%ebp,%ebx
-	adcl	advancetable+4(,%ecx,4),%esi
-	addl	tstep,%edx
-	jmp		LLEntry6_8
-
-//----------------------------------------
-
-.globl	Entry7_8
-Entry7_8:
-	decl	%edi		// adjust for hardwired offsets
-	addl	%eax,%edx
-	movb	(%esi),%al
-	sbbl	%ecx,%ecx
-	addl	%ebp,%ebx
-	adcl	advancetable+4(,%ecx,4),%esi
-	addl	tstep,%edx
-	jmp		LLEntry7_8
-
-//----------------------------------------
-
-.globl	Entry8_8
-Entry8_8:
-	addl	%eax,%edx
-	movb	(%esi),%al
-	sbbl	%ecx,%ecx
-	addl	%ebp,%ebx
-	adcl	advancetable+4(,%ecx,4),%esi
-
-	addl	tstep,%edx
-	sbbl	%ecx,%ecx
-	movb	%al,1(%edi)
-	addl	%ebp,%ebx
-	movb	(%esi),%al
-	adcl	advancetable+4(,%ecx,4),%esi
-	addl	tstep,%edx
-LLEntry7_8:
-	sbbl	%ecx,%ecx
-	movb	%al,2(%edi)
-	addl	%ebp,%ebx
-	movb	(%esi),%al
-	adcl	advancetable+4(,%ecx,4),%esi
-	addl	tstep,%edx
-LLEntry6_8:
-	sbbl	%ecx,%ecx
-	movb	%al,3(%edi)
-	addl	%ebp,%ebx
-	movb	(%esi),%al
-	adcl	advancetable+4(,%ecx,4),%esi
-	addl	tstep,%edx
-LLEntry5_8:
-	sbbl	%ecx,%ecx
-	movb	%al,4(%edi)
-	addl	%ebp,%ebx
-	movb	(%esi),%al
-	adcl	advancetable+4(,%ecx,4),%esi
-	addl	tstep,%edx
-LLEntry4_8:
-	sbbl	%ecx,%ecx
-	movb	%al,5(%edi)
-	addl	%ebp,%ebx
-	movb	(%esi),%al
-	adcl	advancetable+4(,%ecx,4),%esi
-LLEntry3_8:
-	movb	%al,6(%edi)
-	movb	(%esi),%al
-LLEntry2_8:
-
-LEndSpan:
-
-//
-// clear s/z, t/z, 1/z from FP stack
-//
-	fstp %st(0)
-	fstp %st(0)
-	fstp %st(0)
-
-	movl	pspantemp,%ebx				// restore spans pointer
-	movl	espan_t_pnext(%ebx),%ebx	// point to next span
-	testl	%ebx,%ebx			// any more spans?
-	movb	%al,7(%edi)
-	jnz		LSpanLoop			// more spans
-
-	popl	%ebx				// restore register variables
-	popl	%esi
-	popl	%edi
-	popl	%ebp				// restore the caller's stack frame
-	ret
-
-//----------------------------------------------------------------------
-// 8-bpp horizontal span z drawing codefor polygons, with no transparency.
-//
-// Assumes there is at least one span in pzspans, and that every span
-// contains at least one pixel
-//----------------------------------------------------------------------
-
-	.text
-
-// z-clamp on a non-negative gradient span
-LClamp:
-	movl	$0x40000000,%edx
-	xorl	%ebx,%ebx
-	fstp	%st(0)
-	jmp		LZDraw
-
-// z-clamp on a negative gradient span
-LClampNeg:
-	movl	$0x40000000,%edx
-	xorl	%ebx,%ebx
-	fstp	%st(0)
-	jmp		LZDrawNeg
-
-
-#define pzspans	4+16
-
-.globl C(D_DrawZSpans)
-C(D_DrawZSpans):
-	pushl	%ebp				// preserve caller's stack frame
-	pushl	%edi
-	pushl	%esi				// preserve register variables
-	pushl	%ebx
-
-	flds	C(d_zistepu)
-	movl	C(d_zistepu),%eax
-	movl	pzspans(%esp),%esi
-	testl	%eax,%eax
-	jz		LFNegSpan
-
-	fmuls	Float2ToThe31nd
-	fistpl	izistep		// note: we are relying on FP exceptions being turned
-						// off here to avoid range problems
-	movl	izistep,%ebx	// remains loaded for all spans
-
-LFSpanLoop:
-// set up the initial 1/z value
-	fildl	espan_t_v(%esi)
-	fildl	espan_t_u(%esi)
-	movl	espan_t_v(%esi),%ecx
-	movl	C(d_pzbuffer),%edi
-	fmuls	C(d_zistepu)
-	fxch	%st(1)
-	fmuls	C(d_zistepv)
-	fxch	%st(1)
-	fadds	C(d_ziorigin)
-	imull	C(d_zrowbytes),%ecx
-	faddp	%st(0),%st(1)
-
-// clamp if z is nearer than 2 (1/z > 0.5)
-	fcoms	float_point5
-	addl	%ecx,%edi
-	movl	espan_t_u(%esi),%edx
-	addl	%edx,%edx				// word count
-	movl	espan_t_count(%esi),%ecx
-	addl	%edx,%edi				// pdest = &pdestspan[scans->u];
-	pushl	%esi		// preserve spans pointer
-	fnstsw	%ax
-	testb	$0x45,%ah
-	jz		LClamp
-
-	fmuls	Float2ToThe31nd
-	fistpl	izi			// note: we are relying on FP exceptions being turned
-						// off here to avoid problems when the span is closer
-						// than 1/(2**31)
-	movl	izi,%edx
-
-// at this point:
-// %ebx = izistep
-// %ecx = count
-// %edx = izi
-// %edi = pdest
-
-LZDraw:
-
-// do a single pixel up front, if necessary to dword align the destination
-	testl	$2,%edi
-	jz		LFMiddle
-	movl	%edx,%eax
-	addl	%ebx,%edx
-	shrl	$16,%eax
-	decl	%ecx
-	movw	%ax,(%edi)
-	addl	$2,%edi
-
-// do middle a pair of aligned dwords at a time
-LFMiddle:
-	pushl	%ecx
-	shrl	$1,%ecx				// count / 2
-	jz		LFLast				// no aligned dwords to do
-	shrl	$1,%ecx				// (count / 2) / 2
-	jnc		LFMiddleLoop		// even number of aligned dwords to do
-
-	movl	%edx,%eax
-	addl	%ebx,%edx
-	shrl	$16,%eax
-	movl	%edx,%esi
-	addl	%ebx,%edx
-	andl	$0xFFFF0000,%esi
-	orl		%esi,%eax
-	movl	%eax,(%edi)
-	addl	$4,%edi
-	andl	%ecx,%ecx
-	jz		LFLast
-
-LFMiddleLoop:
-	movl	%edx,%eax
-	addl	%ebx,%edx
-	shrl	$16,%eax
-	movl	%edx,%esi
-	addl	%ebx,%edx
-	andl	$0xFFFF0000,%esi
-	orl		%esi,%eax
-	movl	%edx,%ebp
-	movl	%eax,(%edi)
-	addl	%ebx,%edx
-	shrl	$16,%ebp
-	movl	%edx,%esi
-	addl	%ebx,%edx
-	andl	$0xFFFF0000,%esi
-	orl		%esi,%ebp
-	movl	%ebp,4(%edi)	// FIXME: eliminate register contention
-	addl	$8,%edi
-
-	decl	%ecx
-	jnz		LFMiddleLoop
-
-LFLast:
-	popl	%ecx			// retrieve count
-	popl	%esi			// retrieve span pointer
-
-// do the last, unaligned pixel, if there is one
-	andl	$1,%ecx			// is there an odd pixel left to do?
-	jz		LFSpanDone		// no
-	shrl	$16,%edx
-	movw	%dx,(%edi)		// do the final pixel's z
-
-LFSpanDone:
-	movl	espan_t_pnext(%esi),%esi
-	testl	%esi,%esi
-	jnz		LFSpanLoop
-
-	jmp		LFDone
-
-LFNegSpan:
-	fmuls	FloatMinus2ToThe31nd
-	fistpl	izistep		// note: we are relying on FP exceptions being turned
-						// off here to avoid range problems
-	movl	izistep,%ebx	// remains loaded for all spans
-
-LFNegSpanLoop:
-// set up the initial 1/z value
-	fildl	espan_t_v(%esi)
-	fildl	espan_t_u(%esi)
-	movl	espan_t_v(%esi),%ecx
-	movl	C(d_pzbuffer),%edi
-	fmuls	C(d_zistepu)
-	fxch	%st(1)
-	fmuls	C(d_zistepv)
-	fxch	%st(1)
-	fadds	C(d_ziorigin)
-	imull	C(d_zrowbytes),%ecx
-	faddp	%st(0),%st(1)
-
-// clamp if z is nearer than 2 (1/z > 0.5)
-	fcoms	float_point5
-	addl	%ecx,%edi
-	movl	espan_t_u(%esi),%edx
-	addl	%edx,%edx				// word count
-	movl	espan_t_count(%esi),%ecx
-	addl	%edx,%edi				// pdest = &pdestspan[scans->u];
-	pushl	%esi		// preserve spans pointer
-	fnstsw	%ax
-	testb	$0x45,%ah
-	jz		LClampNeg
-
-	fmuls	Float2ToThe31nd
-	fistpl	izi			// note: we are relying on FP exceptions being turned
-						// off here to avoid problems when the span is closer
-						// than 1/(2**31)
-	movl	izi,%edx
-
-// at this point:
-// %ebx = izistep
-// %ecx = count
-// %edx = izi
-// %edi = pdest
-
-LZDrawNeg:
-
-// do a single pixel up front, if necessary to dword align the destination
-	testl	$2,%edi
-	jz		LFNegMiddle
-	movl	%edx,%eax
-	subl	%ebx,%edx
-	shrl	$16,%eax
-	decl	%ecx
-	movw	%ax,(%edi)
-	addl	$2,%edi
-
-// do middle a pair of aligned dwords at a time
-LFNegMiddle:
-	pushl	%ecx
-	shrl	$1,%ecx				// count / 2
-	jz		LFNegLast			// no aligned dwords to do
-	shrl	$1,%ecx				// (count / 2) / 2
-	jnc		LFNegMiddleLoop		// even number of aligned dwords to do
-
-	movl	%edx,%eax
-	subl	%ebx,%edx
-	shrl	$16,%eax
-	movl	%edx,%esi
-	subl	%ebx,%edx
-	andl	$0xFFFF0000,%esi
-	orl		%esi,%eax
-	movl	%eax,(%edi)
-	addl	$4,%edi
-	andl	%ecx,%ecx
-	jz		LFNegLast
-
-LFNegMiddleLoop:
-	movl	%edx,%eax
-	subl	%ebx,%edx
-	shrl	$16,%eax
-	movl	%edx,%esi
-	subl	%ebx,%edx
-	andl	$0xFFFF0000,%esi
-	orl		%esi,%eax
-	movl	%edx,%ebp
-	movl	%eax,(%edi)
-	subl	%ebx,%edx
-	shrl	$16,%ebp
-	movl	%edx,%esi
-	subl	%ebx,%edx
-	andl	$0xFFFF0000,%esi
-	orl		%esi,%ebp
-	movl	%ebp,4(%edi)	// FIXME: eliminate register contention
-	addl	$8,%edi
-
-	decl	%ecx
-	jnz		LFNegMiddleLoop
-
-LFNegLast:
-	popl	%ecx			// retrieve count
-	popl	%esi			// retrieve span pointer
-
-// do the last, unaligned pixel, if there is one
-	andl	$1,%ecx			// is there an odd pixel left to do?
-	jz		LFNegSpanDone	// no
-	shrl	$16,%edx
-	movw	%dx,(%edi)		// do the final pixel's z
-
-LFNegSpanDone:
-	movl	espan_t_pnext(%esi),%esi
-	testl	%esi,%esi
-	jnz		LFNegSpanLoop
-
-LFDone:
-	popl	%ebx				// restore register variables
-	popl	%esi
-	popl	%edi
-	popl	%ebp				// restore the caller's stack frame
-	ret
-
-#endif	// id386
diff -ruN WinQuake/d_draw16.S sdlquake-1.0.9/d_draw16.S
--- WinQuake/d_draw16.S	Wed Dec 31 16:00:00 1969
+++ sdlquake-1.0.9/d_draw16.S	Sat Dec 25 03:38:02 1999
@@ -0,0 +1,974 @@
+/*
+Copyright (C) 1996-1997 Id Software, Inc.
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation; either version 2
+of the License, or (at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
+
+See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+//
+// d_draw16.s
+// x86 assembly-language horizontal 8-bpp span-drawing code, with 16-pixel
+// subdivision.
+//
+
+#include "asm_i386.h"
+#include "quakeasm.h"
+#include "asm_draw.h"
+#include "d_ifacea.h"
+
+#if	id386
+
+//----------------------------------------------------------------------
+// 8-bpp horizontal span drawing code for polygons, with no transparency and
+// 16-pixel subdivision.
+//
+// Assumes there is at least one span in pspans, and that every span
+// contains at least one pixel
+//----------------------------------------------------------------------
+
+	.data
+
+	.text
+
+// out-of-line, rarely-needed clamping code
+
+LClampHigh0:
+	movl	C(bbextents),%esi
+	jmp		LClampReentry0
+LClampHighOrLow0:
+	jg		LClampHigh0
+	xorl	%esi,%esi
+	jmp		LClampReentry0
+
+LClampHigh1:
+	movl	C(bbextentt),%edx
+	jmp		LClampReentry1
+LClampHighOrLow1:
+	jg		LClampHigh1
+	xorl	%edx,%edx
+	jmp		LClampReentry1
+
+LClampLow2:
+	movl	$4096,%ebp
+	jmp		LClampReentry2
+LClampHigh2:
+	movl	C(bbextents),%ebp
+	jmp		LClampReentry2
+
+LClampLow3:
+	movl	$4096,%ecx
+	jmp		LClampReentry3
+LClampHigh3:
+	movl	C(bbextentt),%ecx
+	jmp		LClampReentry3
+
+LClampLow4:
+	movl	$4096,%eax
+	jmp		LClampReentry4
+LClampHigh4:
+	movl	C(bbextents),%eax
+	jmp		LClampReentry4
+
+LClampLow5:
+	movl	$4096,%ebx
+	jmp		LClampReentry5
+LClampHigh5:
+	movl	C(bbextentt),%ebx
+	jmp		LClampReentry5
+
+
+#define pspans	4+16
+
+	.align 4
+.globl C(D_DrawSpans16)
+C(D_DrawSpans16):
+	pushl	%ebp				// preserve caller's stack frame
+	pushl	%edi
+	pushl	%esi				// preserve register variables
+	pushl	%ebx
+
+//
+// set up scaled-by-16 steps, for 16-long segments; also set up cacheblock
+// and span list pointers
+//
+// TODO: any overlap from rearranging?
+	flds	C(d_sdivzstepu)
+	fmuls	fp_16
+	movl	C(cacheblock),%edx
+	flds	C(d_tdivzstepu)
+	fmuls	fp_16
+	movl	pspans(%esp),%ebx	// point to the first span descriptor
+	flds	C(d_zistepu)
+	fmuls	fp_16
+	movl	%edx,pbase			// pbase = cacheblock
+	fstps	zi16stepu
+	fstps	tdivz16stepu
+	fstps	sdivz16stepu
+
+LSpanLoop:
+//
+// set up the initial s/z, t/z, and 1/z on the FP stack, and generate the
+// initial s and t values
+//
+// FIXME: pipeline FILD?
+	fildl	espan_t_v(%ebx)
+	fildl	espan_t_u(%ebx)
+
+	fld		%st(1)			// dv | du | dv
+	fmuls	C(d_sdivzstepv)	// dv*d_sdivzstepv | du | dv
+	fld		%st(1)			// du | dv*d_sdivzstepv | du | dv
+	fmuls	C(d_sdivzstepu)	// du*d_sdivzstepu | dv*d_sdivzstepv | du | dv
+	fld		%st(2)			// du | du*d_sdivzstepu | dv*d_sdivzstepv | du | dv
+	fmuls	C(d_tdivzstepu)	// du*d_tdivzstepu | du*d_sdivzstepu |
+							//  dv*d_sdivzstepv | du | dv
+	fxch	%st(1)			// du*d_sdivzstepu | du*d_tdivzstepu |
+							//  dv*d_sdivzstepv | du | dv
+	faddp	%st(0),%st(2)	// du*d_tdivzstepu |
+							//  du*d_sdivzstepu + dv*d_sdivzstepv | du | dv
+	fxch	%st(1)			// du*d_sdivzstepu + dv*d_sdivzstepv |
+							//  du*d_tdivzstepu | du | dv
+	fld		%st(3)			// dv | du*d_sdivzstepu + dv*d_sdivzstepv |
+							//  du*d_tdivzstepu | du | dv
+	fmuls	C(d_tdivzstepv)	// dv*d_tdivzstepv |
+							//  du*d_sdivzstepu + dv*d_sdivzstepv |
+							//  du*d_tdivzstepu | du | dv
+	fxch	%st(1)			// du*d_sdivzstepu + dv*d_sdivzstepv |
+							//  dv*d_tdivzstepv | du*d_tdivzstepu | du | dv
+	fadds	C(d_sdivzorigin)	// sdivz = d_sdivzorigin + dv*d_sdivzstepv +
+							//  du*d_sdivzstepu; stays in %st(2) at end
+	fxch	%st(4)			// dv | dv*d_tdivzstepv | du*d_tdivzstepu | du |
+							//  s/z
+	fmuls	C(d_zistepv)		// dv*d_zistepv | dv*d_tdivzstepv |
+							//  du*d_tdivzstepu | du | s/z
+	fxch	%st(1)			// dv*d_tdivzstepv |  dv*d_zistepv |
+							//  du*d_tdivzstepu | du | s/z
+	faddp	%st(0),%st(2)	// dv*d_zistepv |
+							//  dv*d_tdivzstepv + du*d_tdivzstepu | du | s/z
+	fxch	%st(2)			// du | dv*d_tdivzstepv + du*d_tdivzstepu |
+							//  dv*d_zistepv | s/z
+	fmuls	C(d_zistepu)		// du*d_zistepu |
+							//  dv*d_tdivzstepv + du*d_tdivzstepu |
+							//  dv*d_zistepv | s/z
+	fxch	%st(1)			// dv*d_tdivzstepv + du*d_tdivzstepu |
+							//  du*d_zistepu | dv*d_zistepv | s/z
+	fadds	C(d_tdivzorigin)	// tdivz = d_tdivzorigin + dv*d_tdivzstepv +
+							//  du*d_tdivzstepu; stays in %st(1) at end
+	fxch	%st(2)			// dv*d_zistepv | du*d_zistepu | t/z | s/z
+	faddp	%st(0),%st(1)	// dv*d_zistepv + du*d_zistepu | t/z | s/z
+
+	flds	fp_64k			// fp_64k | dv*d_zistepv + du*d_zistepu | t/z | s/z
+	fxch	%st(1)			// dv*d_zistepv + du*d_zistepu | fp_64k | t/z | s/z
+	fadds	C(d_ziorigin)		// zi = d_ziorigin + dv*d_zistepv +
+							//  du*d_zistepu; stays in %st(0) at end
+							// 1/z | fp_64k | t/z | s/z
+//
+// calculate and clamp s & t
+//
+	fdivr	%st(0),%st(1)	// 1/z | z*64k | t/z | s/z
+
+//
+// point %edi to the first pixel in the span
+//
+	movl	C(d_viewbuffer),%ecx
+	movl	espan_t_v(%ebx),%eax
+	movl	%ebx,pspantemp	// preserve spans pointer
+
+	movl	C(tadjust),%edx
+	movl	C(sadjust),%esi
+	movl	C(d_scantable)(,%eax,4),%edi	// v * screenwidth
+	addl	%ecx,%edi
+	movl	espan_t_u(%ebx),%ecx
+	addl	%ecx,%edi				// pdest = &pdestspan[scans->u];
+	movl	espan_t_count(%ebx),%ecx
+
+//
+// now start the FDIV for the end of the span
+//
+	cmpl	$16,%ecx
+	ja		LSetupNotLast1
+
+	decl	%ecx
+	jz		LCleanup1		// if only one pixel, no need to start an FDIV
+	movl	%ecx,spancountminus1
+
+// finish up the s and t calcs
+	fxch	%st(1)			// z*64k | 1/z | t/z | s/z
+
+	fld		%st(0)			// z*64k | z*64k | 1/z | t/z | s/z
+	fmul	%st(4),%st(0)	// s | z*64k | 1/z | t/z | s/z
+	fxch	%st(1)			// z*64k | s | 1/z | t/z | s/z
+	fmul	%st(3),%st(0)	// t | s | 1/z | t/z | s/z
+	fxch	%st(1)			// s | t | 1/z | t/z | s/z
+	fistpl	s				// 1/z | t | t/z | s/z
+	fistpl	t				// 1/z | t/z | s/z
+
+	fildl	spancountminus1
+
+	flds	C(d_tdivzstepu)	// C(d_tdivzstepu) | spancountminus1
+	flds	C(d_zistepu)		// C(d_zistepu) | C(d_tdivzstepu) | spancountminus1
+	fmul	%st(2),%st(0)	// C(d_zistepu)*scm1 | C(d_tdivzstepu) | scm1
+	fxch	%st(1)			// C(d_tdivzstepu) | C(d_zistepu)*scm1 | scm1
+	fmul	%st(2),%st(0)	// C(d_tdivzstepu)*scm1 | C(d_zistepu)*scm1 | scm1
+	fxch	%st(2)			// scm1 | C(d_zistepu)*scm1 | C(d_tdivzstepu)*scm1
+	fmuls	C(d_sdivzstepu)	// C(d_sdivzstepu)*scm1 | C(d_zistepu)*scm1 |
+							//  C(d_tdivzstepu)*scm1
+	fxch	%st(1)			// C(d_zistepu)*scm1 | C(d_sdivzstepu)*scm1 |
+							//  C(d_tdivzstepu)*scm1
+	faddp	%st(0),%st(3)	// C(d_sdivzstepu)*scm1 | C(d_tdivzstepu)*scm1
+	fxch	%st(1)			// C(d_tdivzstepu)*scm1 | C(d_sdivzstepu)*scm1
+	faddp	%st(0),%st(3)	// C(d_sdivzstepu)*scm1
+	faddp	%st(0),%st(3)
+
+	flds	fp_64k
+	fdiv	%st(1),%st(0)	// this is what we've gone to all this trouble to
+							//  overlap
+	jmp		LFDIVInFlight1
+
+LCleanup1:
+// finish up the s and t calcs
+	fxch	%st(1)			// z*64k | 1/z | t/z | s/z
+
+	fld		%st(0)			// z*64k | z*64k | 1/z | t/z | s/z
+	fmul	%st(4),%st(0)	// s | z*64k | 1/z | t/z | s/z
+	fxch	%st(1)			// z*64k | s | 1/z | t/z | s/z
+	fmul	%st(3),%st(0)	// t | s | 1/z | t/z | s/z
+	fxch	%st(1)			// s | t | 1/z | t/z | s/z
+	fistpl	s				// 1/z | t | t/z | s/z
+	fistpl	t				// 1/z | t/z | s/z
+	jmp		LFDIVInFlight1
+
+	.align	4
+LSetupNotLast1:
+// finish up the s and t calcs
+	fxch	%st(1)			// z*64k | 1/z | t/z | s/z
+
+	fld		%st(0)			// z*64k | z*64k | 1/z | t/z | s/z
+	fmul	%st(4),%st(0)	// s | z*64k | 1/z | t/z | s/z
+	fxch	%st(1)			// z*64k | s | 1/z | t/z | s/z
+	fmul	%st(3),%st(0)	// t | s | 1/z | t/z | s/z
+	fxch	%st(1)			// s | t | 1/z | t/z | s/z
+	fistpl	s				// 1/z | t | t/z | s/z
+	fistpl	t				// 1/z | t/z | s/z
+
+	fadds	zi16stepu
+	fxch	%st(2)
+	fadds	sdivz16stepu
+	fxch	%st(2)
+	flds	tdivz16stepu
+	faddp	%st(0),%st(2)
+	flds	fp_64k
+	fdiv	%st(1),%st(0)	// z = 1/1/z
+							// this is what we've gone to all this trouble to
+							//  overlap
+LFDIVInFlight1:
+
+	addl	s,%esi
+	addl	t,%edx
+	movl	C(bbextents),%ebx
+	movl	C(bbextentt),%ebp
+	cmpl	%ebx,%esi
+	ja		LClampHighOrLow0
+LClampReentry0:
+	movl	%esi,s
+	movl	pbase,%ebx
+	shll	$16,%esi
+	cmpl	%ebp,%edx
+	movl	%esi,sfracf
+	ja		LClampHighOrLow1
+LClampReentry1:
+	movl	%edx,t
+	movl	s,%esi					// sfrac = scans->sfrac;
+	shll	$16,%edx
+	movl	t,%eax					// tfrac = scans->tfrac;
+	sarl	$16,%esi
+	movl	%edx,tfracf
+
+//
+// calculate the texture starting address
+//
+	sarl	$16,%eax
+	movl	C(cachewidth),%edx
+	imull	%edx,%eax				// (tfrac >> 16) * cachewidth
+	addl	%ebx,%esi
+	addl	%eax,%esi				// psource = pbase + (sfrac >> 16) +
+									//           ((tfrac >> 16) * cachewidth);
+//
+// determine whether last span or not
+//
+	cmpl	$16,%ecx
+	jna		LLastSegment
+
+//
+// not the last segment; do full 16-wide segment
+//
+LNotLastSegment:
+
+//
+// advance s/z, t/z, and 1/z, and calculate s & t at end of span and steps to
+// get there
+//
+
+// pick up after the FDIV that was left in flight previously
+
+	fld		%st(0)			// duplicate it
+	fmul	%st(4),%st(0)	// s = s/z * z
+	fxch	%st(1)
+	fmul	%st(3),%st(0)	// t = t/z * z
+	fxch	%st(1)
+	fistpl	snext
+	fistpl	tnext
+	movl	snext,%eax
+	movl	tnext,%edx
+
+	movb	(%esi),%bl	// get first source texel
+	subl	$16,%ecx		// count off this segments' pixels
+	movl	C(sadjust),%ebp
+	movl	%ecx,counttemp	// remember count of remaining pixels
+
+	movl	C(tadjust),%ecx
+	movb	%bl,(%edi)	// store first dest pixel
+
+	addl	%eax,%ebp
+	addl	%edx,%ecx
+
+	movl	C(bbextents),%eax
+	movl	C(bbextentt),%edx
+
+	cmpl	$4096,%ebp
+	jl		LClampLow2
+	cmpl	%eax,%ebp
+	ja		LClampHigh2
+LClampReentry2:
+
+	cmpl	$4096,%ecx
+	jl		LClampLow3
+	cmpl	%edx,%ecx
+	ja		LClampHigh3
+LClampReentry3:
+
+	movl	%ebp,snext
+	movl	%ecx,tnext
+
+	subl	s,%ebp
+	subl	t,%ecx
+	
+//
+// set up advancetable
+//
+	movl	%ecx,%eax
+	movl	%ebp,%edx
+	sarl	$20,%eax			// tstep >>= 16;
+	jz		LZero
+	sarl	$20,%edx			// sstep >>= 16;
+	movl	C(cachewidth),%ebx
+	imull	%ebx,%eax
+	jmp		LSetUp1
+
+LZero:
+	sarl	$20,%edx			// sstep >>= 16;
+	movl	C(cachewidth),%ebx
+
+LSetUp1:
+
+	addl	%edx,%eax			// add in sstep
+								// (tstep >> 16) * cachewidth + (sstep >> 16);
+	movl	tfracf,%edx
+	movl	%eax,advancetable+4	// advance base in t
+	addl	%ebx,%eax			// ((tstep >> 16) + 1) * cachewidth +
+								//  (sstep >> 16);
+	shll	$12,%ebp			// left-justify sstep fractional part
+	movl	sfracf,%ebx
+	shll	$12,%ecx			// left-justify tstep fractional part
+	movl	%eax,advancetable	// advance extra in t
+
+	movl	%ecx,tstep
+	addl	%ecx,%edx			// advance tfrac fractional part by tstep frac
+
+	sbbl	%ecx,%ecx			// turn tstep carry into -1 (0 if none)
+	addl	%ebp,%ebx			// advance sfrac fractional part by sstep frac
+	adcl	advancetable+4(,%ecx,4),%esi	// point to next source texel
+
+	addl	tstep,%edx
+	sbbl	%ecx,%ecx
+	movb	(%esi),%al
+	addl	%ebp,%ebx
+	movb	%al,1(%edi)
+	adcl	advancetable+4(,%ecx,4),%esi
+
+	addl	tstep,%edx
+	sbbl	%ecx,%ecx
+	addl	%ebp,%ebx
+	movb	(%esi),%al
+	adcl	advancetable+4(,%ecx,4),%esi
+
+	addl	tstep,%edx
+	sbbl	%ecx,%ecx
+	movb	%al,2(%edi)
+	addl	%ebp,%ebx
+	movb	(%esi),%al
+	adcl	advancetable+4(,%ecx,4),%esi
+
+	addl	tstep,%edx
+	sbbl	%ecx,%ecx
+	movb	%al,3(%edi)
+	addl	%ebp,%ebx
+	movb	(%esi),%al
+	adcl	advancetable+4(,%ecx,4),%esi
+
+	addl	tstep,%edx
+	sbbl	%ecx,%ecx
+	movb	%al,4(%edi)
+	addl	%ebp,%ebx
+	movb	(%esi),%al
+	adcl	advancetable+4(,%ecx,4),%esi
+
+	addl	tstep,%edx
+	sbbl	%ecx,%ecx
+	movb	%al,5(%edi)
+	addl	%ebp,%ebx
+	movb	(%esi),%al
+	adcl	advancetable+4(,%ecx,4),%esi
+
+	addl	tstep,%edx
+	sbbl	%ecx,%ecx
+	movb	%al,6(%edi)
+	addl	%ebp,%ebx
+	movb	(%esi),%al
+	adcl	advancetable+4(,%ecx,4),%esi
+
+	addl	tstep,%edx
+	sbbl	%ecx,%ecx
+	movb	%al,7(%edi)
+	addl	%ebp,%ebx
+	movb	(%esi),%al
+	adcl	advancetable+4(,%ecx,4),%esi
+
+
+//
+// start FDIV for end of next segment in flight, so it can overlap
+//
+	movl	counttemp,%ecx
+	cmpl	$16,%ecx			// more than one segment after this?
+	ja		LSetupNotLast2	// yes
+
+	decl	%ecx
+	jz		LFDIVInFlight2	// if only one pixel, no need to start an FDIV
+	movl	%ecx,spancountminus1
+	fildl	spancountminus1
+
+	flds	C(d_zistepu)		// C(d_zistepu) | spancountminus1
+	fmul	%st(1),%st(0)	// C(d_zistepu)*scm1 | scm1
+	flds	C(d_tdivzstepu)	// C(d_tdivzstepu) | C(d_zistepu)*scm1 | scm1
+	fmul	%st(2),%st(0)	// C(d_tdivzstepu)*scm1 | C(d_zistepu)*scm1 | scm1
+	fxch	%st(1)			// C(d_zistepu)*scm1 | C(d_tdivzstepu)*scm1 | scm1
+	faddp	%st(0),%st(3)	// C(d_tdivzstepu)*scm1 | scm1
+	fxch	%st(1)			// scm1 | C(d_tdivzstepu)*scm1
+	fmuls	C(d_sdivzstepu)	// C(d_sdivzstepu)*scm1 | C(d_tdivzstepu)*scm1
+	fxch	%st(1)			// C(d_tdivzstepu)*scm1 | C(d_sdivzstepu)*scm1
+	faddp	%st(0),%st(3)	// C(d_sdivzstepu)*scm1
+	flds	fp_64k			// 64k | C(d_sdivzstepu)*scm1
+	fxch	%st(1)			// C(d_sdivzstepu)*scm1 | 64k
+	faddp	%st(0),%st(4)	// 64k
+
+	fdiv	%st(1),%st(0)	// this is what we've gone to all this trouble to
+							//  overlap
+	jmp		LFDIVInFlight2
+
+	.align	4
+LSetupNotLast2:
+	fadds	zi16stepu
+	fxch	%st(2)
+	fadds	sdivz16stepu
+	fxch	%st(2)
+	flds	tdivz16stepu
+	faddp	%st(0),%st(2)
+	flds	fp_64k
+	fdiv	%st(1),%st(0)	// z = 1/1/z
+							// this is what we've gone to all this trouble to
+							//  overlap
+LFDIVInFlight2:
+	movl	%ecx,counttemp
+
+	addl	tstep,%edx
+	sbbl	%ecx,%ecx
+	movb	%al,8(%edi)
+	addl	%ebp,%ebx
+	movb	(%esi),%al
+	adcl	advancetable+4(,%ecx,4),%esi
+
+	addl	tstep,%edx
+	sbbl	%ecx,%ecx
+	movb	%al,9(%edi)
+	addl	%ebp,%ebx
+	movb	(%esi),%al
+	adcl	advancetable+4(,%ecx,4),%esi
+
+	addl	tstep,%edx
+	sbbl	%ecx,%ecx
+	movb	%al,10(%edi)
+	addl	%ebp,%ebx
+	movb	(%esi),%al
+	adcl	advancetable+4(,%ecx,4),%esi
+
+	addl	tstep,%edx
+	sbbl	%ecx,%ecx
+	movb	%al,11(%edi)
+	addl	%ebp,%ebx
+	movb	(%esi),%al
+	adcl	advancetable+4(,%ecx,4),%esi
+
+	addl	tstep,%edx
+	sbbl	%ecx,%ecx
+	movb	%al,12(%edi)
+	addl	%ebp,%ebx
+	movb	(%esi),%al
+	adcl	advancetable+4(,%ecx,4),%esi
+
+	addl	tstep,%edx
+	sbbl	%ecx,%ecx
+	movb	%al,13(%edi)
+	addl	%ebp,%ebx
+	movb	(%esi),%al
+	adcl	advancetable+4(,%ecx,4),%esi
+
+	addl	tstep,%edx
+	sbbl	%ecx,%ecx
+	movb	%al,14(%edi)
+	addl	%ebp,%ebx
+	movb	(%esi),%al
+	adcl	advancetable+4(,%ecx,4),%esi
+
+	addl	$16,%edi
+	movl	%edx,tfracf
+	movl	snext,%edx
+	movl	%ebx,sfracf
+	movl	tnext,%ebx
+	movl	%edx,s
+	movl	%ebx,t
+
+	movl	counttemp,%ecx		// retrieve count
+
+//
+// determine whether last span or not
+//
+	cmpl	$16,%ecx				// are there multiple segments remaining?
+	movb	%al,-1(%edi)
+	ja		LNotLastSegment		// yes
+
+//
+// last segment of scan
+//
+LLastSegment:
+
+//
+// advance s/z, t/z, and 1/z, and calculate s & t at end of span and steps to
+// get there. The number of pixels left is variable, and we want to land on the
+// last pixel, not step one past it, so we can't run into arithmetic problems
+//
+	testl	%ecx,%ecx
+	jz		LNoSteps		// just draw the last pixel and we're done
+
+// pick up after the FDIV that was left in flight previously
+
+
+	fld		%st(0)			// duplicate it
+	fmul	%st(4),%st(0)	// s = s/z * z
+	fxch	%st(1)
+	fmul	%st(3),%st(0)	// t = t/z * z
+	fxch	%st(1)
+	fistpl	snext
+	fistpl	tnext
+
+	movb	(%esi),%al		// load first texel in segment
+	movl	C(tadjust),%ebx
+	movb	%al,(%edi)		// store first pixel in segment
+	movl	C(sadjust),%eax
+
+	addl	snext,%eax
+	addl	tnext,%ebx
+
+	movl	C(bbextents),%ebp
+	movl	C(bbextentt),%edx
+
+	cmpl	$4096,%eax
+	jl		LClampLow4
+	cmpl	%ebp,%eax
+	ja		LClampHigh4
+LClampReentry4:
+	movl	%eax,snext
+
+	cmpl	$4096,%ebx
+	jl		LClampLow5
+	cmpl	%edx,%ebx
+	ja		LClampHigh5
+LClampReentry5:
+
+	cmpl	$1,%ecx			// don't bother 
+	je		LOnlyOneStep	// if two pixels in segment, there's only one step,
+							//  of the segment length
+	subl	s,%eax
+	subl	t,%ebx
+
+	addl	%eax,%eax		// convert to 15.17 format so multiply by 1.31
+	addl	%ebx,%ebx		//  reciprocal yields 16.48
+
+	imull	reciprocal_table_16-8(,%ecx,4)	// sstep = (snext - s) /
+											//  (spancount-1)
+	movl	%edx,%ebp
+
+	movl	%ebx,%eax
+	imull	reciprocal_table_16-8(,%ecx,4)	// tstep = (tnext - t) /
+											//  (spancount-1)
+LSetEntryvec:
+//
+// set up advancetable
+//
+	movl	entryvec_table_16(,%ecx,4),%ebx
+	movl	%edx,%eax
+	movl	%ebx,jumptemp		// entry point into code for RET later
+	movl	%ebp,%ecx
+	sarl	$16,%edx			// tstep >>= 16;
+	movl	C(cachewidth),%ebx
+	sarl	$16,%ecx			// sstep >>= 16;
+	imull	%ebx,%edx
+
+	addl	%ecx,%edx			// add in sstep
+								// (tstep >> 16) * cachewidth + (sstep >> 16);
+	movl	tfracf,%ecx
+	movl	%edx,advancetable+4	// advance base in t
+	addl	%ebx,%edx			// ((tstep >> 16) + 1) * cachewidth +
+								//  (sstep >> 16);
+	shll	$16,%ebp			// left-justify sstep fractional part
+	movl	sfracf,%ebx
+	shll	$16,%eax			// left-justify tstep fractional part
+	movl	%edx,advancetable	// advance extra in t
+
+	movl	%eax,tstep
+	movl	%ecx,%edx
+	addl	%eax,%edx
+	sbbl	%ecx,%ecx
+	addl	%ebp,%ebx
+	adcl	advancetable+4(,%ecx,4),%esi
+
+	jmp		*jumptemp			// jump to the number-of-pixels handler
+
+//----------------------------------------
+
+LNoSteps:
+	movb	(%esi),%al		// load first texel in segment
+	subl	$15,%edi			// adjust for hardwired offset
+	jmp		LEndSpan
+
+
+LOnlyOneStep:
+	subl	s,%eax
+	subl	t,%ebx
+	movl	%eax,%ebp
+	movl	%ebx,%edx
+	jmp		LSetEntryvec
+
+//----------------------------------------
+
+.globl	Entry2_16, Entry3_16, Entry4_16, Entry5_16
+.globl	Entry6_16, Entry7_16, Entry8_16, Entry9_16
+.globl	Entry10_16, Entry11_16, Entry12_16, Entry13_16
+.globl	Entry14_16, Entry15_16, Entry16_16
+
+Entry2_16:
+	subl	$14,%edi		// adjust for hardwired offsets
+	movb	(%esi),%al
+	jmp		LEntry2_16
+
+//----------------------------------------
+
+Entry3_16:
+	subl	$13,%edi		// adjust for hardwired offsets
+	addl	%eax,%edx
+	movb	(%esi),%al
+	sbbl	%ecx,%ecx
+	addl	%ebp,%ebx
+	adcl	advancetable+4(,%ecx,4),%esi
+	jmp		LEntry3_16
+
+//----------------------------------------
+
+Entry4_16:
+	subl	$12,%edi		// adjust for hardwired offsets
+	addl	%eax,%edx
+	movb	(%esi),%al
+	sbbl	%ecx,%ecx
+	addl	%ebp,%ebx
+	adcl	advancetable+4(,%ecx,4),%esi
+	addl	tstep,%edx
+	jmp		LEntry4_16
+
+//----------------------------------------
+
+Entry5_16:
+	subl	$11,%edi		// adjust for hardwired offsets
+	addl	%eax,%edx
+	movb	(%esi),%al
+	sbbl	%ecx,%ecx
+	addl	%ebp,%ebx
+	adcl	advancetable+4(,%ecx,4),%esi
+	addl	tstep,%edx
+	jmp		LEntry5_16
+
+//----------------------------------------
+
+Entry6_16:
+	subl	$10,%edi		// adjust for hardwired offsets
+	addl	%eax,%edx
+	movb	(%esi),%al
+	sbbl	%ecx,%ecx
+	addl	%ebp,%ebx
+	adcl	advancetable+4(,%ecx,4),%esi
+	addl	tstep,%edx
+	jmp		LEntry6_16
+
+//----------------------------------------
+
+Entry7_16:
+	subl	$9,%edi		// adjust for hardwired offsets
+	addl	%eax,%edx
+	movb	(%esi),%al
+	sbbl	%ecx,%ecx
+	addl	%ebp,%ebx
+	adcl	advancetable+4(,%ecx,4),%esi
+	addl	tstep,%edx
+	jmp		LEntry7_16
+
+//----------------------------------------
+
+Entry8_16:
+	subl	$8,%edi		// adjust for hardwired offsets
+	addl	%eax,%edx
+	movb	(%esi),%al
+	sbbl	%ecx,%ecx
+	addl	%ebp,%ebx
+	adcl	advancetable+4(,%ecx,4),%esi
+	addl	tstep,%edx
+	jmp		LEntry8_16
+
+//----------------------------------------
+
+Entry9_16:
+	subl	$7,%edi		// adjust for hardwired offsets
+	addl	%eax,%edx
+	movb	(%esi),%al
+	sbbl	%ecx,%ecx
+	addl	%ebp,%ebx
+	adcl	advancetable+4(,%ecx,4),%esi
+	addl	tstep,%edx
+	jmp		LEntry9_16
+
+//----------------------------------------
+
+Entry10_16:
+	subl	$6,%edi		// adjust for hardwired offsets
+	addl	%eax,%edx
+	movb	(%esi),%al
+	sbbl	%ecx,%ecx
+	addl	%ebp,%ebx
+	adcl	advancetable+4(,%ecx,4),%esi
+	addl	tstep,%edx
+	jmp		LEntry10_16
+
+//----------------------------------------
+
+Entry11_16:
+	subl	$5,%edi		// adjust for hardwired offsets
+	addl	%eax,%edx
+	movb	(%esi),%al
+	sbbl	%ecx,%ecx
+	addl	%ebp,%ebx
+	adcl	advancetable+4(,%ecx,4),%esi
+	addl	tstep,%edx
+	jmp		LEntry11_16
+
+//----------------------------------------
+
+Entry12_16:
+	subl	$4,%edi		// adjust for hardwired offsets
+	addl	%eax,%edx
+	movb	(%esi),%al
+	sbbl	%ecx,%ecx
+	addl	%ebp,%ebx
+	adcl	advancetable+4(,%ecx,4),%esi
+	addl	tstep,%edx
+	jmp		LEntry12_16
+
+//----------------------------------------
+
+Entry13_16:
+	subl	$3,%edi		// adjust for hardwired offsets
+	addl	%eax,%edx
+	movb	(%esi),%al
+	sbbl	%ecx,%ecx
+	addl	%ebp,%ebx
+	adcl	advancetable+4(,%ecx,4),%esi
+	addl	tstep,%edx
+	jmp		LEntry13_16
+
+//----------------------------------------
+
+Entry14_16:
+	subl	$2,%edi		// adjust for hardwired offsets
+	addl	%eax,%edx
+	movb	(%esi),%al
+	sbbl	%ecx,%ecx
+	addl	%ebp,%ebx
+	adcl	advancetable+4(,%ecx,4),%esi
+	addl	tstep,%edx
+	jmp		LEntry14_16
+
+//----------------------------------------
+
+Entry15_16:
+	decl	%edi		// adjust for hardwired offsets
+	addl	%eax,%edx
+	movb	(%esi),%al
+	sbbl	%ecx,%ecx
+	addl	%ebp,%ebx
+	adcl	advancetable+4(,%ecx,4),%esi
+	addl	tstep,%edx
+	jmp		LEntry15_16
+
+//----------------------------------------
+
+Entry16_16:
+	addl	%eax,%edx
+	movb	(%esi),%al
+	sbbl	%ecx,%ecx
+	addl	%ebp,%ebx
+	adcl	advancetable+4(,%ecx,4),%esi
+
+	addl	tstep,%edx
+	sbbl	%ecx,%ecx
+	movb	%al,1(%edi)
+	addl	%ebp,%ebx
+	movb	(%esi),%al
+	adcl	advancetable+4(,%ecx,4),%esi
+	addl	tstep,%edx
+LEntry15_16:
+	sbbl	%ecx,%ecx
+	movb	%al,2(%edi)
+	addl	%ebp,%ebx
+	movb	(%esi),%al
+	adcl	advancetable+4(,%ecx,4),%esi
+	addl	tstep,%edx
+LEntry14_16:
+	sbbl	%ecx,%ecx
+	movb	%al,3(%edi)
+	addl	%ebp,%ebx
+	movb	(%esi),%al
+	adcl	advancetable+4(,%ecx,4),%esi
+	addl	tstep,%edx
+LEntry13_16:
+	sbbl	%ecx,%ecx
+	movb	%al,4(%edi)
+	addl	%ebp,%ebx
+	movb	(%esi),%al
+	adcl	advancetable+4(,%ecx,4),%esi
+	addl	tstep,%edx
+LEntry12_16:
+	sbbl	%ecx,%ecx
+	movb	%al,5(%edi)
+	addl	%ebp,%ebx
+	movb	(%esi),%al
+	adcl	advancetable+4(,%ecx,4),%esi
+	addl	tstep,%edx
+LEntry11_16:
+	sbbl	%ecx,%ecx
+	movb	%al,6(%edi)
+	addl	%ebp,%ebx
+	movb	(%esi),%al
+	adcl	advancetable+4(,%ecx,4),%esi
+	addl	tstep,%edx
+LEntry10_16:
+	sbbl	%ecx,%ecx
+	movb	%al,7(%edi)
+	addl	%ebp,%ebx
+	movb	(%esi),%al
+	adcl	advancetable+4(,%ecx,4),%esi
+	addl	tstep,%edx
+LEntry9_16:
+	sbbl	%ecx,%ecx
+	movb	%al,8(%edi)
+	addl	%ebp,%ebx
+	movb	(%esi),%al
+	adcl	advancetable+4(,%ecx,4),%esi
+	addl	tstep,%edx
+LEntry8_16:
+	sbbl	%ecx,%ecx
+	movb	%al,9(%edi)
+	addl	%ebp,%ebx
+	movb	(%esi),%al
+	adcl	advancetable+4(,%ecx,4),%esi
+	addl	tstep,%edx
+LEntry7_16:
+	sbbl	%ecx,%ecx
+	movb	%al,10(%edi)
+	addl	%ebp,%ebx
+	movb	(%esi),%al
+	adcl	advancetable+4(,%ecx,4),%esi
+	addl	tstep,%edx
+LEntry6_16:
+	sbbl	%ecx,%ecx
+	movb	%al,11(%edi)
+	addl	%ebp,%ebx
+	movb	(%esi),%al
+	adcl	advancetable+4(,%ecx,4),%esi
+	addl	tstep,%edx
+LEntry5_16:
+	sbbl	%ecx,%ecx
+	movb	%al,12(%edi)
+	addl	%ebp,%ebx
+	movb	(%esi),%al
+	adcl	advancetable+4(,%ecx,4),%esi
+	addl	tstep,%edx
+LEntry4_16:
+	sbbl	%ecx,%ecx
+	movb	%al,13(%edi)
+	addl	%ebp,%ebx
+	movb	(%esi),%al
+	adcl	advancetable+4(,%ecx,4),%esi
+LEntry3_16:
+	movb	%al,14(%edi)
+	movb	(%esi),%al
+LEntry2_16:
+
+LEndSpan:
+
+//
+// clear s/z, t/z, 1/z from FP stack
+//
+	fstp %st(0)
+	fstp %st(0)
+	fstp %st(0)
+
+	movl	pspantemp,%ebx				// restore spans pointer
+	movl	espan_t_pnext(%ebx),%ebx	// point to next span
+	testl	%ebx,%ebx			// any more spans?
+	movb	%al,15(%edi)
+	jnz		LSpanLoop			// more spans
+
+	popl	%ebx				// restore register variables
+	popl	%esi
+	popl	%edi
+	popl	%ebp				// restore the caller's stack frame
+	ret
+
+#endif	// id386
diff -ruN WinQuake/d_draw16.s sdlquake-1.0.9/d_draw16.s
--- WinQuake/d_draw16.s	Tue Dec 21 15:53:24 1999
+++ sdlquake-1.0.9/d_draw16.s	Wed Dec 31 16:00:00 1969
@@ -1,974 +0,0 @@
-/*
-Copyright (C) 1996-1997 Id Software, Inc.
-
-This program is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License
-as published by the Free Software Foundation; either version 2
-of the License, or (at your option) any later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
-
-See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-*/
-//
-// d_draw16.s
-// x86 assembly-language horizontal 8-bpp span-drawing code, with 16-pixel
-// subdivision.
-//
-
-#include "asm_i386.h"
-#include "quakeasm.h"
-#include "asm_draw.h"
-#include "d_ifacea.h"
-
-#if	id386
-
-//----------------------------------------------------------------------
-// 8-bpp horizontal span drawing code for polygons, with no transparency and
-// 16-pixel subdivision.
-//
-// Assumes there is at least one span in pspans, and that every span
-// contains at least one pixel
-//----------------------------------------------------------------------
-
-	.data
-
-	.text
-
-// out-of-line, rarely-needed clamping code
-
-LClampHigh0:
-	movl	C(bbextents),%esi
-	jmp		LClampReentry0
-LClampHighOrLow0:
-	jg		LClampHigh0
-	xorl	%esi,%esi
-	jmp		LClampReentry0
-
-LClampHigh1:
-	movl	C(bbextentt),%edx
-	jmp		LClampReentry1
-LClampHighOrLow1:
-	jg		LClampHigh1
-	xorl	%edx,%edx
-	jmp		LClampReentry1
-
-LClampLow2:
-	movl	$4096,%ebp
-	jmp		LClampReentry2
-LClampHigh2:
-	movl	C(bbextents),%ebp
-	jmp		LClampReentry2
-
-LClampLow3:
-	movl	$4096,%ecx
-	jmp		LClampReentry3
-LClampHigh3:
-	movl	C(bbextentt),%ecx
-	jmp		LClampReentry3
-
-LClampLow4:
-	movl	$4096,%eax
-	jmp		LClampReentry4
-LClampHigh4:
-	movl	C(bbextents),%eax
-	jmp		LClampReentry4
-
-LClampLow5:
-	movl	$4096,%ebx
-	jmp		LClampReentry5
-LClampHigh5:
-	movl	C(bbextentt),%ebx
-	jmp		LClampReentry5
-
-
-#define pspans	4+16
-
-	.align 4
-.globl C(D_DrawSpans16)
-C(D_DrawSpans16):
-	pushl	%ebp				// preserve caller's stack frame
-	pushl	%edi
-	pushl	%esi				// preserve register variables
-	pushl	%ebx
-
-//
-// set up scaled-by-16 steps, for 16-long segments; also set up cacheblock
-// and span list pointers
-//
-// TODO: any overlap from rearranging?
-	flds	C(d_sdivzstepu)
-	fmuls	fp_16
-	movl	C(cacheblock),%edx
-	flds	C(d_tdivzstepu)
-	fmuls	fp_16
-	movl	pspans(%esp),%ebx	// point to the first span descriptor
-	flds	C(d_zistepu)
-	fmuls	fp_16
-	movl	%edx,pbase			// pbase = cacheblock
-	fstps	zi16stepu
-	fstps	tdivz16stepu
-	fstps	sdivz16stepu
-
-LSpanLoop:
-//
-// set up the initial s/z, t/z, and 1/z on the FP stack, and generate the
-// initial s and t values
-//
-// FIXME: pipeline FILD?
-	fildl	espan_t_v(%ebx)
-	fildl	espan_t_u(%ebx)
-
-	fld		%st(1)			// dv | du | dv
-	fmuls	C(d_sdivzstepv)	// dv*d_sdivzstepv | du | dv
-	fld		%st(1)			// du | dv*d_sdivzstepv | du | dv
-	fmuls	C(d_sdivzstepu)	// du*d_sdivzstepu | dv*d_sdivzstepv | du | dv
-	fld		%st(2)			// du | du*d_sdivzstepu | dv*d_sdivzstepv | du | dv
-	fmuls	C(d_tdivzstepu)	// du*d_tdivzstepu | du*d_sdivzstepu |
-							//  dv*d_sdivzstepv | du | dv
-	fxch	%st(1)			// du*d_sdivzstepu | du*d_tdivzstepu |
-							//  dv*d_sdivzstepv | du | dv
-	faddp	%st(0),%st(2)	// du*d_tdivzstepu |
-							//  du*d_sdivzstepu + dv*d_sdivzstepv | du | dv
-	fxch	%st(1)			// du*d_sdivzstepu + dv*d_sdivzstepv |
-							//  du*d_tdivzstepu | du | dv
-	fld		%st(3)			// dv | du*d_sdivzstepu + dv*d_sdivzstepv |
-							//  du*d_tdivzstepu | du | dv
-	fmuls	C(d_tdivzstepv)	// dv*d_tdivzstepv |
-							//  du*d_sdivzstepu + dv*d_sdivzstepv |
-							//  du*d_tdivzstepu | du | dv
-	fxch	%st(1)			// du*d_sdivzstepu + dv*d_sdivzstepv |
-							//  dv*d_tdivzstepv | du*d_tdivzstepu | du | dv
-	fadds	C(d_sdivzorigin)	// sdivz = d_sdivzorigin + dv*d_sdivzstepv +
-							//  du*d_sdivzstepu; stays in %st(2) at end
-	fxch	%st(4)			// dv | dv*d_tdivzstepv | du*d_tdivzstepu | du |
-							//  s/z
-	fmuls	C(d_zistepv)		// dv*d_zistepv | dv*d_tdivzstepv |
-							//  du*d_tdivzstepu | du | s/z
-	fxch	%st(1)			// dv*d_tdivzstepv |  dv*d_zistepv |
-							//  du*d_tdivzstepu | du | s/z
-	faddp	%st(0),%st(2)	// dv*d_zistepv |
-							//  dv*d_tdivzstepv + du*d_tdivzstepu | du | s/z
-	fxch	%st(2)			// du | dv*d_tdivzstepv + du*d_tdivzstepu |
-							//  dv*d_zistepv | s/z
-	fmuls	C(d_zistepu)		// du*d_zistepu |
-							//  dv*d_tdivzstepv + du*d_tdivzstepu |
-							//  dv*d_zistepv | s/z
-	fxch	%st(1)			// dv*d_tdivzstepv + du*d_tdivzstepu |
-							//  du*d_zistepu | dv*d_zistepv | s/z
-	fadds	C(d_tdivzorigin)	// tdivz = d_tdivzorigin + dv*d_tdivzstepv +
-							//  du*d_tdivzstepu; stays in %st(1) at end
-	fxch	%st(2)			// dv*d_zistepv | du*d_zistepu | t/z | s/z
-	faddp	%st(0),%st(1)	// dv*d_zistepv + du*d_zistepu | t/z | s/z
-
-	flds	fp_64k			// fp_64k | dv*d_zistepv + du*d_zistepu | t/z | s/z
-	fxch	%st(1)			// dv*d_zistepv + du*d_zistepu | fp_64k | t/z | s/z
-	fadds	C(d_ziorigin)		// zi = d_ziorigin + dv*d_zistepv +
-							//  du*d_zistepu; stays in %st(0) at end
-							// 1/z | fp_64k | t/z | s/z
-//
-// calculate and clamp s & t
-//
-	fdivr	%st(0),%st(1)	// 1/z | z*64k | t/z | s/z
-
-//
-// point %edi to the first pixel in the span
-//
-	movl	C(d_viewbuffer),%ecx
-	movl	espan_t_v(%ebx),%eax
-	movl	%ebx,pspantemp	// preserve spans pointer
-
-	movl	C(tadjust),%edx
-	movl	C(sadjust),%esi
-	movl	C(d_scantable)(,%eax,4),%edi	// v * screenwidth
-	addl	%ecx,%edi
-	movl	espan_t_u(%ebx),%ecx
-	addl	%ecx,%edi				// pdest = &pdestspan[scans->u];
-	movl	espan_t_count(%ebx),%ecx
-
-//
-// now start the FDIV for the end of the span
-//
-	cmpl	$16,%ecx
-	ja		LSetupNotLast1
-
-	decl	%ecx
-	jz		LCleanup1		// if only one pixel, no need to start an FDIV
-	movl	%ecx,spancountminus1
-
-// finish up the s and t calcs
-	fxch	%st(1)			// z*64k | 1/z | t/z | s/z
-
-	fld		%st(0)			// z*64k | z*64k | 1/z | t/z | s/z
-	fmul	%st(4),%st(0)	// s | z*64k | 1/z | t/z | s/z
-	fxch	%st(1)			// z*64k | s | 1/z | t/z | s/z
-	fmul	%st(3),%st(0)	// t | s | 1/z | t/z | s/z
-	fxch	%st(1)			// s | t | 1/z | t/z | s/z
-	fistpl	s				// 1/z | t | t/z | s/z
-	fistpl	t				// 1/z | t/z | s/z
-
-	fildl	spancountminus1
-
-	flds	C(d_tdivzstepu)	// C(d_tdivzstepu) | spancountminus1
-	flds	C(d_zistepu)		// C(d_zistepu) | C(d_tdivzstepu) | spancountminus1
-	fmul	%st(2),%st(0)	// C(d_zistepu)*scm1 | C(d_tdivzstepu) | scm1
-	fxch	%st(1)			// C(d_tdivzstepu) | C(d_zistepu)*scm1 | scm1
-	fmul	%st(2),%st(0)	// C(d_tdivzstepu)*scm1 | C(d_zistepu)*scm1 | scm1
-	fxch	%st(2)			// scm1 | C(d_zistepu)*scm1 | C(d_tdivzstepu)*scm1
-	fmuls	C(d_sdivzstepu)	// C(d_sdivzstepu)*scm1 | C(d_zistepu)*scm1 |
-							//  C(d_tdivzstepu)*scm1
-	fxch	%st(1)			// C(d_zistepu)*scm1 | C(d_sdivzstepu)*scm1 |
-							//  C(d_tdivzstepu)*scm1
-	faddp	%st(0),%st(3)	// C(d_sdivzstepu)*scm1 | C(d_tdivzstepu)*scm1
-	fxch	%st(1)			// C(d_tdivzstepu)*scm1 | C(d_sdivzstepu)*scm1
-	faddp	%st(0),%st(3)	// C(d_sdivzstepu)*scm1
-	faddp	%st(0),%st(3)
-
-	flds	fp_64k
-	fdiv	%st(1),%st(0)	// this is what we've gone to all this trouble to
-							//  overlap
-	jmp		LFDIVInFlight1
-
-LCleanup1:
-// finish up the s and t calcs
-	fxch	%st(1)			// z*64k | 1/z | t/z | s/z
-
-	fld		%st(0)			// z*64k | z*64k | 1/z | t/z | s/z
-	fmul	%st(4),%st(0)	// s | z*64k | 1/z | t/z | s/z
-	fxch	%st(1)			// z*64k | s | 1/z | t/z | s/z
-	fmul	%st(3),%st(0)	// t | s | 1/z | t/z | s/z
-	fxch	%st(1)			// s | t | 1/z | t/z | s/z
-	fistpl	s				// 1/z | t | t/z | s/z
-	fistpl	t				// 1/z | t/z | s/z
-	jmp		LFDIVInFlight1
-
-	.align	4
-LSetupNotLast1:
-// finish up the s and t calcs
-	fxch	%st(1)			// z*64k | 1/z | t/z | s/z
-
-	fld		%st(0)			// z*64k | z*64k | 1/z | t/z | s/z
-	fmul	%st(4),%st(0)	// s | z*64k | 1/z | t/z | s/z
-	fxch	%st(1)			// z*64k | s | 1/z | t/z | s/z
-	fmul	%st(3),%st(0)	// t | s | 1/z | t/z | s/z
-	fxch	%st(1)			// s | t | 1/z | t/z | s/z
-	fistpl	s				// 1/z | t | t/z | s/z
-	fistpl	t				// 1/z | t/z | s/z
-
-	fadds	zi16stepu
-	fxch	%st(2)
-	fadds	sdivz16stepu
-	fxch	%st(2)
-	flds	tdivz16stepu
-	faddp	%st(0),%st(2)
-	flds	fp_64k
-	fdiv	%st(1),%st(0)	// z = 1/1/z
-							// this is what we've gone to all this trouble to
-							//  overlap
-LFDIVInFlight1:
-
-	addl	s,%esi
-	addl	t,%edx
-	movl	C(bbextents),%ebx
-	movl	C(bbextentt),%ebp
-	cmpl	%ebx,%esi
-	ja		LClampHighOrLow0
-LClampReentry0:
-	movl	%esi,s
-	movl	pbase,%ebx
-	shll	$16,%esi
-	cmpl	%ebp,%edx
-	movl	%esi,sfracf
-	ja		LClampHighOrLow1
-LClampReentry1:
-	movl	%edx,t
-	movl	s,%esi					// sfrac = scans->sfrac;
-	shll	$16,%edx
-	movl	t,%eax					// tfrac = scans->tfrac;
-	sarl	$16,%esi
-	movl	%edx,tfracf
-
-//
-// calculate the texture starting address
-//
-	sarl	$16,%eax
-	movl	C(cachewidth),%edx
-	imull	%edx,%eax				// (tfrac >> 16) * cachewidth
-	addl	%ebx,%esi
-	addl	%eax,%esi				// psource = pbase + (sfrac >> 16) +
-									//           ((tfrac >> 16) * cachewidth);
-//
-// determine whether last span or not
-//
-	cmpl	$16,%ecx
-	jna		LLastSegment
-
-//
-// not the last segment; do full 16-wide segment
-//
-LNotLastSegment:
-
-//
-// advance s/z, t/z, and 1/z, and calculate s & t at end of span and steps to
-// get there
-//
-
-// pick up after the FDIV that was left in flight previously
-
-	fld		%st(0)			// duplicate it
-	fmul	%st(4),%st(0)	// s = s/z * z
-	fxch	%st(1)
-	fmul	%st(3),%st(0)	// t = t/z * z
-	fxch	%st(1)
-	fistpl	snext
-	fistpl	tnext
-	movl	snext,%eax
-	movl	tnext,%edx
-
-	movb	(%esi),%bl	// get first source texel
-	subl	$16,%ecx		// count off this segments' pixels
-	movl	C(sadjust),%ebp
-	movl	%ecx,counttemp	// remember count of remaining pixels
-
-	movl	C(tadjust),%ecx
-	movb	%bl,(%edi)	// store first dest pixel
-
-	addl	%eax,%ebp
-	addl	%edx,%ecx
-
-	movl	C(bbextents),%eax
-	movl	C(bbextentt),%edx
-
-	cmpl	$4096,%ebp
-	jl		LClampLow2
-	cmpl	%eax,%ebp
-	ja		LClampHigh2
-LClampReentry2:
-
-	cmpl	$4096,%ecx
-	jl		LClampLow3
-	cmpl	%edx,%ecx
-	ja		LClampHigh3
-LClampReentry3:
-
-	movl	%ebp,snext
-	movl	%ecx,tnext
-
-	subl	s,%ebp
-	subl	t,%ecx
-	
-//
-// set up advancetable
-//
-	movl	%ecx,%eax
-	movl	%ebp,%edx
-	sarl	$20,%eax			// tstep >>= 16;
-	jz		LZero
-	sarl	$20,%edx			// sstep >>= 16;
-	movl	C(cachewidth),%ebx
-	imull	%ebx,%eax
-	jmp		LSetUp1
-
-LZero:
-	sarl	$20,%edx			// sstep >>= 16;
-	movl	C(cachewidth),%ebx
-
-LSetUp1:
-
-	addl	%edx,%eax			// add in sstep
-								// (tstep >> 16) * cachewidth + (sstep >> 16);
-	movl	tfracf,%edx
-	movl	%eax,advancetable+4	// advance base in t
-	addl	%ebx,%eax			// ((tstep >> 16) + 1) * cachewidth +
-								//  (sstep >> 16);
-	shll	$12,%ebp			// left-justify sstep fractional part
-	movl	sfracf,%ebx
-	shll	$12,%ecx			// left-justify tstep fractional part
-	movl	%eax,advancetable	// advance extra in t
-
-	movl	%ecx,tstep
-	addl	%ecx,%edx			// advance tfrac fractional part by tstep frac
-
-	sbbl	%ecx,%ecx			// turn tstep carry into -1 (0 if none)
-	addl	%ebp,%ebx			// advance sfrac fractional part by sstep frac
-	adcl	advancetable+4(,%ecx,4),%esi	// point to next source texel
-
-	addl	tstep,%edx
-	sbbl	%ecx,%ecx
-	movb	(%esi),%al
-	addl	%ebp,%ebx
-	movb	%al,1(%edi)
-	adcl	advancetable+4(,%ecx,4),%esi
-
-	addl	tstep,%edx
-	sbbl	%ecx,%ecx
-	addl	%ebp,%ebx
-	movb	(%esi),%al
-	adcl	advancetable+4(,%ecx,4),%esi
-
-	addl	tstep,%edx
-	sbbl	%ecx,%ecx
-	movb	%al,2(%edi)
-	addl	%ebp,%ebx
-	movb	(%esi),%al
-	adcl	advancetable+4(,%ecx,4),%esi
-
-	addl	tstep,%edx
-	sbbl	%ecx,%ecx
-	movb	%al,3(%edi)
-	addl	%ebp,%ebx
-	movb	(%esi),%al
-	adcl	advancetable+4(,%ecx,4),%esi
-
-	addl	tstep,%edx
-	sbbl	%ecx,%ecx
-	movb	%al,4(%edi)
-	addl	%ebp,%ebx
-	movb	(%esi),%al
-	adcl	advancetable+4(,%ecx,4),%esi
-
-	addl	tstep,%edx
-	sbbl	%ecx,%ecx
-	movb	%al,5(%edi)
-	addl	%ebp,%ebx
-	movb	(%esi),%al
-	adcl	advancetable+4(,%ecx,4),%esi
-
-	addl	tstep,%edx
-	sbbl	%ecx,%ecx
-	movb	%al,6(%edi)
-	addl	%ebp,%ebx
-	movb	(%esi),%al
-	adcl	advancetable+4(,%ecx,4),%esi
-
-	addl	tstep,%edx
-	sbbl	%ecx,%ecx
-	movb	%al,7(%edi)
-	addl	%ebp,%ebx
-	movb	(%esi),%al
-	adcl	advancetable+4(,%ecx,4),%esi
-
-
-//
-// start FDIV for end of next segment in flight, so it can overlap
-//
-	movl	counttemp,%ecx
-	cmpl	$16,%ecx			// more than one segment after this?
-	ja		LSetupNotLast2	// yes
-
-	decl	%ecx
-	jz		LFDIVInFlight2	// if only one pixel, no need to start an FDIV
-	movl	%ecx,spancountminus1
-	fildl	spancountminus1
-
-	flds	C(d_zistepu)		// C(d_zistepu) | spancountminus1
-	fmul	%st(1),%st(0)	// C(d_zistepu)*scm1 | scm1
-	flds	C(d_tdivzstepu)	// C(d_tdivzstepu) | C(d_zistepu)*scm1 | scm1
-	fmul	%st(2),%st(0)	// C(d_tdivzstepu)*scm1 | C(d_zistepu)*scm1 | scm1
-	fxch	%st(1)			// C(d_zistepu)*scm1 | C(d_tdivzstepu)*scm1 | scm1
-	faddp	%st(0),%st(3)	// C(d_tdivzstepu)*scm1 | scm1
-	fxch	%st(1)			// scm1 | C(d_tdivzstepu)*scm1
-	fmuls	C(d_sdivzstepu)	// C(d_sdivzstepu)*scm1 | C(d_tdivzstepu)*scm1
-	fxch	%st(1)			// C(d_tdivzstepu)*scm1 | C(d_sdivzstepu)*scm1
-	faddp	%st(0),%st(3)	// C(d_sdivzstepu)*scm1
-	flds	fp_64k			// 64k | C(d_sdivzstepu)*scm1
-	fxch	%st(1)			// C(d_sdivzstepu)*scm1 | 64k
-	faddp	%st(0),%st(4)	// 64k
-
-	fdiv	%st(1),%st(0)	// this is what we've gone to all this trouble to
-							//  overlap
-	jmp		LFDIVInFlight2
-
-	.align	4
-LSetupNotLast2:
-	fadds	zi16stepu
-	fxch	%st(2)
-	fadds	sdivz16stepu
-	fxch	%st(2)
-	flds	tdivz16stepu
-	faddp	%st(0),%st(2)
-	flds	fp_64k
-	fdiv	%st(1),%st(0)	// z = 1/1/z
-							// this is what we've gone to all this trouble to
-							//  overlap
-LFDIVInFlight2:
-	movl	%ecx,counttemp
-
-	addl	tstep,%edx
-	sbbl	%ecx,%ecx
-	movb	%al,8(%edi)
-	addl	%ebp,%ebx
-	movb	(%esi),%al
-	adcl	advancetable+4(,%ecx,4),%esi
-
-	addl	tstep,%edx
-	sbbl	%ecx,%ecx
-	movb	%al,9(%edi)
-	addl	%ebp,%ebx
-	movb	(%esi),%al
-	adcl	advancetable+4(,%ecx,4),%esi
-
-	addl	tstep,%edx
-	sbbl	%ecx,%ecx
-	movb	%al,10(%edi)
-	addl	%ebp,%ebx
-	movb	(%esi),%al
-	adcl	advancetable+4(,%ecx,4),%esi
-
-	addl	tstep,%edx
-	sbbl	%ecx,%ecx
-	movb	%al,11(%edi)
-	addl	%ebp,%ebx
-	movb	(%esi),%al
-	adcl	advancetable+4(,%ecx,4),%esi
-
-	addl	tstep,%edx
-	sbbl	%ecx,%ecx
-	movb	%al,12(%edi)
-	addl	%ebp,%ebx
-	movb	(%esi),%al
-	adcl	advancetable+4(,%ecx,4),%esi
-
-	addl	tstep,%edx
-	sbbl	%ecx,%ecx
-	movb	%al,13(%edi)
-	addl	%ebp,%ebx
-	movb	(%esi),%al
-	adcl	advancetable+4(,%ecx,4),%esi
-
-	addl	tstep,%edx
-	sbbl	%ecx,%ecx
-	movb	%al,14(%edi)
-	addl	%ebp,%ebx
-	movb	(%esi),%al
-	adcl	advancetable+4(,%ecx,4),%esi
-
-	addl	$16,%edi
-	movl	%edx,tfracf
-	movl	snext,%edx
-	movl	%ebx,sfracf
-	movl	tnext,%ebx
-	movl	%edx,s
-	movl	%ebx,t
-
-	movl	counttemp,%ecx		// retrieve count
-
-//
-// determine whether last span or not
-//
-	cmpl	$16,%ecx				// are there multiple segments remaining?
-	movb	%al,-1(%edi)
-	ja		LNotLastSegment		// yes
-
-//
-// last segment of scan
-//
-LLastSegment:
-
-//
-// advance s/z, t/z, and 1/z, and calculate s & t at end of span and steps to
-// get there. The number of pixels left is variable, and we want to land on the
-// last pixel, not step one past it, so we can't run into arithmetic problems
-//
-	testl	%ecx,%ecx
-	jz		LNoSteps		// just draw the last pixel and we're done
-
-// pick up after the FDIV that was left in flight previously
-
-
-	fld		%st(0)			// duplicate it
-	fmul	%st(4),%st(0)	// s = s/z * z
-	fxch	%st(1)
-	fmul	%st(3),%st(0)	// t = t/z * z
-	fxch	%st(1)
-	fistpl	snext
-	fistpl	tnext
-
-	movb	(%esi),%al		// load first texel in segment
-	movl	C(tadjust),%ebx
-	movb	%al,(%edi)		// store first pixel in segment
-	movl	C(sadjust),%eax
-
-	addl	snext,%eax
-	addl	tnext,%ebx
-
-	movl	C(bbextents),%ebp
-	movl	C(bbextentt),%edx
-
-	cmpl	$4096,%eax
-	jl		LClampLow4
-	cmpl	%ebp,%eax
-	ja		LClampHigh4
-LClampReentry4:
-	movl	%eax,snext
-
-	cmpl	$4096,%ebx
-	jl		LClampLow5
-	cmpl	%edx,%ebx
-	ja		LClampHigh5
-LClampReentry5:
-
-	cmpl	$1,%ecx			// don't bother 
-	je		LOnlyOneStep	// if two pixels in segment, there's only one step,
-							//  of the segment length
-	subl	s,%eax
-	subl	t,%ebx
-
-	addl	%eax,%eax		// convert to 15.17 format so multiply by 1.31
-	addl	%ebx,%ebx		//  reciprocal yields 16.48
-
-	imull	reciprocal_table_16-8(,%ecx,4)	// sstep = (snext - s) /
-											//  (spancount-1)
-	movl	%edx,%ebp
-
-	movl	%ebx,%eax
-	imull	reciprocal_table_16-8(,%ecx,4)	// tstep = (tnext - t) /
-											//  (spancount-1)
-LSetEntryvec:
-//
-// set up advancetable
-//
-	movl	entryvec_table_16(,%ecx,4),%ebx
-	movl	%edx,%eax
-	movl	%ebx,jumptemp		// entry point into code for RET later
-	movl	%ebp,%ecx
-	sarl	$16,%edx			// tstep >>= 16;
-	movl	C(cachewidth),%ebx
-	sarl	$16,%ecx			// sstep >>= 16;
-	imull	%ebx,%edx
-
-	addl	%ecx,%edx			// add in sstep
-								// (tstep >> 16) * cachewidth + (sstep >> 16);
-	movl	tfracf,%ecx
-	movl	%edx,advancetable+4	// advance base in t
-	addl	%ebx,%edx			// ((tstep >> 16) + 1) * cachewidth +
-								//  (sstep >> 16);
-	shll	$16,%ebp			// left-justify sstep fractional part
-	movl	sfracf,%ebx
-	shll	$16,%eax			// left-justify tstep fractional part
-	movl	%edx,advancetable	// advance extra in t
-
-	movl	%eax,tstep
-	movl	%ecx,%edx
-	addl	%eax,%edx
-	sbbl	%ecx,%ecx
-	addl	%ebp,%ebx
-	adcl	advancetable+4(,%ecx,4),%esi
-
-	jmp		*jumptemp			// jump to the number-of-pixels handler
-
-//----------------------------------------
-
-LNoSteps:
-	movb	(%esi),%al		// load first texel in segment
-	subl	$15,%edi			// adjust for hardwired offset
-	jmp		LEndSpan
-
-
-LOnlyOneStep:
-	subl	s,%eax
-	subl	t,%ebx
-	movl	%eax,%ebp
-	movl	%ebx,%edx
-	jmp		LSetEntryvec
-
-//----------------------------------------
-
-.globl	Entry2_16, Entry3_16, Entry4_16, Entry5_16
-.globl	Entry6_16, Entry7_16, Entry8_16, Entry9_16
-.globl	Entry10_16, Entry11_16, Entry12_16, Entry13_16
-.globl	Entry14_16, Entry15_16, Entry16_16
-
-Entry2_16:
-	subl	$14,%edi		// adjust for hardwired offsets
-	movb	(%esi),%al
-	jmp		LEntry2_16
-
-//----------------------------------------
-
-Entry3_16:
-	subl	$13,%edi		// adjust for hardwired offsets
-	addl	%eax,%edx
-	movb	(%esi),%al
-	sbbl	%ecx,%ecx
-	addl	%ebp,%ebx
-	adcl	advancetable+4(,%ecx,4),%esi
-	jmp		LEntry3_16
-
-//----------------------------------------
-
-Entry4_16:
-	subl	$12,%edi		// adjust for hardwired offsets
-	addl	%eax,%edx
-	movb	(%esi),%al
-	sbbl	%ecx,%ecx
-	addl	%ebp,%ebx
-	adcl	advancetable+4(,%ecx,4),%esi
-	addl	tstep,%edx
-	jmp		LEntry4_16
-
-//----------------------------------------
-
-Entry5_16:
-	subl	$11,%edi		// adjust for hardwired offsets
-	addl	%eax,%edx
-	movb	(%esi),%al
-	sbbl	%ecx,%ecx
-	addl	%ebp,%ebx
-	adcl	advancetable+4(,%ecx,4),%esi
-	addl	tstep,%edx
-	jmp		LEntry5_16
-
-//----------------------------------------
-
-Entry6_16:
-	subl	$10,%edi		// adjust for hardwired offsets
-	addl	%eax,%edx
-	movb	(%esi),%al
-	sbbl	%ecx,%ecx
-	addl	%ebp,%ebx
-	adcl	advancetable+4(,%ecx,4),%esi
-	addl	tstep,%edx
-	jmp		LEntry6_16
-
-//----------------------------------------
-
-Entry7_16:
-	subl	$9,%edi		// adjust for hardwired offsets
-	addl	%eax,%edx
-	movb	(%esi),%al
-	sbbl	%ecx,%ecx
-	addl	%ebp,%ebx
-	adcl	advancetable+4(,%ecx,4),%esi
-	addl	tstep,%edx
-	jmp		LEntry7_16
-
-//----------------------------------------
-
-Entry8_16:
-	subl	$8,%edi		// adjust for hardwired offsets
-	addl	%eax,%edx
-	movb	(%esi),%al
-	sbbl	%ecx,%ecx
-	addl	%ebp,%ebx
-	adcl	advancetable+4(,%ecx,4),%esi
-	addl	tstep,%edx
-	jmp		LEntry8_16
-
-//----------------------------------------
-
-Entry9_16:
-	subl	$7,%edi		// adjust for hardwired offsets
-	addl	%eax,%edx
-	movb	(%esi),%al
-	sbbl	%ecx,%ecx
-	addl	%ebp,%ebx
-	adcl	advancetable+4(,%ecx,4),%esi
-	addl	tstep,%edx
-	jmp		LEntry9_16
-
-//----------------------------------------
-
-Entry10_16:
-	subl	$6,%edi		// adjust for hardwired offsets
-	addl	%eax,%edx
-	movb	(%esi),%al
-	sbbl	%ecx,%ecx
-	addl	%ebp,%ebx
-	adcl	advancetable+4(,%ecx,4),%esi
-	addl	tstep,%edx
-	jmp		LEntry10_16
-
-//----------------------------------------
-
-Entry11_16:
-	subl	$5,%edi		// adjust for hardwired offsets
-	addl	%eax,%edx
-	movb	(%esi),%al
-	sbbl	%ecx,%ecx
-	addl	%ebp,%ebx
-	adcl	advancetable+4(,%ecx,4),%esi
-	addl	tstep,%edx
-	jmp		LEntry11_16
-
-//----------------------------------------
-
-Entry12_16:
-	subl	$4,%edi		// adjust for hardwired offsets
-	addl	%eax,%edx
-	movb	(%esi),%al
-	sbbl	%ecx,%ecx
-	addl	%ebp,%ebx
-	adcl	advancetable+4(,%ecx,4),%esi
-	addl	tstep,%edx
-	jmp		LEntry12_16
-
-//----------------------------------------
-
-Entry13_16:
-	subl	$3,%edi		// adjust for hardwired offsets
-	addl	%eax,%edx
-	movb	(%esi),%al
-	sbbl	%ecx,%ecx
-	addl	%ebp,%ebx
-	adcl	advancetable+4(,%ecx,4),%esi
-	addl	tstep,%edx
-	jmp		LEntry13_16
-
-//----------------------------------------
-
-Entry14_16:
-	subl	$2,%edi		// adjust for hardwired offsets
-	addl	%eax,%edx
-	movb	(%esi),%al
-	sbbl	%ecx,%ecx
-	addl	%ebp,%ebx
-	adcl	advancetable+4(,%ecx,4),%esi
-	addl	tstep,%edx
-	jmp		LEntry14_16
-
-//----------------------------------------
-
-Entry15_16:
-	decl	%edi		// adjust for hardwired offsets
-	addl	%eax,%edx
-	movb	(%esi),%al
-	sbbl	%ecx,%ecx
-	addl	%ebp,%ebx
-	adcl	advancetable+4(,%ecx,4),%esi
-	addl	tstep,%edx
-	jmp		LEntry15_16
-
-//----------------------------------------
-
-Entry16_16:
-	addl	%eax,%edx
-	movb	(%esi),%al
-	sbbl	%ecx,%ecx
-	addl	%ebp,%ebx
-	adcl	advancetable+4(,%ecx,4),%esi
-
-	addl	tstep,%edx
-	sbbl	%ecx,%ecx
-	movb	%al,1(%edi)
-	addl	%ebp,%ebx
-	movb	(%esi),%al
-	adcl	advancetable+4(,%ecx,4),%esi
-	addl	tstep,%edx
-LEntry15_16:
-	sbbl	%ecx,%ecx
-	movb	%al,2(%edi)
-	addl	%ebp,%ebx
-	movb	(%esi),%al
-	adcl	advancetable+4(,%ecx,4),%esi
-	addl	tstep,%edx
-LEntry14_16:
-	sbbl	%ecx,%ecx
-	movb	%al,3(%edi)
-	addl	%ebp,%ebx
-	movb	(%esi),%al
-	adcl	advancetable+4(,%ecx,4),%esi
-	addl	tstep,%edx
-LEntry13_16:
-	sbbl	%ecx,%ecx
-	movb	%al,4(%edi)
-	addl	%ebp,%ebx
-	movb	(%esi),%al
-	adcl	advancetable+4(,%ecx,4),%esi
-	addl	tstep,%edx
-LEntry12_16:
-	sbbl	%ecx,%ecx
-	movb	%al,5(%edi)
-	addl	%ebp,%ebx
-	movb	(%esi),%al
-	adcl	advancetable+4(,%ecx,4),%esi
-	addl	tstep,%edx
-LEntry11_16:
-	sbbl	%ecx,%ecx
-	movb	%al,6(%edi)
-	addl	%ebp,%ebx
-	movb	(%esi),%al
-	adcl	advancetable+4(,%ecx,4),%esi
-	addl	tstep,%edx
-LEntry10_16:
-	sbbl	%ecx,%ecx
-	movb	%al,7(%edi)
-	addl	%ebp,%ebx
-	movb	(%esi),%al
-	adcl	advancetable+4(,%ecx,4),%esi
-	addl	tstep,%edx
-LEntry9_16:
-	sbbl	%ecx,%ecx
-	movb	%al,8(%edi)
-	addl	%ebp,%ebx
-	movb	(%esi),%al
-	adcl	advancetable+4(,%ecx,4),%esi
-	addl	tstep,%edx
-LEntry8_16:
-	sbbl	%ecx,%ecx
-	movb	%al,9(%edi)
-	addl	%ebp,%ebx
-	movb	(%esi),%al
-	adcl	advancetable+4(,%ecx,4),%esi
-	addl	tstep,%edx
-LEntry7_16:
-	sbbl	%ecx,%ecx
-	movb	%al,10(%edi)
-	addl	%ebp,%ebx
-	movb	(%esi),%al
-	adcl	advancetable+4(,%ecx,4),%esi
-	addl	tstep,%edx
-LEntry6_16:
-	sbbl	%ecx,%ecx
-	movb	%al,11(%edi)
-	addl	%ebp,%ebx
-	movb	(%esi),%al
-	adcl	advancetable+4(,%ecx,4),%esi
-	addl	tstep,%edx
-LEntry5_16:
-	sbbl	%ecx,%ecx
-	movb	%al,12(%edi)
-	addl	%ebp,%ebx
-	movb	(%esi),%al
-	adcl	advancetable+4(,%ecx,4),%esi
-	addl	tstep,%edx
-LEntry4_16:
-	sbbl	%ecx,%ecx
-	movb	%al,13(%edi)
-	addl	%ebp,%ebx
-	movb	(%esi),%al
-	adcl	advancetable+4(,%ecx,4),%esi
-LEntry3_16:
-	movb	%al,14(%edi)
-	movb	(%esi),%al
-LEntry2_16:
-
-LEndSpan:
-
-//
-// clear s/z, t/z, 1/z from FP stack
-//
-	fstp %st(0)
-	fstp %st(0)
-	fstp %st(0)
-
-	movl	pspantemp,%ebx				// restore spans pointer
-	movl	espan_t_pnext(%ebx),%ebx	// point to next span
-	testl	%ebx,%ebx			// any more spans?
-	movb	%al,15(%edi)
-	jnz		LSpanLoop			// more spans
-
-	popl	%ebx				// restore register variables
-	popl	%esi
-	popl	%edi
-	popl	%ebp				// restore the caller's stack frame
-	ret
-
-#endif	// id386
diff -ruN WinQuake/d_parta.S sdlquake-1.0.9/d_parta.S
--- WinQuake/d_parta.S	Wed Dec 31 16:00:00 1969
+++ sdlquake-1.0.9/d_parta.S	Sat Dec 25 03:38:02 1999
@@ -0,0 +1,477 @@
+/*
+Copyright (C) 1996-1997 Id Software, Inc.
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation; either version 2
+of the License, or (at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
+
+See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+//
+// d_parta.s
+// x86 assembly-language 8-bpp particle-drawing code.
+//
+
+#include "asm_i386.h"
+#include "quakeasm.h"
+#include "d_ifacea.h"
+#include "asm_draw.h"
+
+#if	id386
+
+//----------------------------------------------------------------------
+// 8-bpp particle drawing code.
+//----------------------------------------------------------------------
+
+//FIXME: comments, full optimization
+
+//----------------------------------------------------------------------
+// 8-bpp particle queueing code.
+//----------------------------------------------------------------------
+
+	.text
+
+#define P	12+4
+
+	.align 4
+.globl C(D_DrawParticle)
+C(D_DrawParticle):
+	pushl	%ebp				// preserve caller's stack frame
+	pushl	%edi				// preserve register variables
+	pushl	%ebx
+
+	movl	P(%esp),%edi
+
+// FIXME: better FP overlap in general here
+
+// transform point
+//	VectorSubtract (p->org, r_origin, local);
+	flds	C(r_origin)
+	fsubrs	pt_org(%edi)
+	flds	pt_org+4(%edi)
+	fsubs	C(r_origin)+4
+	flds	pt_org+8(%edi)
+	fsubs	C(r_origin)+8
+	fxch	%st(2)			// local[0] | local[1] | local[2]
+
+//	transformed[2] = DotProduct(local, r_ppn);		
+	flds	C(r_ppn)		// r_ppn[0] | local[0] | local[1] | local[2]
+	fmul	%st(1),%st(0)	// dot0 | local[0] | local[1] | local[2]
+	flds	C(r_ppn)+4	// r_ppn[1] | dot0 | local[0] | local[1] | local[2]
+	fmul	%st(3),%st(0)	// dot1 | dot0 | local[0] | local[1] | local[2]
+	flds	C(r_ppn)+8	// r_ppn[2] | dot1 | dot0 | local[0] |
+						//  local[1] | local[2]
+	fmul	%st(5),%st(0)	// dot2 | dot1 | dot0 | local[0] | local[1] | local[2]
+	fxch	%st(2)		// dot0 | dot1 | dot2 | local[0] | local[1] | local[2]
+	faddp	%st(0),%st(1) // dot0 + dot1 | dot2 | local[0] | local[1] |
+						  //  local[2]
+	faddp	%st(0),%st(1) // z | local[0] | local[1] | local[2]
+	fld		%st(0)		// z | z | local[0] | local[1] |
+						//  local[2]
+	fdivrs	float_1		// 1/z | z | local[0] | local[1] | local[2]
+	fxch	%st(1)		// z | 1/z | local[0] | local[1] | local[2]
+
+//	if (transformed[2] < PARTICLE_Z_CLIP)
+//		return;
+	fcomps	float_particle_z_clip	// 1/z | local[0] | local[1] | local[2]
+	fxch	%st(3)					// local[2] | local[0] | local[1] | 1/z
+
+	flds	C(r_pup)	// r_pup[0] | local[2] | local[0] | local[1] | 1/z
+	fmul	%st(2),%st(0)	// dot0 | local[2] | local[0] | local[1] | 1/z 
+	flds	C(r_pup)+4	// r_pup[1] | dot0 | local[2] | local[0] |
+						//  local[1] | 1/z 
+
+	fnstsw	%ax
+	testb	$1,%ah
+	jnz		LPop6AndDone
+
+//	transformed[1] = DotProduct(local, r_pup);
+	fmul	%st(4),%st(0)	// dot1 | dot0 | local[2] | local[0] | local[1] | 1/z 
+	flds	C(r_pup)+8	// r_pup[2] | dot1 | dot0 | local[2] |
+						//  local[0] | local[1] | 1/z 
+	fmul	%st(3),%st(0)	// dot2 | dot1 | dot0 | local[2] | local[0] |
+						//  local[1] | 1/z 
+	fxch	%st(2)		// dot0 | dot1 | dot2 | local[2] | local[0] |
+						//  local[1] | 1/z 
+	faddp	%st(0),%st(1) // dot0 + dot1 | dot2 | local[2] | local[0] |
+						//  local[1] | 1/z 
+	faddp	%st(0),%st(1) // y | local[2] | local[0] | local[1] | 1/z 
+	fxch	%st(3)		// local[1] | local[2] | local[0] | y | 1/z 
+
+//	transformed[0] = DotProduct(local, r_pright);
+	fmuls	C(r_pright)+4	// dot1 | local[2] | local[0] | y | 1/z
+	fxch	%st(2)		// local[0] | local[2] | dot1 | y | 1/z
+	fmuls	C(r_pright)	// dot0 | local[2] | dot1 | y | 1/z
+	fxch	%st(1)		// local[2] | dot0 | dot1 | y | 1/z
+	fmuls	C(r_pright)+8	// dot2 | dot0 | dot1 | y | 1/z
+	fxch	%st(2)		// dot1 | dot0 | dot2 | y | 1/z
+	faddp	%st(0),%st(1) // dot1 + dot0 | dot2 | y | 1/z
+
+	faddp	%st(0),%st(1)	// x | y | 1/z
+	fxch	%st(1)			// y | x | 1/z
+
+// project the point
+	fmul	%st(2),%st(0)	// y/z | x | 1/z
+	fxch	%st(1)			// x | y/z | 1/z
+	fmul	%st(2),%st(0)	// x/z | y/z | 1/z
+	fxch	%st(1)			// y/z | x/z | 1/z
+	fsubrs	C(ycenter)		// v | x/z | 1/z
+	fxch	%st(1)			// x/z | v | 1/z
+	fadds	C(xcenter)		// u | v | 1/z
+// FIXME: preadjust xcenter and ycenter
+	fxch	%st(1)			// v | u | 1/z
+	fadds	float_point5	// v | u | 1/z
+	fxch	%st(1)			// u | v | 1/z
+	fadds	float_point5	// u | v | 1/z
+	fxch	%st(2)			// 1/z | v | u
+	fmuls	DP_32768		// 1/z * 0x8000 | v | u
+	fxch	%st(2)			// u | v | 1/z * 0x8000
+
+// FIXME: use Terje's fp->int trick here?
+// FIXME: check we're getting proper rounding here
+	fistpl	DP_u			// v | 1/z * 0x8000
+	fistpl	DP_v			// 1/z * 0x8000
+
+	movl	DP_u,%eax
+	movl	DP_v,%edx
+
+// if ((v > d_vrectbottom_particle) || 
+// 	(u > d_vrectright_particle) ||
+// 	(v < d_vrecty) ||
+// 	(u < d_vrectx))
+// {
+// 	continue;
+// }
+
+	movl	C(d_vrectbottom_particle),%ebx
+	movl	C(d_vrectright_particle),%ecx
+	cmpl	%ebx,%edx
+	jg		LPop1AndDone
+	cmpl	%ecx,%eax
+	jg		LPop1AndDone
+	movl	C(d_vrecty),%ebx
+	movl	C(d_vrectx),%ecx
+	cmpl	%ebx,%edx
+	jl		LPop1AndDone
+
+	cmpl	%ecx,%eax
+	jl		LPop1AndDone
+
+	flds	pt_color(%edi)	// color | 1/z * 0x8000
+// FIXME: use Terje's fast fp->int trick?
+	fistpl	DP_Color		// 1/z * 0x8000
+
+	movl	C(d_viewbuffer),%ebx
+
+	addl	%eax,%ebx
+	movl	C(d_scantable)(,%edx,4),%edi		// point to the pixel
+
+	imull	C(d_zrowbytes),%edx		// point to the z pixel
+
+	leal	(%edx,%eax,2),%edx
+	movl	C(d_pzbuffer),%eax
+
+	fistpl	izi
+
+	addl	%ebx,%edi
+	addl	%eax,%edx
+
+// pix = izi >> d_pix_shift;
+
+	movl	izi,%eax
+	movl	C(d_pix_shift),%ecx
+	shrl	%cl,%eax
+	movl	izi,%ebp
+
+// if (pix < d_pix_min)
+// 		pix = d_pix_min;
+// else if (pix > d_pix_max)
+//  	pix = d_pix_max;
+
+	movl	C(d_pix_min),%ebx
+	movl	C(d_pix_max),%ecx
+	cmpl	%ebx,%eax
+	jnl		LTestPixMax
+	movl	%ebx,%eax
+	jmp		LTestDone
+
+LTestPixMax:
+	cmpl	%ecx,%eax
+	jng		LTestDone
+	movl	%ecx,%eax
+LTestDone:
+
+	movb	DP_Color,%ch
+
+	movl	C(d_y_aspect_shift),%ebx
+	testl	%ebx,%ebx
+	jnz		LDefault
+
+	cmpl	$4,%eax
+	ja		LDefault
+
+	jmp		DP_EntryTable-4(,%eax,4)
+
+// 1x1
+.globl	DP_1x1
+DP_1x1:
+	cmpw	%bp,(%edx)		// just one pixel to do
+	jg		LDone
+	movw	%bp,(%edx)
+	movb	%ch,(%edi)
+	jmp		LDone
+
+// 2x2
+.globl	DP_2x2
+DP_2x2:
+	pushl	%esi
+	movl	C(screenwidth),%ebx
+	movl	C(d_zrowbytes),%esi
+
+	cmpw	%bp,(%edx)
+	jg		L2x2_1
+	movw	%bp,(%edx)
+	movb	%ch,(%edi)
+L2x2_1:
+	cmpw	%bp,2(%edx)
+	jg		L2x2_2
+	movw	%bp,2(%edx)
+	movb	%ch,1(%edi)
+L2x2_2:
+	cmpw	%bp,(%edx,%esi,1)
+	jg		L2x2_3
+	movw	%bp,(%edx,%esi,1)
+	movb	%ch,(%edi,%ebx,1)
+L2x2_3:
+	cmpw	%bp,2(%edx,%esi,1)
+	jg		L2x2_4
+	movw	%bp,2(%edx,%esi,1)
+	movb	%ch,1(%edi,%ebx,1)
+L2x2_4:
+
+	popl	%esi
+	jmp		LDone
+
+// 3x3
+.globl	DP_3x3
+DP_3x3:
+	pushl	%esi
+	movl	C(screenwidth),%ebx
+	movl	C(d_zrowbytes),%esi
+
+	cmpw	%bp,(%edx)
+	jg		L3x3_1
+	movw	%bp,(%edx)
+	movb	%ch,(%edi)
+L3x3_1:
+	cmpw	%bp,2(%edx)
+	jg		L3x3_2
+	movw	%bp,2(%edx)
+	movb	%ch,1(%edi)
+L3x3_2:
+	cmpw	%bp,4(%edx)
+	jg		L3x3_3
+	movw	%bp,4(%edx)
+	movb	%ch,2(%edi)
+L3x3_3:
+
+	cmpw	%bp,(%edx,%esi,1)
+	jg		L3x3_4
+	movw	%bp,(%edx,%esi,1)
+	movb	%ch,(%edi,%ebx,1)
+L3x3_4:
+	cmpw	%bp,2(%edx,%esi,1)
+	jg		L3x3_5
+	movw	%bp,2(%edx,%esi,1)
+	movb	%ch,1(%edi,%ebx,1)
+L3x3_5:
+	cmpw	%bp,4(%edx,%esi,1)
+	jg		L3x3_6
+	movw	%bp,4(%edx,%esi,1)
+	movb	%ch,2(%edi,%ebx,1)
+L3x3_6:
+
+	cmpw	%bp,(%edx,%esi,2)
+	jg		L3x3_7
+	movw	%bp,(%edx,%esi,2)
+	movb	%ch,(%edi,%ebx,2)
+L3x3_7:
+	cmpw	%bp,2(%edx,%esi,2)
+	jg		L3x3_8
+	movw	%bp,2(%edx,%esi,2)
+	movb	%ch,1(%edi,%ebx,2)
+L3x3_8:
+	cmpw	%bp,4(%edx,%esi,2)
+	jg		L3x3_9
+	movw	%bp,4(%edx,%esi,2)
+	movb	%ch,2(%edi,%ebx,2)
+L3x3_9:
+
+	popl	%esi
+	jmp		LDone
+
+
+// 4x4
+.globl	DP_4x4
+DP_4x4:
+	pushl	%esi
+	movl	C(screenwidth),%ebx
+	movl	C(d_zrowbytes),%esi
+
+	cmpw	%bp,(%edx)
+	jg		L4x4_1
+	movw	%bp,(%edx)
+	movb	%ch,(%edi)
+L4x4_1:
+	cmpw	%bp,2(%edx)
+	jg		L4x4_2
+	movw	%bp,2(%edx)
+	movb	%ch,1(%edi)
+L4x4_2:
+	cmpw	%bp,4(%edx)
+	jg		L4x4_3
+	movw	%bp,4(%edx)
+	movb	%ch,2(%edi)
+L4x4_3:
+	cmpw	%bp,6(%edx)
+	jg		L4x4_4
+	movw	%bp,6(%edx)
+	movb	%ch,3(%edi)
+L4x4_4:
+
+	cmpw	%bp,(%edx,%esi,1)
+	jg		L4x4_5
+	movw	%bp,(%edx,%esi,1)
+	movb	%ch,(%edi,%ebx,1)
+L4x4_5:
+	cmpw	%bp,2(%edx,%esi,1)
+	jg		L4x4_6
+	movw	%bp,2(%edx,%esi,1)
+	movb	%ch,1(%edi,%ebx,1)
+L4x4_6:
+	cmpw	%bp,4(%edx,%esi,1)
+	jg		L4x4_7
+	movw	%bp,4(%edx,%esi,1)
+	movb	%ch,2(%edi,%ebx,1)
+L4x4_7:
+	cmpw	%bp,6(%edx,%esi,1)
+	jg		L4x4_8
+	movw	%bp,6(%edx,%esi,1)
+	movb	%ch,3(%edi,%ebx,1)
+L4x4_8:
+
+	leal	(%edx,%esi,2),%edx
+	leal	(%edi,%ebx,2),%edi
+
+	cmpw	%bp,(%edx)
+	jg		L4x4_9
+	movw	%bp,(%edx)
+	movb	%ch,(%edi)
+L4x4_9:
+	cmpw	%bp,2(%edx)
+	jg		L4x4_10
+	movw	%bp,2(%edx)
+	movb	%ch,1(%edi)
+L4x4_10:
+	cmpw	%bp,4(%edx)
+	jg		L4x4_11
+	movw	%bp,4(%edx)
+	movb	%ch,2(%edi)
+L4x4_11:
+	cmpw	%bp,6(%edx)
+	jg		L4x4_12
+	movw	%bp,6(%edx)
+	movb	%ch,3(%edi)
+L4x4_12:
+
+	cmpw	%bp,(%edx,%esi,1)
+	jg		L4x4_13
+	movw	%bp,(%edx,%esi,1)
+	movb	%ch,(%edi,%ebx,1)
+L4x4_13:
+	cmpw	%bp,2(%edx,%esi,1)
+	jg		L4x4_14
+	movw	%bp,2(%edx,%esi,1)
+	movb	%ch,1(%edi,%ebx,1)
+L4x4_14:
+	cmpw	%bp,4(%edx,%esi,1)
+	jg		L4x4_15
+	movw	%bp,4(%edx,%esi,1)
+	movb	%ch,2(%edi,%ebx,1)
+L4x4_15:
+	cmpw	%bp,6(%edx,%esi,1)
+	jg		L4x4_16
+	movw	%bp,6(%edx,%esi,1)
+	movb	%ch,3(%edi,%ebx,1)
+L4x4_16:
+
+	popl	%esi
+	jmp		LDone
+
+// default case, handling any size particle
+LDefault:
+
+// count = pix << d_y_aspect_shift;
+
+	movl	%eax,%ebx
+	movl	%eax,DP_Pix
+	movb	C(d_y_aspect_shift),%cl
+	shll	%cl,%ebx
+
+// for ( ; count ; count--, pz += d_zwidth, pdest += screenwidth)
+// {
+// 	for (i=0 ; i<pix ; i++)
+// 	{
+// 		if (pz[i] <= izi)
+// 		{
+// 			pz[i] = izi;
+// 			pdest[i] = color;
+// 		}
+// 	}
+// }
+
+LGenRowLoop:
+	movl	DP_Pix,%eax
+
+LGenColLoop:
+	cmpw	%bp,-2(%edx,%eax,2)
+	jg		LGSkip
+	movw	%bp,-2(%edx,%eax,2)
+	movb	%ch,-1(%edi,%eax,1)
+LGSkip:
+	decl	%eax			// --pix
+	jnz		LGenColLoop
+
+	addl	C(d_zrowbytes),%edx
+	addl	C(screenwidth),%edi
+
+	decl	%ebx			// --count
+	jnz		LGenRowLoop
+
+LDone:
+	popl	%ebx				// restore register variables
+	popl	%edi
+	popl	%ebp				// restore the caller's stack frame
+	ret
+
+LPop6AndDone:
+	fstp	%st(0)
+	fstp	%st(0)
+	fstp	%st(0)
+	fstp	%st(0)
+	fstp	%st(0)
+LPop1AndDone:
+	fstp	%st(0)
+	jmp		LDone
+
+#endif	// id386
diff -ruN WinQuake/d_parta.s sdlquake-1.0.9/d_parta.s
--- WinQuake/d_parta.s	Tue Dec 21 15:53:24 1999
+++ sdlquake-1.0.9/d_parta.s	Wed Dec 31 16:00:00 1969
@@ -1,477 +0,0 @@
-/*
-Copyright (C) 1996-1997 Id Software, Inc.
-
-This program is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License
-as published by the Free Software Foundation; either version 2
-of the License, or (at your option) any later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
-
-See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-*/
-//
-// d_parta.s
-// x86 assembly-language 8-bpp particle-drawing code.
-//
-
-#include "asm_i386.h"
-#include "quakeasm.h"
-#include "d_ifacea.h"
-#include "asm_draw.h"
-
-#if	id386
-
-//----------------------------------------------------------------------
-// 8-bpp particle drawing code.
-//----------------------------------------------------------------------
-
-//FIXME: comments, full optimization
-
-//----------------------------------------------------------------------
-// 8-bpp particle queueing code.
-//----------------------------------------------------------------------
-
-	.text
-
-#define P	12+4
-
-	.align 4
-.globl C(D_DrawParticle)
-C(D_DrawParticle):
-	pushl	%ebp				// preserve caller's stack frame
-	pushl	%edi				// preserve register variables
-	pushl	%ebx
-
-	movl	P(%esp),%edi
-
-// FIXME: better FP overlap in general here
-
-// transform point
-//	VectorSubtract (p->org, r_origin, local);
-	flds	C(r_origin)
-	fsubrs	pt_org(%edi)
-	flds	pt_org+4(%edi)
-	fsubs	C(r_origin)+4
-	flds	pt_org+8(%edi)
-	fsubs	C(r_origin)+8
-	fxch	%st(2)			// local[0] | local[1] | local[2]
-
-//	transformed[2] = DotProduct(local, r_ppn);		
-	flds	C(r_ppn)		// r_ppn[0] | local[0] | local[1] | local[2]
-	fmul	%st(1),%st(0)	// dot0 | local[0] | local[1] | local[2]
-	flds	C(r_ppn)+4	// r_ppn[1] | dot0 | local[0] | local[1] | local[2]
-	fmul	%st(3),%st(0)	// dot1 | dot0 | local[0] | local[1] | local[2]
-	flds	C(r_ppn)+8	// r_ppn[2] | dot1 | dot0 | local[0] |
-						//  local[1] | local[2]
-	fmul	%st(5),%st(0)	// dot2 | dot1 | dot0 | local[0] | local[1] | local[2]
-	fxch	%st(2)		// dot0 | dot1 | dot2 | local[0] | local[1] | local[2]
-	faddp	%st(0),%st(1) // dot0 + dot1 | dot2 | local[0] | local[1] |
-						  //  local[2]
-	faddp	%st(0),%st(1) // z | local[0] | local[1] | local[2]
-	fld		%st(0)		// z | z | local[0] | local[1] |
-						//  local[2]
-	fdivrs	float_1		// 1/z | z | local[0] | local[1] | local[2]
-	fxch	%st(1)		// z | 1/z | local[0] | local[1] | local[2]
-
-//	if (transformed[2] < PARTICLE_Z_CLIP)
-//		return;
-	fcomps	float_particle_z_clip	// 1/z | local[0] | local[1] | local[2]
-	fxch	%st(3)					// local[2] | local[0] | local[1] | 1/z
-
-	flds	C(r_pup)	// r_pup[0] | local[2] | local[0] | local[1] | 1/z
-	fmul	%st(2),%st(0)	// dot0 | local[2] | local[0] | local[1] | 1/z 
-	flds	C(r_pup)+4	// r_pup[1] | dot0 | local[2] | local[0] |
-						//  local[1] | 1/z 
-
-	fnstsw	%ax
-	testb	$1,%ah
-	jnz		LPop6AndDone
-
-//	transformed[1] = DotProduct(local, r_pup);
-	fmul	%st(4),%st(0)	// dot1 | dot0 | local[2] | local[0] | local[1] | 1/z 
-	flds	C(r_pup)+8	// r_pup[2] | dot1 | dot0 | local[2] |
-						//  local[0] | local[1] | 1/z 
-	fmul	%st(3),%st(0)	// dot2 | dot1 | dot0 | local[2] | local[0] |
-						//  local[1] | 1/z 
-	fxch	%st(2)		// dot0 | dot1 | dot2 | local[2] | local[0] |
-						//  local[1] | 1/z 
-	faddp	%st(0),%st(1) // dot0 + dot1 | dot2 | local[2] | local[0] |
-						//  local[1] | 1/z 
-	faddp	%st(0),%st(1) // y | local[2] | local[0] | local[1] | 1/z 
-	fxch	%st(3)		// local[1] | local[2] | local[0] | y | 1/z 
-
-//	transformed[0] = DotProduct(local, r_pright);
-	fmuls	C(r_pright)+4	// dot1 | local[2] | local[0] | y | 1/z
-	fxch	%st(2)		// local[0] | local[2] | dot1 | y | 1/z
-	fmuls	C(r_pright)	// dot0 | local[2] | dot1 | y | 1/z
-	fxch	%st(1)		// local[2] | dot0 | dot1 | y | 1/z
-	fmuls	C(r_pright)+8	// dot2 | dot0 | dot1 | y | 1/z
-	fxch	%st(2)		// dot1 | dot0 | dot2 | y | 1/z
-	faddp	%st(0),%st(1) // dot1 + dot0 | dot2 | y | 1/z
-
-	faddp	%st(0),%st(1)	// x | y | 1/z
-	fxch	%st(1)			// y | x | 1/z
-
-// project the point
-	fmul	%st(2),%st(0)	// y/z | x | 1/z
-	fxch	%st(1)			// x | y/z | 1/z
-	fmul	%st(2),%st(0)	// x/z | y/z | 1/z
-	fxch	%st(1)			// y/z | x/z | 1/z
-	fsubrs	C(ycenter)		// v | x/z | 1/z
-	fxch	%st(1)			// x/z | v | 1/z
-	fadds	C(xcenter)		// u | v | 1/z
-// FIXME: preadjust xcenter and ycenter
-	fxch	%st(1)			// v | u | 1/z
-	fadds	float_point5	// v | u | 1/z
-	fxch	%st(1)			// u | v | 1/z
-	fadds	float_point5	// u | v | 1/z
-	fxch	%st(2)			// 1/z | v | u
-	fmuls	DP_32768		// 1/z * 0x8000 | v | u
-	fxch	%st(2)			// u | v | 1/z * 0x8000
-
-// FIXME: use Terje's fp->int trick here?
-// FIXME: check we're getting proper rounding here
-	fistpl	DP_u			// v | 1/z * 0x8000
-	fistpl	DP_v			// 1/z * 0x8000
-
-	movl	DP_u,%eax
-	movl	DP_v,%edx
-
-// if ((v > d_vrectbottom_particle) || 
-// 	(u > d_vrectright_particle) ||
-// 	(v < d_vrecty) ||
-// 	(u < d_vrectx))
-// {
-// 	continue;
-// }
-
-	movl	C(d_vrectbottom_particle),%ebx
-	movl	C(d_vrectright_particle),%ecx
-	cmpl	%ebx,%edx
-	jg		LPop1AndDone
-	cmpl	%ecx,%eax
-	jg		LPop1AndDone
-	movl	C(d_vrecty),%ebx
-	movl	C(d_vrectx),%ecx
-	cmpl	%ebx,%edx
-	jl		LPop1AndDone
-
-	cmpl	%ecx,%eax
-	jl		LPop1AndDone
-
-	flds	pt_color(%edi)	// color | 1/z * 0x8000
-// FIXME: use Terje's fast fp->int trick?
-	fistpl	DP_Color		// 1/z * 0x8000
-
-	movl	C(d_viewbuffer),%ebx
-
-	addl	%eax,%ebx
-	movl	C(d_scantable)(,%edx,4),%edi		// point to the pixel
-
-	imull	C(d_zrowbytes),%edx		// point to the z pixel
-
-	leal	(%edx,%eax,2),%edx
-	movl	C(d_pzbuffer),%eax
-
-	fistpl	izi
-
-	addl	%ebx,%edi
-	addl	%eax,%edx
-
-// pix = izi >> d_pix_shift;
-
-	movl	izi,%eax
-	movl	C(d_pix_shift),%ecx
-	shrl	%cl,%eax
-	movl	izi,%ebp
-
-// if (pix < d_pix_min)
-// 		pix = d_pix_min;
-// else if (pix > d_pix_max)
-//  	pix = d_pix_max;
-
-	movl	C(d_pix_min),%ebx
-	movl	C(d_pix_max),%ecx
-	cmpl	%ebx,%eax
-	jnl		LTestPixMax
-	movl	%ebx,%eax
-	jmp		LTestDone
-
-LTestPixMax:
-	cmpl	%ecx,%eax
-	jng		LTestDone
-	movl	%ecx,%eax
-LTestDone:
-
-	movb	DP_Color,%ch
-
-	movl	C(d_y_aspect_shift),%ebx
-	testl	%ebx,%ebx
-	jnz		LDefault
-
-	cmpl	$4,%eax
-	ja		LDefault
-
-	jmp		DP_EntryTable-4(,%eax,4)
-
-// 1x1
-.globl	DP_1x1
-DP_1x1:
-	cmpw	%bp,(%edx)		// just one pixel to do
-	jg		LDone
-	movw	%bp,(%edx)
-	movb	%ch,(%edi)
-	jmp		LDone
-
-// 2x2
-.globl	DP_2x2
-DP_2x2:
-	pushl	%esi
-	movl	C(screenwidth),%ebx
-	movl	C(d_zrowbytes),%esi
-
-	cmpw	%bp,(%edx)
-	jg		L2x2_1
-	movw	%bp,(%edx)
-	movb	%ch,(%edi)
-L2x2_1:
-	cmpw	%bp,2(%edx)
-	jg		L2x2_2
-	movw	%bp,2(%edx)
-	movb	%ch,1(%edi)
-L2x2_2:
-	cmpw	%bp,(%edx,%esi,1)
-	jg		L2x2_3
-	movw	%bp,(%edx,%esi,1)
-	movb	%ch,(%edi,%ebx,1)
-L2x2_3:
-	cmpw	%bp,2(%edx,%esi,1)
-	jg		L2x2_4
-	movw	%bp,2(%edx,%esi,1)
-	movb	%ch,1(%edi,%ebx,1)
-L2x2_4:
-
-	popl	%esi
-	jmp		LDone
-
-// 3x3
-.globl	DP_3x3
-DP_3x3:
-	pushl	%esi
-	movl	C(screenwidth),%ebx
-	movl	C(d_zrowbytes),%esi
-
-	cmpw	%bp,(%edx)
-	jg		L3x3_1
-	movw	%bp,(%edx)
-	movb	%ch,(%edi)
-L3x3_1:
-	cmpw	%bp,2(%edx)
-	jg		L3x3_2
-	movw	%bp,2(%edx)
-	movb	%ch,1(%edi)
-L3x3_2:
-	cmpw	%bp,4(%edx)
-	jg		L3x3_3
-	movw	%bp,4(%edx)
-	movb	%ch,2(%edi)
-L3x3_3:
-
-	cmpw	%bp,(%edx,%esi,1)
-	jg		L3x3_4
-	movw	%bp,(%edx,%esi,1)
-	movb	%ch,(%edi,%ebx,1)
-L3x3_4:
-	cmpw	%bp,2(%edx,%esi,1)
-	jg		L3x3_5
-	movw	%bp,2(%edx,%esi,1)
-	movb	%ch,1(%edi,%ebx,1)
-L3x3_5:
-	cmpw	%bp,4(%edx,%esi,1)
-	jg		L3x3_6
-	movw	%bp,4(%edx,%esi,1)
-	movb	%ch,2(%edi,%ebx,1)
-L3x3_6:
-
-	cmpw	%bp,(%edx,%esi,2)
-	jg		L3x3_7
-	movw	%bp,(%edx,%esi,2)
-	movb	%ch,(%edi,%ebx,2)
-L3x3_7:
-	cmpw	%bp,2(%edx,%esi,2)
-	jg		L3x3_8
-	movw	%bp,2(%edx,%esi,2)
-	movb	%ch,1(%edi,%ebx,2)
-L3x3_8:
-	cmpw	%bp,4(%edx,%esi,2)
-	jg		L3x3_9
-	movw	%bp,4(%edx,%esi,2)
-	movb	%ch,2(%edi,%ebx,2)
-L3x3_9:
-
-	popl	%esi
-	jmp		LDone
-
-
-// 4x4
-.globl	DP_4x4
-DP_4x4:
-	pushl	%esi
-	movl	C(screenwidth),%ebx
-	movl	C(d_zrowbytes),%esi
-
-	cmpw	%bp,(%edx)
-	jg		L4x4_1
-	movw	%bp,(%edx)
-	movb	%ch,(%edi)
-L4x4_1:
-	cmpw	%bp,2(%edx)
-	jg		L4x4_2
-	movw	%bp,2(%edx)
-	movb	%ch,1(%edi)
-L4x4_2:
-	cmpw	%bp,4(%edx)
-	jg		L4x4_3
-	movw	%bp,4(%edx)
-	movb	%ch,2(%edi)
-L4x4_3:
-	cmpw	%bp,6(%edx)
-	jg		L4x4_4
-	movw	%bp,6(%edx)
-	movb	%ch,3(%edi)
-L4x4_4:
-
-	cmpw	%bp,(%edx,%esi,1)
-	jg		L4x4_5
-	movw	%bp,(%edx,%esi,1)
-	movb	%ch,(%edi,%ebx,1)
-L4x4_5:
-	cmpw	%bp,2(%edx,%esi,1)
-	jg		L4x4_6
-	movw	%bp,2(%edx,%esi,1)
-	movb	%ch,1(%edi,%ebx,1)
-L4x4_6:
-	cmpw	%bp,4(%edx,%esi,1)
-	jg		L4x4_7
-	movw	%bp,4(%edx,%esi,1)
-	movb	%ch,2(%edi,%ebx,1)
-L4x4_7:
-	cmpw	%bp,6(%edx,%esi,1)
-	jg		L4x4_8
-	movw	%bp,6(%edx,%esi,1)
-	movb	%ch,3(%edi,%ebx,1)
-L4x4_8:
-
-	leal	(%edx,%esi,2),%edx
-	leal	(%edi,%ebx,2),%edi
-
-	cmpw	%bp,(%edx)
-	jg		L4x4_9
-	movw	%bp,(%edx)
-	movb	%ch,(%edi)
-L4x4_9:
-	cmpw	%bp,2(%edx)
-	jg		L4x4_10
-	movw	%bp,2(%edx)
-	movb	%ch,1(%edi)
-L4x4_10:
-	cmpw	%bp,4(%edx)
-	jg		L4x4_11
-	movw	%bp,4(%edx)
-	movb	%ch,2(%edi)
-L4x4_11:
-	cmpw	%bp,6(%edx)
-	jg		L4x4_12
-	movw	%bp,6(%edx)
-	movb	%ch,3(%edi)
-L4x4_12:
-
-	cmpw	%bp,(%edx,%esi,1)
-	jg		L4x4_13
-	movw	%bp,(%edx,%esi,1)
-	movb	%ch,(%edi,%ebx,1)
-L4x4_13:
-	cmpw	%bp,2(%edx,%esi,1)
-	jg		L4x4_14
-	movw	%bp,2(%edx,%esi,1)
-	movb	%ch,1(%edi,%ebx,1)
-L4x4_14:
-	cmpw	%bp,4(%edx,%esi,1)
-	jg		L4x4_15
-	movw	%bp,4(%edx,%esi,1)
-	movb	%ch,2(%edi,%ebx,1)
-L4x4_15:
-	cmpw	%bp,6(%edx,%esi,1)
-	jg		L4x4_16
-	movw	%bp,6(%edx,%esi,1)
-	movb	%ch,3(%edi,%ebx,1)
-L4x4_16:
-
-	popl	%esi
-	jmp		LDone
-
-// default case, handling any size particle
-LDefault:
-
-// count = pix << d_y_aspect_shift;
-
-	movl	%eax,%ebx
-	movl	%eax,DP_Pix
-	movb	C(d_y_aspect_shift),%cl
-	shll	%cl,%ebx
-
-// for ( ; count ; count--, pz += d_zwidth, pdest += screenwidth)
-// {
-// 	for (i=0 ; i<pix ; i++)
-// 	{
-// 		if (pz[i] <= izi)
-// 		{
-// 			pz[i] = izi;
-// 			pdest[i] = color;
-// 		}
-// 	}
-// }
-
-LGenRowLoop:
-	movl	DP_Pix,%eax
-
-LGenColLoop:
-	cmpw	%bp,-2(%edx,%eax,2)
-	jg		LGSkip
-	movw	%bp,-2(%edx,%eax,2)
-	movb	%ch,-1(%edi,%eax,1)
-LGSkip:
-	decl	%eax			// --pix
-	jnz		LGenColLoop
-
-	addl	C(d_zrowbytes),%edx
-	addl	C(screenwidth),%edi
-
-	decl	%ebx			// --count
-	jnz		LGenRowLoop
-
-LDone:
-	popl	%ebx				// restore register variables
-	popl	%edi
-	popl	%ebp				// restore the caller's stack frame
-	ret
-
-LPop6AndDone:
-	fstp	%st(0)
-	fstp	%st(0)
-	fstp	%st(0)
-	fstp	%st(0)
-	fstp	%st(0)
-LPop1AndDone:
-	fstp	%st(0)
-	jmp		LDone
-
-#endif	// id386
diff -ruN WinQuake/d_polysa.S sdlquake-1.0.9/d_polysa.S
--- WinQuake/d_polysa.S	Wed Dec 31 16:00:00 1969
+++ sdlquake-1.0.9/d_polysa.S	Sat Dec 25 03:38:02 1999
@@ -0,0 +1,1744 @@
+/*
+Copyright (C) 1996-1997 Id Software, Inc.
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation; either version 2
+of the License, or (at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
+
+See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+//
+// d_polysa.s
+// x86 assembly-language polygon model drawing code
+//
+
+#include "asm_i386.h"
+#include "quakeasm.h"
+#include "asm_draw.h"
+#include "d_ifacea.h"
+
+#if	id386
+
+// !!! if this is changed, it must be changed in d_polyse.c too !!!
+#define DPS_MAXSPANS			MAXHEIGHT+1	
+									// 1 extra for spanpackage that marks end
+
+//#define	SPAN_SIZE	(((DPS_MAXSPANS + 1 + ((CACHE_SIZE - 1) / spanpackage_t_size)) + 1) * spanpackage_t_size)
+#define SPAN_SIZE (1024+1+1+1)*32
+
+
+	.data
+
+	.align	4
+p10_minus_p20:	.single		0
+p01_minus_p21:	.single		0
+temp0:			.single		0
+temp1:			.single		0
+Ltemp:			.single		0
+
+aff8entryvec_table:	.long	LDraw8, LDraw7, LDraw6, LDraw5
+				.long	LDraw4, LDraw3, LDraw2, LDraw1
+
+lzistepx:		.long	0
+
+
+	.text
+
+#ifndef NeXT
+	.extern C(D_PolysetSetEdgeTable)
+	.extern C(D_RasterizeAliasPolySmooth)
+#endif
+
+//----------------------------------------------------------------------
+// affine triangle gradient calculation code
+//----------------------------------------------------------------------
+
+#define skinwidth	4+0
+
+.globl C(D_PolysetCalcGradients)
+C(D_PolysetCalcGradients):
+
+//	p00_minus_p20 = r_p0[0] - r_p2[0];
+//	p01_minus_p21 = r_p0[1] - r_p2[1];
+//	p10_minus_p20 = r_p1[0] - r_p2[0];
+//	p11_minus_p21 = r_p1[1] - r_p2[1];
+//
+//	xstepdenominv = 1.0 / (p10_minus_p20 * p01_minus_p21 -
+//			     p00_minus_p20 * p11_minus_p21);
+//
+//	ystepdenominv = -xstepdenominv;
+
+	fildl	C(r_p0)+0		// r_p0[0]
+	fildl	C(r_p2)+0		// r_p2[0] | r_p0[0]
+	fildl	C(r_p0)+4		// r_p0[1] | r_p2[0] | r_p0[0]
+	fildl	C(r_p2)+4		// r_p2[1] | r_p0[1] | r_p2[0] | r_p0[0]
+	fildl	C(r_p1)+0		// r_p1[0] | r_p2[1] | r_p0[1] | r_p2[0] | r_p0[0]
+	fildl	C(r_p1)+4		// r_p1[1] | r_p1[0] | r_p2[1] | r_p0[1] |
+							//  r_p2[0] | r_p0[0]
+	fxch	%st(3)			// r_p0[1] | r_p1[0] | r_p2[1] | r_p1[1] |
+							//  r_p2[0] | r_p0[0]
+	fsub	%st(2),%st(0)	// p01_minus_p21 | r_p1[0] | r_p2[1] | r_p1[1] |
+							//  r_p2[0] | r_p0[0]
+	fxch	%st(1)			// r_p1[0] | p01_minus_p21 | r_p2[1] | r_p1[1] |
+							//  r_p2[0] | r_p0[0]
+	fsub	%st(4),%st(0)	// p10_minus_p20 | p01_minus_p21 | r_p2[1] |
+							//  r_p1[1] | r_p2[0] | r_p0[0]
+	fxch	%st(5)			// r_p0[0] | p01_minus_p21 | r_p2[1] |
+							//  r_p1[1] | r_p2[0] | p10_minus_p20
+	fsubp	%st(0),%st(4)	// p01_minus_p21 | r_p2[1] | r_p1[1] |
+							//  p00_minus_p20 | p10_minus_p20
+	fxch	%st(2)			// r_p1[1] | r_p2[1] | p01_minus_p21 |
+							//  p00_minus_p20 | p10_minus_p20
+	fsubp	%st(0),%st(1)	// p11_minus_p21 | p01_minus_p21 |
+							//  p00_minus_p20 | p10_minus_p20
+	fxch	%st(1)			// p01_minus_p21 | p11_minus_p21 |
+							//  p00_minus_p20 | p10_minus_p20
+	flds	C(d_xdenom)		// d_xdenom | p01_minus_p21 | p11_minus_p21 |
+							//  p00_minus_p20 | p10_minus_p20
+	fxch	%st(4)			// p10_minus_p20 | p01_minus_p21 | p11_minus_p21 |
+							//  p00_minus_p20 | d_xdenom
+	fstps	p10_minus_p20	// p01_minus_p21 | p11_minus_p21 |
+							//  p00_minus_p20 | d_xdenom
+	fstps	p01_minus_p21	// p11_minus_p21 | p00_minus_p20 | xstepdenominv
+	fxch	%st(2)			// xstepdenominv | p00_minus_p20 | p11_minus_p21
+
+//// ceil () for light so positive steps are exaggerated, negative steps
+//// diminished,  pushing us away from underflow toward overflow. Underflow is
+//// very visible, overflow is very unlikely, because of ambient lighting
+//	t0 = r_p0[4] - r_p2[4];
+//	t1 = r_p1[4] - r_p2[4];
+
+	fildl	C(r_p2)+16		// r_p2[4] | xstepdenominv | p00_minus_p20 |
+							//  p11_minus_p21
+	fildl	C(r_p0)+16		// r_p0[4] | r_p2[4] | xstepdenominv |
+							//  p00_minus_p20 | p11_minus_p21
+	fildl	C(r_p1)+16		// r_p1[4] | r_p0[4] | r_p2[4] | xstepdenominv |
+							//  p00_minus_p20 | p11_minus_p21
+	fxch	%st(2)			// r_p2[4] | r_p0[4] | r_p1[4] | xstepdenominv |
+							//  p00_minus_p20 | p11_minus_p21
+	fld		%st(0)			// r_p2[4] | r_p2[4] | r_p0[4] | r_p1[4] |
+							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
+	fsubrp	%st(0),%st(2)	// r_p2[4] | t0 | r_p1[4] | xstepdenominv |
+							//  p00_minus_p20 | p11_minus_p21
+	fsubrp	%st(0),%st(2)	// t0 | t1 | xstepdenominv | p00_minus_p20 |
+							//  p11_minus_p21
+
+//	r_lstepx = (int)
+//			ceil((t1 * p01_minus_p21 - t0 * p11_minus_p21) * xstepdenominv);
+//	r_lstepy = (int)
+//			ceil((t1 * p00_minus_p20 - t0 * p10_minus_p20) * ystepdenominv);
+
+	fld		%st(0)			// t0 | t0 | t1 | xstepdenominv | p00_minus_p20 |
+							//  p11_minus_p21
+	fmul	%st(5),%st(0)	// t0*p11_minus_p21 | t0 | t1 | xstepdenominv |
+							//  p00_minus_p20 | p11_minus_p21
+	fxch	%st(2)			// t1 | t0 | t0*p11_minus_p21 | xstepdenominv |
+							//  p00_minus_p20 | p11_minus_p21
+	fld		%st(0)			// t1 | t1 | t0 | t0*p11_minus_p21 |
+							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
+	fmuls	p01_minus_p21	// t1*p01_minus_p21 | t1 | t0 | t0*p11_minus_p21 |
+							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
+	fxch	%st(2)			// t0 | t1 | t1*p01_minus_p21 | t0*p11_minus_p21 |
+							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
+	fmuls	p10_minus_p20	// t0*p10_minus_p20 | t1 | t1*p01_minus_p21 |
+							//  t0*p11_minus_p21 | xstepdenominv |
+							//  p00_minus_p20 | p11_minus_p21
+	fxch	%st(1)			// t1 | t0*p10_minus_p20 | t1*p01_minus_p21 |
+							//  t0*p11_minus_p21 | xstepdenominv |
+							//  p00_minus_p20 | p11_minus_p21
+	fmul	%st(5),%st(0)	// t1*p00_minus_p20 | t0*p10_minus_p20 |
+							//  t1*p01_minus_p21 | t0*p11_minus_p21 |
+							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
+	fxch	%st(2)			// t1*p01_minus_p21 | t0*p10_minus_p20 |
+							//  t1*p00_minus_p20 | t0*p11_minus_p21 |
+							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
+	fsubp	%st(0),%st(3)	// t0*p10_minus_p20 | t1*p00_minus_p20 |
+							//  t1*p01_minus_p21 - t0*p11_minus_p21 |
+							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
+	fsubrp	%st(0),%st(1)	// t1*p00_minus_p20 - t0*p10_minus_p20 |
+							//  t1*p01_minus_p21 - t0*p11_minus_p21 |
+							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
+	fld		%st(2)			// xstepdenominv |
+							//  t1*p00_minus_p20 - t0*p10_minus_p20 |
+							//  t1*p01_minus_p21 - t0*p11_minus_p21 |
+							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
+	fmuls	float_minus_1	// ystepdenominv |
+							//  t1*p00_minus_p20 - t0*p10_minus_p20 |
+							//  t1*p01_minus_p21 - t0*p11_minus_p21 |
+							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
+	fxch	%st(2)			// t1*p01_minus_p21 - t0*p11_minus_p21 |
+							//  t1*p00_minus_p20 - t0*p10_minus_p20 |
+							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
+							//  p11_minus_p21
+	fmul	%st(3),%st(0)	// (t1*p01_minus_p21 - t0*p11_minus_p21)*
+							//   xstepdenominv |
+							//  t1*p00_minus_p20 - t0*p10_minus_p20 |
+							//   | ystepdenominv | xstepdenominv |
+							//   p00_minus_p20 | p11_minus_p21
+	fxch	%st(1)			// t1*p00_minus_p20 - t0*p10_minus_p20 |
+							//  (t1*p01_minus_p21 - t0*p11_minus_p21)*
+							//   xstepdenominv | ystepdenominv |
+							//   xstepdenominv | p00_minus_p20 | p11_minus_p21
+	fmul	%st(2),%st(0)	// (t1*p00_minus_p20 - t0*p10_minus_p20)*
+							//  ystepdenominv |
+							//  (t1*p01_minus_p21 - t0*p11_minus_p21)*
+							//  xstepdenominv | ystepdenominv |
+							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
+	fldcw	ceil_cw
+	fistpl	C(r_lstepy)		// r_lstepx | ystepdenominv | xstepdenominv |
+							//  p00_minus_p20 | p11_minus_p21
+	fistpl	C(r_lstepx)		// ystepdenominv | xstepdenominv | p00_minus_p20 |
+							//  p11_minus_p21
+	fldcw	single_cw
+
+//	t0 = r_p0[2] - r_p2[2];
+//	t1 = r_p1[2] - r_p2[2];
+
+	fildl	C(r_p2)+8		// r_p2[2] | ystepdenominv | xstepdenominv |
+							//  p00_minus_p20 | p11_minus_p21
+	fildl	C(r_p0)+8		// r_p0[2] | r_p2[2] | ystepdenominv |
+							//   xstepdenominv | p00_minus_p20 | p11_minus_p21
+	fildl	C(r_p1)+8		// r_p1[2] | r_p0[2] | r_p2[2] | ystepdenominv |
+							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
+	fxch	%st(2)			// r_p2[2] | r_p0[2] | r_p1[2] | ystepdenominv |
+							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
+	fld		%st(0)			// r_p2[2] | r_p2[2] | r_p0[2] | r_p1[2] |
+							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
+							//  p11_minus_p21
+	fsubrp	%st(0),%st(2)	// r_p2[2] | t0 | r_p1[2] | ystepdenominv |
+							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
+	fsubrp	%st(0),%st(2)	// t0 | t1 | ystepdenominv | xstepdenominv |
+							//  p00_minus_p20 | p11_minus_p21
+
+//	r_sstepx = (int)((t1 * p01_minus_p21 - t0 * p11_minus_p21) *
+//			xstepdenominv);
+//	r_sstepy = (int)((t1 * p00_minus_p20 - t0 * p10_minus_p20) *
+//			ystepdenominv);
+
+	fld		%st(0)			// t0 | t0 | t1 | ystepdenominv | xstepdenominv
+	fmul	%st(6),%st(0)	// t0*p11_minus_p21 | t0 | t1 | ystepdenominv |
+							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
+	fxch	%st(2)			// t1 | t0 | t0*p11_minus_p21 | ystepdenominv |
+							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
+	fld		%st(0)			// t1 | t1 | t0 | t0*p11_minus_p21 |
+							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
+							//  p11_minus_p21
+	fmuls	p01_minus_p21	// t1*p01_minus_p21 | t1 | t0 | t0*p11_minus_p21 |
+							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
+							//  p11_minus_p21
+	fxch	%st(2)			// t0 | t1 | t1*p01_minus_p21 | t0*p11_minus_p21 |
+							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
+							//  p11_minus_p21
+	fmuls	p10_minus_p20	// t0*p10_minus_p20 | t1 | t1*p01_minus_p21 |
+							//  t0*p11_minus_p21 | ystepdenominv |
+							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
+	fxch	%st(1)			// t1 | t0*p10_minus_p20 | t1*p01_minus_p21 |
+							//  t0*p11_minus_p21 | ystepdenominv |
+							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
+	fmul	%st(6),%st(0)	// t1*p00_minus_p20 | t0*p10_minus_p20 |
+							//  t1*p01_minus_p21 | t0*p11_minus_p21 |
+							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
+							//  p11_minus_p21
+	fxch	%st(2)			// t1*p01_minus_p21 | t0*p10_minus_p20 |
+							//  t1*p00_minus_p20 | t0*p11_minus_p21 |
+							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
+							//  p11_minus_p21
+	fsubp	%st(0),%st(3)	// t0*p10_minus_p20 | t1*p00_minus_p20 |
+							//  t1*p01_minus_p21 - t0*p11_minus_p21 |
+							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
+							//  p11_minus_p21
+	fsubrp	%st(0),%st(1)	// t1*p00_minus_p20 - t0*p10_minus_p20 |
+							//  t1*p01_minus_p21 - t0*p11_minus_p21 |
+							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
+							//  p11_minus_p21
+	fmul	%st(2),%st(0)	// (t1*p00_minus_p20 - t0*p10_minus_p20)*
+							//   ystepdenominv |
+							//  t1*p01_minus_p21 - t0*p11_minus_p21 |
+							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
+							//  p11_minus_p21
+	fxch	%st(1)			// t1*p01_minus_p21 - t0*p11_minus_p21 |
+							//  (t1*p00_minus_p20 - t0*p10_minus_p20)*
+							//   ystepdenominv | ystepdenominv |
+							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
+	fmul	%st(3),%st(0)	// (t1*p01_minus_p21 - t0*p11_minus_p21)*
+							//  xstepdenominv |
+							//  (t1*p00_minus_p20 - t0*p10_minus_p20)*
+							//  ystepdenominv | ystepdenominv |
+							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
+	fxch	%st(1)			// (t1*p00_minus_p20 - t0*p10_minus_p20)*
+							//  ystepdenominv |
+							//  (t1*p01_minus_p21 - t0*p11_minus_p21)*
+							//  xstepdenominv | ystepdenominv |
+							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
+	fistpl	C(r_sstepy)		// r_sstepx | ystepdenominv | xstepdenominv |
+							//  p00_minus_p20 | p11_minus_p21
+	fistpl	C(r_sstepx)		// ystepdenominv | xstepdenominv | p00_minus_p20 |
+							//  p11_minus_p21
+
+//	t0 = r_p0[3] - r_p2[3];
+//	t1 = r_p1[3] - r_p2[3];
+
+	fildl	C(r_p2)+12		// r_p2[3] | ystepdenominv | xstepdenominv |
+							//  p00_minus_p20 | p11_minus_p21
+	fildl	C(r_p0)+12		// r_p0[3] | r_p2[3] | ystepdenominv |
+							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
+	fildl	C(r_p1)+12		// r_p1[3] | r_p0[3] | r_p2[3] | ystepdenominv |
+							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
+	fxch	%st(2)			// r_p2[3] | r_p0[3] | r_p1[3] | ystepdenominv |
+							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
+	fld		%st(0)			// r_p2[3] | r_p2[3] | r_p0[3] | r_p1[3] |
+							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
+							//  p11_minus_p21
+	fsubrp	%st(0),%st(2)	// r_p2[3] | t0 | r_p1[3] | ystepdenominv |
+							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
+	fsubrp	%st(0),%st(2)	// t0 | t1 | ystepdenominv | xstepdenominv |
+							//  p00_minus_p20 | p11_minus_p21
+
+//	r_tstepx = (int)((t1 * p01_minus_p21 - t0 * p11_minus_p21) *
+//			xstepdenominv);
+//	r_tstepy = (int)((t1 * p00_minus_p20 - t0 * p10_minus_p20) *
+//			ystepdenominv);
+
+	fld		%st(0)			// t0 | t0 | t1 | ystepdenominv | xstepdenominv |
+							//  p00_minus_p20 | p11_minus_p21
+	fmul	%st(6),%st(0)	// t0*p11_minus_p21 | t0 | t1 | ystepdenominv |
+							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
+	fxch	%st(2)			// t1 | t0 | t0*p11_minus_p21 | ystepdenominv |
+							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
+	fld		%st(0)			// t1 | t1 | t0 | t0*p11_minus_p21 |
+							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
+							//  p11_minus_p21
+	fmuls	p01_minus_p21	// t1*p01_minus_p21 | t1 | t0 | t0*p11_minus_p21 |
+							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
+							//  p11_minus_p21
+	fxch	%st(2)			// t0 | t1 | t1*p01_minus_p21 | t0*p11_minus_p21 |
+							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
+							//  p11_minus_p21
+	fmuls	p10_minus_p20	// t0*p10_minus_p20 | t1 | t1*p01_minus_p21 |
+							//  t0*p11_minus_p21 | ystepdenominv |
+							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
+	fxch	%st(1)			// t1 | t0*p10_minus_p20 | t1*p01_minus_p21 |
+							//  t0*p11_minus_p21 | ystepdenominv |
+							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
+	fmul	%st(6),%st(0)	// t1*p00_minus_p20 | t0*p10_minus_p20 |
+							//  t1*p01_minus_p21 | t0*p11_minus_p21 |
+							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
+							//  p11_minus_p21
+	fxch	%st(2)			// t1*p01_minus_p21 | t0*p10_minus_p20 |
+							//  t1*p00_minus_p20 | t0*p11_minus_p21 |
+							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
+							//  p11_minus_p21
+	fsubp	%st(0),%st(3)	// t0*p10_minus_p20 | t1*p00_minus_p20 |
+							//  t1*p01_minus_p21 - t0*p11_minus_p21 |
+							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
+							//  p11_minus_p21
+	fsubrp	%st(0),%st(1)	// t1*p00_minus_p20 - t0*p10_minus_p20 |
+							//  t1*p01_minus_p21 - t0*p11_minus_p21 |
+							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
+							//  p11_minus_p21
+	fmul	%st(2),%st(0)	// (t1*p00_minus_p20 - t0*p10_minus_p20)*
+							//   ystepdenominv |
+							//  t1*p01_minus_p21 - t0*p11_minus_p21 |
+							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
+							//  p11_minus_p21
+	fxch	%st(1)			// t1*p01_minus_p21 - t0*p11_minus_p21 |
+							//  (t1*p00_minus_p20 - t0*p10_minus_p20)*
+							//  ystepdenominv | ystepdenominv |
+							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
+	fmul	%st(3),%st(0)	// (t1*p01_minus_p21 - t0*p11_minus_p21)*
+							//  xstepdenominv |
+							//  (t1*p00_minus_p20 - t0*p10_minus_p20)*
+							//  ystepdenominv | ystepdenominv |
+							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
+	fxch	%st(1)			// (t1*p00_minus_p20 - t0*p10_minus_p20)*
+							//  ystepdenominv |
+							//  (t1*p01_minus_p21 - t0*p11_minus_p21)*
+							//  xstepdenominv | ystepdenominv |
+							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
+	fistpl	C(r_tstepy)		// r_tstepx | ystepdenominv | xstepdenominv |
+							//  p00_minus_p20 | p11_minus_p21
+	fistpl	C(r_tstepx)		// ystepdenominv | xstepdenominv | p00_minus_p20 |
+							//  p11_minus_p21
+
+//	t0 = r_p0[5] - r_p2[5];
+//	t1 = r_p1[5] - r_p2[5];
+
+	fildl	C(r_p2)+20		// r_p2[5] | ystepdenominv | xstepdenominv |
+							//  p00_minus_p20 | p11_minus_p21
+	fildl	C(r_p0)+20		// r_p0[5] | r_p2[5] | ystepdenominv |
+							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
+	fildl	C(r_p1)+20		// r_p1[5] | r_p0[5] | r_p2[5] | ystepdenominv |
+							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
+	fxch	%st(2)			// r_p2[5] | r_p0[5] | r_p1[5] | ystepdenominv |
+							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
+	fld		%st(0)			// r_p2[5] | r_p2[5] | r_p0[5] | r_p1[5] |
+							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
+							//  p11_minus_p21
+	fsubrp	%st(0),%st(2)	// r_p2[5] | t0 | r_p1[5] | ystepdenominv |
+							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
+	fsubrp	%st(0),%st(2)	// t0 | t1 | ystepdenominv | xstepdenominv |
+							//  p00_minus_p20 | p11_minus_p21
+
+//	r_zistepx = (int)((t1 * p01_minus_p21 - t0 * p11_minus_p21) *
+//			xstepdenominv);
+//	r_zistepy = (int)((t1 * p00_minus_p20 - t0 * p10_minus_p20) *
+//			ystepdenominv);
+
+	fld		%st(0)			// t0 | t0 | t1 | ystepdenominv | xstepdenominv |
+							//  p00_minus_p20 | p11_minus_p21
+	fmulp	%st(0),%st(6)	// t0 | t1 | ystepdenominv | xstepdenominv |
+							//  p00_minus_p20 | t0*p11_minus_p21
+	fxch	%st(1)			// t1 | t0 | ystepdenominv | xstepdenominv |
+							//  p00_minus_p20 | t0*p11_minus_p21
+	fld		%st(0)			// t1 | t1 | t0 | ystepdenominv | xstepdenominv |
+							//  p00_minus_p20 | t0*p11_minus_p21
+	fmuls	p01_minus_p21	// t1*p01_minus_p21 | t1 | t0 | ystepdenominv |
+							//  xstepdenominv | p00_minus_p20 |
+							//  t0*p11_minus_p21
+	fxch	%st(2)			// t0 | t1 | t1*p01_minus_p21 | ystepdenominv |
+							//  xstepdenominv | p00_minus_p20 |
+							//  t0*p11_minus_p21
+	fmuls	p10_minus_p20	// t0*p10_minus_p20 | t1 | t1*p01_minus_p21 |
+							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
+							//  t0*p11_minus_p21
+	fxch	%st(1)			// t1 | t0*p10_minus_p20 | t1*p01_minus_p21 |
+							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
+							//  t0*p11_minus_p21
+	fmulp	%st(0),%st(5)	// t0*p10_minus_p20 | t1*p01_minus_p21 |
+							//  ystepdenominv | xstepdenominv |
+							//  t1*p00_minus_p20 | t0*p11_minus_p21
+	fxch	%st(5)			// t0*p11_minus_p21 | t1*p01_minus_p21 |
+							//  ystepdenominv | xstepdenominv |
+							//  t1*p00_minus_p20 | t0*p10_minus_p20
+	fsubrp	%st(0),%st(1)	// t1*p01_minus_p21 - t0*p11_minus_p21 |
+							//  ystepdenominv | xstepdenominv |
+							//  t1*p00_minus_p20 | t0*p10_minus_p20
+	fxch	%st(3)			// t1*p00_minus_p20 | ystepdenominv |
+							//  xstepdenominv |
+							//  t1*p01_minus_p21 - t0*p11_minus_p21 |
+							//  t0*p10_minus_p20
+	fsubp	%st(0),%st(4)	// ystepdenominv | xstepdenominv |
+							//  t1*p01_minus_p21 - t0*p11_minus_p21 |
+							//  t1*p00_minus_p20 - t0*p10_minus_p20
+	fxch	%st(1)			// xstepdenominv | ystepdenominv |
+							//  t1*p01_minus_p21 - t0*p11_minus_p21 |
+							//  t1*p00_minus_p20 - t0*p10_minus_p20
+	fmulp	%st(0),%st(2)	// ystepdenominv |
+							//  (t1*p01_minus_p21 - t0*p11_minus_p21) *
+							//  xstepdenominv |
+							//  t1*p00_minus_p20 - t0*p10_minus_p20
+	fmulp	%st(0),%st(2)	// (t1*p01_minus_p21 - t0*p11_minus_p21) *
+							//  xstepdenominv |
+							//  (t1*p00_minus_p20 - t0*p10_minus_p20) *
+							//  ystepdenominv
+	fistpl	C(r_zistepx)	// (t1*p00_minus_p20 - t0*p10_minus_p20) *
+							//  ystepdenominv
+	fistpl	C(r_zistepy)
+
+//	a_sstepxfrac = r_sstepx << 16;
+//	a_tstepxfrac = r_tstepx << 16;
+//
+//	a_ststepxwhole = r_affinetridesc.skinwidth * (r_tstepx >> 16) +
+//			(r_sstepx >> 16);
+
+	movl	C(r_sstepx),%eax
+	movl	C(r_tstepx),%edx
+	shll	$16,%eax
+	shll	$16,%edx
+	movl	%eax,C(a_sstepxfrac)
+	movl	%edx,C(a_tstepxfrac)
+
+	movl	C(r_sstepx),%ecx
+	movl	C(r_tstepx),%eax
+	sarl	$16,%ecx
+	sarl	$16,%eax
+	imull	skinwidth(%esp)
+	addl	%ecx,%eax
+	movl	%eax,C(a_ststepxwhole)
+
+	ret
+
+
+//----------------------------------------------------------------------
+// recursive subdivision affine triangle drawing code
+//
+// not C-callable because of stdcall return
+//----------------------------------------------------------------------
+
+#define lp1	4+16
+#define lp2	8+16
+#define lp3	12+16
+
+.globl C(D_PolysetRecursiveTriangle)
+C(D_PolysetRecursiveTriangle):
+	pushl	%ebp				// preserve caller stack frame pointer
+	pushl	%esi				// preserve register variables
+	pushl	%edi
+	pushl	%ebx
+
+//	int		*temp;
+//	int		d;
+//	int		new[6];
+//	int		i;
+//	int		z;
+//	short	*zbuf;
+	movl	lp2(%esp),%esi
+	movl	lp1(%esp),%ebx
+	movl	lp3(%esp),%edi
+
+//	d = lp2[0] - lp1[0];
+//	if (d < -1 || d > 1)
+//		goto split;
+	movl	0(%esi),%eax
+
+	movl	0(%ebx),%edx
+	movl	4(%esi),%ebp
+
+	subl	%edx,%eax
+	movl	4(%ebx),%ecx
+
+	subl	%ecx,%ebp
+	incl	%eax
+
+	cmpl	$2,%eax
+	ja		LSplit
+
+//	d = lp2[1] - lp1[1];
+//	if (d < -1 || d > 1)
+//		goto split;
+	movl	0(%edi),%eax
+	incl	%ebp
+
+	cmpl	$2,%ebp
+	ja		LSplit
+
+//	d = lp3[0] - lp2[0];
+//	if (d < -1 || d > 1)
+//		goto split2;
+	movl	0(%esi),%edx
+	movl	4(%edi),%ebp
+
+	subl	%edx,%eax
+	movl	4(%esi),%ecx
+
+	subl	%ecx,%ebp
+	incl	%eax
+
+	cmpl	$2,%eax
+	ja		LSplit2
+
+//	d = lp3[1] - lp2[1];
+//	if (d < -1 || d > 1)
+//		goto split2;
+	movl	0(%ebx),%eax
+	incl	%ebp
+
+	cmpl	$2,%ebp
+	ja		LSplit2
+
+//	d = lp1[0] - lp3[0];
+//	if (d < -1 || d > 1)
+//		goto split3;
+	movl	0(%edi),%edx
+	movl	4(%ebx),%ebp
+
+	subl	%edx,%eax
+	movl	4(%edi),%ecx
+
+	subl	%ecx,%ebp
+	incl	%eax
+
+	incl	%ebp
+	movl	%ebx,%edx
+
+	cmpl	$2,%eax
+	ja		LSplit3
+
+//	d = lp1[1] - lp3[1];
+//	if (d < -1 || d > 1)
+//	{
+//split3:
+//		temp = lp1;
+//		lp3 = lp2;
+//		lp1 = lp3;
+//		lp2 = temp;
+//		goto split;
+//	}
+//
+//	return;			// entire tri is filled
+//
+	cmpl	$2,%ebp
+	jna		LDone
+
+LSplit3:
+	movl	%edi,%ebx
+	movl	%esi,%edi
+	movl	%edx,%esi
+	jmp		LSplit
+
+//split2:
+LSplit2:
+
+//	temp = lp1;
+//	lp1 = lp2;
+//	lp2 = lp3;
+//	lp3 = temp;
+	movl	%ebx,%eax
+	movl	%esi,%ebx
+	movl	%edi,%esi
+	movl	%eax,%edi
+
+//split:
+LSplit:
+
+	subl	$24,%esp		// allocate space for a new vertex
+
+//// split this edge
+//	new[0] = (lp1[0] + lp2[0]) >> 1;
+//	new[1] = (lp1[1] + lp2[1]) >> 1;
+//	new[2] = (lp1[2] + lp2[2]) >> 1;
+//	new[3] = (lp1[3] + lp2[3]) >> 1;
+//	new[5] = (lp1[5] + lp2[5]) >> 1;
+	movl	8(%ebx),%eax
+
+	movl	8(%esi),%edx
+	movl	12(%ebx),%ecx
+
+	addl	%edx,%eax
+	movl	12(%esi),%edx
+
+	sarl	$1,%eax
+	addl	%edx,%ecx
+
+	movl	%eax,8(%esp)
+	movl	20(%ebx),%eax
+
+	sarl	$1,%ecx
+	movl	20(%esi),%edx
+
+	movl	%ecx,12(%esp)
+	addl	%edx,%eax
+
+	movl	0(%ebx),%ecx
+	movl	0(%esi),%edx
+
+	sarl	$1,%eax
+	addl	%ecx,%edx
+
+	movl	%eax,20(%esp)
+	movl	4(%ebx),%eax
+
+	sarl	$1,%edx
+	movl	4(%esi),%ebp
+
+	movl	%edx,0(%esp)
+	addl	%eax,%ebp
+
+	sarl	$1,%ebp
+	movl	%ebp,4(%esp)
+
+//// draw the point if splitting a leading edge
+//	if (lp2[1] > lp1[1])
+//		goto nodraw;
+	cmpl	%eax,4(%esi)
+	jg		LNoDraw
+
+//	if ((lp2[1] == lp1[1]) && (lp2[0] < lp1[0]))
+//		goto nodraw;
+	movl	0(%esi),%edx
+	jnz		LDraw
+
+	cmpl	%ecx,%edx
+	jl		LNoDraw
+
+LDraw:
+
+// z = new[5] >> 16;
+	movl	20(%esp),%edx
+	movl	4(%esp),%ecx
+
+	sarl	$16,%edx
+	movl	0(%esp),%ebp
+
+//	zbuf = zspantable[new[1]] + new[0];
+	movl	C(zspantable)(,%ecx,4),%eax
+
+//	if (z >= *zbuf)
+//	{
+	cmpw	(%eax,%ebp,2),%dx
+	jnge	LNoDraw
+
+//		int		pix;
+//		
+//		*zbuf = z;
+	movw	%dx,(%eax,%ebp,2)
+
+//		pix = d_pcolormap[skintable[new[3]>>16][new[2]>>16]];
+	movl	12(%esp),%eax
+
+	sarl	$16,%eax
+	movl	8(%esp),%edx
+
+	sarl	$16,%edx
+	subl	%ecx,%ecx
+
+	movl	C(skintable)(,%eax,4),%eax
+	movl	4(%esp),%ebp
+
+	movb	(%eax,%edx,),%cl
+	movl	C(d_pcolormap),%edx
+
+	movb	(%edx,%ecx,),%dl
+	movl	0(%esp),%ecx
+
+//		d_viewbuffer[d_scantable[new[1]] + new[0]] = pix;
+	movl	C(d_scantable)(,%ebp,4),%eax
+	addl	%eax,%ecx
+	movl	C(d_viewbuffer),%eax
+	movb	%dl,(%eax,%ecx,1)
+
+//	}
+//
+//nodraw:
+LNoDraw:
+
+//// recursively continue
+//	D_PolysetRecursiveTriangle (lp3, lp1, new);
+	pushl	%esp
+	pushl	%ebx
+	pushl	%edi
+	call	C(D_PolysetRecursiveTriangle)
+
+//	D_PolysetRecursiveTriangle (lp3, new, lp2);
+	movl	%esp,%ebx
+	pushl	%esi
+	pushl	%ebx
+	pushl	%edi
+	call	C(D_PolysetRecursiveTriangle)
+	addl	$24,%esp
+
+LDone:
+	popl	%ebx				// restore register variables
+	popl	%edi
+	popl	%esi
+	popl	%ebp				// restore caller stack frame pointer
+	ret		$12
+
+
+//----------------------------------------------------------------------
+// 8-bpp horizontal span drawing code for affine polygons, with smooth
+// shading and no transparency
+//----------------------------------------------------------------------
+
+#define pspans	4+8
+
+.globl C(D_PolysetAff8Start)
+C(D_PolysetAff8Start):
+
+.globl C(D_PolysetDrawSpans8)
+C(D_PolysetDrawSpans8):
+	pushl	%esi				// preserve register variables
+	pushl	%ebx
+
+	movl	pspans(%esp),%esi	// point to the first span descriptor
+	movl	C(r_zistepx),%ecx
+
+	pushl	%ebp				// preserve caller's stack frame
+	pushl	%edi
+
+	rorl	$16,%ecx			// put high 16 bits of 1/z step in low word
+	movl	spanpackage_t_count(%esi),%edx
+
+	movl	%ecx,lzistepx
+
+LSpanLoop:
+
+//		lcount = d_aspancount - pspanpackage->count;
+//
+//		errorterm += erroradjustup;
+//		if (errorterm >= 0)
+//		{
+//			d_aspancount += d_countextrastep;
+//			errorterm -= erroradjustdown;
+//		}
+//		else
+//		{
+//			d_aspancount += ubasestep;
+//		}
+	movl	C(d_aspancount),%eax
+	subl	%edx,%eax
+
+	movl	C(erroradjustup),%edx
+	movl	C(errorterm),%ebx
+	addl	%edx,%ebx
+	js		LNoTurnover
+
+	movl	C(erroradjustdown),%edx
+	movl	C(d_countextrastep),%edi
+	subl	%edx,%ebx
+	movl	C(d_aspancount),%ebp
+	movl	%ebx,C(errorterm)
+	addl	%edi,%ebp
+	movl	%ebp,C(d_aspancount)
+	jmp		LRightEdgeStepped
+
+LNoTurnover:
+	movl	C(d_aspancount),%edi
+	movl	C(ubasestep),%edx
+	movl	%ebx,C(errorterm)
+	addl	%edx,%edi
+	movl	%edi,C(d_aspancount)
+
+LRightEdgeStepped:
+	cmpl	$1,%eax
+
+	jl		LNextSpan
+	jz		LExactlyOneLong
+
+//
+// set up advancetable
+//
+	movl	C(a_ststepxwhole),%ecx
+	movl	C(r_affinetridesc)+atd_skinwidth,%edx
+
+	movl	%ecx,advancetable+4	// advance base in t
+	addl	%edx,%ecx
+
+	movl	%ecx,advancetable	// advance extra in t
+	movl	C(a_tstepxfrac),%ecx
+
+	movw	C(r_lstepx),%cx
+	movl	%eax,%edx			// count
+
+	movl	%ecx,tstep
+	addl	$7,%edx
+
+	shrl	$3,%edx				// count of full and partial loops
+	movl	spanpackage_t_sfrac(%esi),%ebx
+
+	movw	%dx,%bx
+	movl	spanpackage_t_pz(%esi),%ecx
+
+	negl	%eax
+
+	movl	spanpackage_t_pdest(%esi),%edi
+	andl	$7,%eax		// 0->0, 1->7, 2->6, ... , 7->1
+
+	subl	%eax,%edi	// compensate for hardwired offsets
+	subl	%eax,%ecx
+
+	subl	%eax,%ecx
+	movl	spanpackage_t_tfrac(%esi),%edx
+
+	movw	spanpackage_t_light(%esi),%dx
+	movl	spanpackage_t_zi(%esi),%ebp
+
+	rorl	$16,%ebp	// put high 16 bits of 1/z in low word
+	pushl	%esi
+
+	movl	spanpackage_t_ptex(%esi),%esi
+	jmp		aff8entryvec_table(,%eax,4)
+
+// %bx = count of full and partial loops
+// %ebx high word = sfrac
+// %ecx = pz
+// %dx = light
+// %edx high word = tfrac
+// %esi = ptex
+// %edi = pdest
+// %ebp = 1/z
+// tstep low word = C(r_lstepx)
+// tstep high word = C(a_tstepxfrac)
+// C(a_sstepxfrac) low word = 0
+// C(a_sstepxfrac) high word = C(a_sstepxfrac)
+
+LDrawLoop:
+
+// FIXME: do we need to clamp light? We may need at least a buffer bit to
+// keep it from poking into tfrac and causing problems
+
+LDraw8:
+	cmpw	(%ecx),%bp
+	jl		Lp1
+	xorl	%eax,%eax
+	movb	%dh,%ah
+	movb	(%esi),%al
+	movw	%bp,(%ecx)
+	movb	0x12345678(%eax),%al
+LPatch8:
+	movb	%al,(%edi)
+Lp1:
+	addl	tstep,%edx
+	sbbl	%eax,%eax
+	addl	lzistepx,%ebp
+	adcl	$0,%ebp
+	addl	C(a_sstepxfrac),%ebx
+	adcl	advancetable+4(,%eax,4),%esi
+
+LDraw7:
+	cmpw	2(%ecx),%bp
+	jl		Lp2
+	xorl	%eax,%eax
+	movb	%dh,%ah
+	movb	(%esi),%al
+	movw	%bp,2(%ecx)
+	movb	0x12345678(%eax),%al
+LPatch7:
+	movb	%al,1(%edi)
+Lp2:
+	addl	tstep,%edx
+	sbbl	%eax,%eax
+	addl	lzistepx,%ebp
+	adcl	$0,%ebp
+	addl	C(a_sstepxfrac),%ebx
+	adcl	advancetable+4(,%eax,4),%esi
+
+LDraw6:
+	cmpw	4(%ecx),%bp
+	jl		Lp3
+	xorl	%eax,%eax
+	movb	%dh,%ah
+	movb	(%esi),%al
+	movw	%bp,4(%ecx)
+	movb	0x12345678(%eax),%al
+LPatch6:
+	movb	%al,2(%edi)
+Lp3:
+	addl	tstep,%edx
+	sbbl	%eax,%eax
+	addl	lzistepx,%ebp
+	adcl	$0,%ebp
+	addl	C(a_sstepxfrac),%ebx
+	adcl	advancetable+4(,%eax,4),%esi
+
+LDraw5:
+	cmpw	6(%ecx),%bp
+	jl		Lp4
+	xorl	%eax,%eax
+	movb	%dh,%ah
+	movb	(%esi),%al
+	movw	%bp,6(%ecx)
+	movb	0x12345678(%eax),%al
+LPatch5:
+	movb	%al,3(%edi)
+Lp4:
+	addl	tstep,%edx
+	sbbl	%eax,%eax
+	addl	lzistepx,%ebp
+	adcl	$0,%ebp
+	addl	C(a_sstepxfrac),%ebx
+	adcl	advancetable+4(,%eax,4),%esi
+
+LDraw4:
+	cmpw	8(%ecx),%bp
+	jl		Lp5
+	xorl	%eax,%eax
+	movb	%dh,%ah
+	movb	(%esi),%al
+	movw	%bp,8(%ecx)
+	movb	0x12345678(%eax),%al
+LPatch4:
+	movb	%al,4(%edi)
+Lp5:
+	addl	tstep,%edx
+	sbbl	%eax,%eax
+	addl	lzistepx,%ebp
+	adcl	$0,%ebp
+	addl	C(a_sstepxfrac),%ebx
+	adcl	advancetable+4(,%eax,4),%esi
+
+LDraw3:
+	cmpw	10(%ecx),%bp
+	jl		Lp6
+	xorl	%eax,%eax
+	movb	%dh,%ah
+	movb	(%esi),%al
+	movw	%bp,10(%ecx)
+	movb	0x12345678(%eax),%al
+LPatch3:
+	movb	%al,5(%edi)
+Lp6:
+	addl	tstep,%edx
+	sbbl	%eax,%eax
+	addl	lzistepx,%ebp
+	adcl	$0,%ebp
+	addl	C(a_sstepxfrac),%ebx
+	adcl	advancetable+4(,%eax,4),%esi
+
+LDraw2:
+	cmpw	12(%ecx),%bp
+	jl		Lp7
+	xorl	%eax,%eax
+	movb	%dh,%ah
+	movb	(%esi),%al
+	movw	%bp,12(%ecx)
+	movb	0x12345678(%eax),%al
+LPatch2:
+	movb	%al,6(%edi)
+Lp7:
+	addl	tstep,%edx
+	sbbl	%eax,%eax
+	addl	lzistepx,%ebp
+	adcl	$0,%ebp
+	addl	C(a_sstepxfrac),%ebx
+	adcl	advancetable+4(,%eax,4),%esi
+
+LDraw1:
+	cmpw	14(%ecx),%bp
+	jl		Lp8
+	xorl	%eax,%eax
+	movb	%dh,%ah
+	movb	(%esi),%al
+	movw	%bp,14(%ecx)
+	movb	0x12345678(%eax),%al
+LPatch1:
+	movb	%al,7(%edi)
+Lp8:
+	addl	tstep,%edx
+	sbbl	%eax,%eax
+	addl	lzistepx,%ebp
+	adcl	$0,%ebp
+	addl	C(a_sstepxfrac),%ebx
+	adcl	advancetable+4(,%eax,4),%esi
+
+	addl	$8,%edi
+	addl	$16,%ecx
+
+	decw	%bx
+	jnz		LDrawLoop
+
+	popl	%esi				// restore spans pointer
+LNextSpan:
+	addl	$(spanpackage_t_size),%esi	// point to next span
+LNextSpanESISet:
+	movl	spanpackage_t_count(%esi),%edx
+	cmpl	$-999999,%edx		// any more spans?
+	jnz		LSpanLoop			// yes
+
+	popl	%edi
+	popl	%ebp				// restore the caller's stack frame
+	popl	%ebx				// restore register variables
+	popl	%esi
+	ret
+
+
+// draw a one-long span
+
+LExactlyOneLong:
+
+	movl	spanpackage_t_pz(%esi),%ecx
+	movl	spanpackage_t_zi(%esi),%ebp
+
+	rorl	$16,%ebp	// put high 16 bits of 1/z in low word
+	movl	spanpackage_t_ptex(%esi),%ebx
+
+	cmpw	(%ecx),%bp
+	jl		LNextSpan
+	xorl	%eax,%eax
+	movl	spanpackage_t_pdest(%esi),%edi
+	movb	spanpackage_t_light+1(%esi),%ah
+	addl	$(spanpackage_t_size),%esi	// point to next span
+	movb	(%ebx),%al
+	movw	%bp,(%ecx)
+	movb	0x12345678(%eax),%al
+LPatch9:
+	movb	%al,(%edi)
+
+	jmp		LNextSpanESISet
+
+.globl C(D_PolysetAff8End)
+C(D_PolysetAff8End):
+
+
+#define pcolormap		4
+
+.globl C(D_Aff8Patch)
+C(D_Aff8Patch):
+	movl	pcolormap(%esp),%eax
+	movl	%eax,LPatch1-4
+	movl	%eax,LPatch2-4
+	movl	%eax,LPatch3-4
+	movl	%eax,LPatch4-4
+	movl	%eax,LPatch5-4
+	movl	%eax,LPatch6-4
+	movl	%eax,LPatch7-4
+	movl	%eax,LPatch8-4
+	movl	%eax,LPatch9-4
+
+	ret
+
+
+//----------------------------------------------------------------------
+// Alias model polygon dispatching code, combined with subdivided affine
+// triangle drawing code
+//----------------------------------------------------------------------
+
+.globl C(D_PolysetDraw)
+C(D_PolysetDraw):
+
+//	spanpackage_t	spans[DPS_MAXSPANS + 1 +
+//			((CACHE_SIZE - 1) / sizeof(spanpackage_t)) + 1];
+//						// one extra because of cache line pretouching
+//
+//	a_spans = (spanpackage_t *)
+//			(((long)&spans[0] + CACHE_SIZE - 1) & ~(CACHE_SIZE - 1));
+	subl	$(SPAN_SIZE),%esp
+	movl	%esp,%eax
+	addl	$(CACHE_SIZE - 1),%eax
+	andl	$(~(CACHE_SIZE - 1)),%eax
+	movl	%eax,C(a_spans)
+
+//	if (r_affinetridesc.drawtype)
+//		D_DrawSubdiv ();
+//	else
+//		D_DrawNonSubdiv ();
+	movl	C(r_affinetridesc)+atd_drawtype,%eax
+	testl	%eax,%eax
+	jz		C(D_DrawNonSubdiv)
+
+	pushl	%ebp				// preserve caller stack frame pointer
+
+//	lnumtriangles = r_affinetridesc.numtriangles;
+	movl	C(r_affinetridesc)+atd_numtriangles,%ebp
+
+	pushl	%esi				// preserve register variables
+	shll	$4,%ebp
+
+	pushl	%ebx
+//	ptri = r_affinetridesc.ptriangles;
+	movl	C(r_affinetridesc)+atd_ptriangles,%ebx
+
+	pushl	%edi
+
+//	mtriangle_t		*ptri;
+//	finalvert_t		*pfv, *index0, *index1, *index2;
+//	int				i;
+//	int				lnumtriangles;
+//	int				s0, s1, s2;
+
+//	pfv = r_affinetridesc.pfinalverts;
+	movl	C(r_affinetridesc)+atd_pfinalverts,%edi
+
+//	for (i=0 ; i<lnumtriangles ; i++)
+//	{
+
+Llooptop:
+
+//		index0 = pfv + ptri[i].vertindex[0];
+//		index1 = pfv + ptri[i].vertindex[1];
+//		index2 = pfv + ptri[i].vertindex[2];
+	movl	mtri_vertindex-16+0(%ebx,%ebp,),%ecx
+	movl	mtri_vertindex-16+4(%ebx,%ebp,),%esi
+
+	shll	$(fv_shift),%ecx
+	movl	mtri_vertindex-16+8(%ebx,%ebp,),%edx
+
+	shll	$(fv_shift),%esi
+	addl	%edi,%ecx
+
+	shll	$(fv_shift),%edx
+	addl	%edi,%esi
+
+	addl	%edi,%edx
+
+//		if (((index0->v[1]-index1->v[1]) *
+//				(index0->v[0]-index2->v[0]) -
+//				(index0->v[0]-index1->v[0])*(index0->v[1]-index2->v[1])) >= 0)
+//		{
+//			continue;
+//		}
+//
+//		d_pcolormap = &((byte *)acolormap)[index0->v[4] & 0xFF00];
+	fildl	fv_v+4(%ecx)	// i0v1
+	fildl	fv_v+4(%esi)	// i1v1 | i0v1
+	fildl	fv_v+0(%ecx)	// i0v0 | i1v1 | i0v1
+	fildl	fv_v+0(%edx)	// i2v0 | i0v0 | i1v1 | i0v1
+	fxch	%st(2)			// i1v1 | i0v0 | i2v0 | i0v1
+	fsubr	%st(3),%st(0)	// i0v1-i1v1 | i0v0 | i2v0 | i0v1
+	fildl	fv_v+0(%esi)	// i1v0 | i0v1-i1v1 | i0v0 | i2v0 | i0v1
+	fxch	%st(2)			// i0v0 | i0v1-i1v1 | i1v0 | i2v0 | i0v1
+	fsub	%st(0),%st(3)	// i0v0 | i0v1-i1v1 | i1v0 | i0v0-i2v0 | i0v1
+	fildl	fv_v+4(%edx)	// i2v1 | i0v0 | i0v1-i1v1 | i1v0 | i0v0-i2v0| i0v1
+	fxch	%st(1)			// i0v0 | i2v1 | i0v1-i1v1 | i1v0 | i0v0-i2v0| i0v1
+	fsubp	%st(0),%st(3)	// i2v1 | i0v1-i1v1 | i0v0-i1v0 | i0v0-i2v0 | i0v1
+	fxch	%st(1)			// i0v1-i1v1 | i2v1 | i0v0-i1v0 | i0v0-i2v0 | i0v1
+	fmulp	%st(0),%st(3)	// i2v1 | i0v0-i1v0 | i0v1-i1v1*i0v0-i2v0 | i0v1
+	fsubrp	%st(0),%st(3)	// i0v0-i1v0 | i0v1-i1v1*i0v0-i2v0 | i0v1-i2v1
+	movl	fv_v+16(%ecx),%eax
+	andl	$0xFF00,%eax
+	fmulp	%st(0),%st(2)	// i0v1-i1v1*i0v0-i2v0 | i0v0-i1v0*i0v1-i2v1
+	addl	C(acolormap),%eax
+	fsubp	%st(0),%st(1)	// (i0v1-i1v1)*(i0v0-i2v0)-(i0v0-i1v0)*(i0v1-i2v1)
+	movl	%eax,C(d_pcolormap)
+	fstps	Ltemp
+	movl	Ltemp,%eax
+	subl	$0x80000001,%eax
+	jc		Lskip
+
+//		if (ptri[i].facesfront)
+//		{
+//			D_PolysetRecursiveTriangle(index0->v, index1->v, index2->v);
+	movl	mtri_facesfront-16(%ebx,%ebp,),%eax
+	testl	%eax,%eax
+	jz		Lfacesback
+
+	pushl	%edx
+	pushl	%esi
+	pushl	%ecx
+	call	C(D_PolysetRecursiveTriangle)
+
+	subl	$16,%ebp
+	jnz		Llooptop
+	jmp		Ldone2
+
+//		}
+//		else
+//		{
+Lfacesback:
+
+//			s0 = index0->v[2];
+//			s1 = index1->v[2];
+//			s2 = index2->v[2];
+	movl	fv_v+8(%ecx),%eax
+	pushl	%eax
+	movl	fv_v+8(%esi),%eax
+	pushl	%eax
+	movl	fv_v+8(%edx),%eax
+	pushl	%eax
+	pushl	%ecx
+	pushl	%edx
+
+//			if (index0->flags & ALIAS_ONSEAM)
+//				index0->v[2] += r_affinetridesc.seamfixupX16;
+	movl	C(r_affinetridesc)+atd_seamfixupX16,%eax
+	testl	$(ALIAS_ONSEAM),fv_flags(%ecx)
+	jz		Lp11
+	addl	%eax,fv_v+8(%ecx)
+Lp11:
+
+//			if (index1->flags & ALIAS_ONSEAM)
+//				index1->v[2] += r_affinetridesc.seamfixupX16;
+	testl	$(ALIAS_ONSEAM),fv_flags(%esi)
+	jz		Lp12
+	addl	%eax,fv_v+8(%esi)
+Lp12:
+
+//			if (index2->flags & ALIAS_ONSEAM)
+//				index2->v[2] += r_affinetridesc.seamfixupX16;
+	testl	$(ALIAS_ONSEAM),fv_flags(%edx)
+	jz		Lp13
+	addl	%eax,fv_v+8(%edx)
+Lp13:
+
+//			D_PolysetRecursiveTriangle(index0->v, index1->v, index2->v);
+	pushl	%edx
+	pushl	%esi
+	pushl	%ecx
+	call	C(D_PolysetRecursiveTriangle)
+
+//			index0->v[2] = s0;
+//			index1->v[2] = s1;
+//			index2->v[2] = s2;
+	popl	%edx
+	popl	%ecx
+	popl	%eax
+	movl	%eax,fv_v+8(%edx)
+	popl	%eax
+	movl	%eax,fv_v+8(%esi)
+	popl	%eax
+	movl	%eax,fv_v+8(%ecx)
+
+//		}
+//	}
+Lskip:
+	subl	$16,%ebp
+	jnz		Llooptop
+
+Ldone2:
+	popl	%edi				// restore the caller's stack frame
+	popl	%ebx
+	popl	%esi				// restore register variables
+	popl	%ebp
+
+	addl	$(SPAN_SIZE),%esp
+
+	ret
+
+
+//----------------------------------------------------------------------
+// Alias model triangle left-edge scanning code
+//----------------------------------------------------------------------
+
+#define height	4+16
+
+.globl C(D_PolysetScanLeftEdge)
+C(D_PolysetScanLeftEdge):
+	pushl	%ebp				// preserve caller stack frame pointer
+	pushl	%esi				// preserve register variables
+	pushl	%edi
+	pushl	%ebx
+
+	movl	height(%esp),%eax
+	movl	C(d_sfrac),%ecx
+	andl	$0xFFFF,%eax
+	movl	C(d_ptex),%ebx
+	orl		%eax,%ecx
+	movl	C(d_pedgespanpackage),%esi
+	movl	C(d_tfrac),%edx
+	movl	C(d_light),%edi
+	movl	C(d_zi),%ebp
+
+// %eax: scratch
+// %ebx: d_ptex
+// %ecx: d_sfrac in high word, count in low word
+// %edx: d_tfrac
+// %esi: d_pedgespanpackage, errorterm, scratch alternately
+// %edi: d_light
+// %ebp: d_zi
+
+//	do
+//	{
+
+LScanLoop:
+
+//		d_pedgespanpackage->ptex = ptex;
+//		d_pedgespanpackage->pdest = d_pdest;
+//		d_pedgespanpackage->pz = d_pz;
+//		d_pedgespanpackage->count = d_aspancount;
+//		d_pedgespanpackage->light = d_light;
+//		d_pedgespanpackage->zi = d_zi;
+//		d_pedgespanpackage->sfrac = d_sfrac << 16;
+//		d_pedgespanpackage->tfrac = d_tfrac << 16;
+	movl	%ebx,spanpackage_t_ptex(%esi)
+	movl	C(d_pdest),%eax
+	movl	%eax,spanpackage_t_pdest(%esi)
+	movl	C(d_pz),%eax
+	movl	%eax,spanpackage_t_pz(%esi)
+	movl	C(d_aspancount),%eax
+	movl	%eax,spanpackage_t_count(%esi)
+	movl	%edi,spanpackage_t_light(%esi)
+	movl	%ebp,spanpackage_t_zi(%esi)
+	movl	%ecx,spanpackage_t_sfrac(%esi)
+	movl	%edx,spanpackage_t_tfrac(%esi)
+
+// pretouch the next cache line
+	movb	spanpackage_t_size(%esi),%al
+
+//		d_pedgespanpackage++;
+	addl	$(spanpackage_t_size),%esi
+	movl	C(erroradjustup),%eax
+	movl	%esi,C(d_pedgespanpackage)
+
+//		errorterm += erroradjustup;
+	movl	C(errorterm),%esi
+	addl	%eax,%esi
+	movl	C(d_pdest),%eax
+
+//		if (errorterm >= 0)
+//		{
+	js		LNoLeftEdgeTurnover
+
+//			errorterm -= erroradjustdown;
+//			d_pdest += d_pdestextrastep;
+	subl	C(erroradjustdown),%esi
+	addl	C(d_pdestextrastep),%eax
+	movl	%esi,C(errorterm)
+	movl	%eax,C(d_pdest)
+
+//			d_pz += d_pzextrastep;
+//			d_aspancount += d_countextrastep;
+//			d_ptex += d_ptexextrastep;
+//			d_sfrac += d_sfracextrastep;
+//			d_ptex += d_sfrac >> 16;
+//			d_sfrac &= 0xFFFF;
+//			d_tfrac += d_tfracextrastep;
+	movl	C(d_pz),%eax
+	movl	C(d_aspancount),%esi
+	addl	C(d_pzextrastep),%eax
+	addl	C(d_sfracextrastep),%ecx
+	adcl	C(d_ptexextrastep),%ebx
+	addl	C(d_countextrastep),%esi
+	movl	%eax,C(d_pz)
+	movl	C(d_tfracextrastep),%eax
+	movl	%esi,C(d_aspancount)
+	addl	%eax,%edx
+
+//			if (d_tfrac & 0x10000)
+//			{
+	jnc		LSkip1
+
+//				d_ptex += r_affinetridesc.skinwidth;
+//				d_tfrac &= 0xFFFF;
+	addl	C(r_affinetridesc)+atd_skinwidth,%ebx
+
+//			}
+
+LSkip1:
+
+//			d_light += d_lightextrastep;
+//			d_zi += d_ziextrastep;
+	addl	C(d_lightextrastep),%edi
+	addl	C(d_ziextrastep),%ebp
+
+//		}
+	movl	C(d_pedgespanpackage),%esi
+	decl	%ecx
+	testl	$0xFFFF,%ecx
+	jnz		LScanLoop
+
+	popl	%ebx
+	popl	%edi
+	popl	%esi
+	popl	%ebp
+	ret
+
+//		else
+//		{
+
+LNoLeftEdgeTurnover:
+	movl	%esi,C(errorterm)
+
+//			d_pdest += d_pdestbasestep;
+	addl	C(d_pdestbasestep),%eax
+	movl	%eax,C(d_pdest)
+
+//			d_pz += d_pzbasestep;
+//			d_aspancount += ubasestep;
+//			d_ptex += d_ptexbasestep;
+//			d_sfrac += d_sfracbasestep;
+//			d_ptex += d_sfrac >> 16;
+//			d_sfrac &= 0xFFFF;
+	movl	C(d_pz),%eax
+	movl	C(d_aspancount),%esi
+	addl	C(d_pzbasestep),%eax
+	addl	C(d_sfracbasestep),%ecx
+	adcl	C(d_ptexbasestep),%ebx
+	addl	C(ubasestep),%esi
+	movl	%eax,C(d_pz)
+	movl	%esi,C(d_aspancount)
+
+//			d_tfrac += d_tfracbasestep;
+	movl	C(d_tfracbasestep),%esi
+	addl	%esi,%edx
+
+//			if (d_tfrac & 0x10000)
+//			{
+	jnc		LSkip2
+
+//				d_ptex += r_affinetridesc.skinwidth;
+//				d_tfrac &= 0xFFFF;
+	addl	C(r_affinetridesc)+atd_skinwidth,%ebx
+
+//			}
+
+LSkip2:
+
+//			d_light += d_lightbasestep;
+//			d_zi += d_zibasestep;
+	addl	C(d_lightbasestep),%edi
+	addl	C(d_zibasestep),%ebp
+
+//		}
+//	} while (--height);
+	movl	C(d_pedgespanpackage),%esi
+	decl	%ecx
+	testl	$0xFFFF,%ecx
+	jnz		LScanLoop
+
+	popl	%ebx
+	popl	%edi
+	popl	%esi
+	popl	%ebp
+	ret
+
+
+//----------------------------------------------------------------------
+// Alias model vertex drawing code
+//----------------------------------------------------------------------
+
+#define fv			4+8
+#define	numverts	8+8
+
+.globl C(D_PolysetDrawFinalVerts)
+C(D_PolysetDrawFinalVerts):
+	pushl	%ebp				// preserve caller stack frame pointer
+	pushl	%ebx
+
+//	int		i, z;
+//	short	*zbuf;
+
+	movl	numverts(%esp),%ecx
+	movl	fv(%esp),%ebx
+
+	pushl	%esi				// preserve register variables
+	pushl	%edi
+
+LFVLoop:
+
+//	for (i=0 ; i<numverts ; i++, fv++)
+//	{
+//	// valid triangle coordinates for filling can include the bottom and
+//	// right clip edges, due to the fill rule; these shouldn't be drawn
+//		if ((fv->v[0] < r_refdef.vrectright) &&
+//			(fv->v[1] < r_refdef.vrectbottom))
+//		{
+	movl	fv_v+0(%ebx),%eax
+	movl	C(r_refdef)+rd_vrectright,%edx
+	cmpl	%edx,%eax
+	jge		LNextVert
+	movl	fv_v+4(%ebx),%esi
+	movl	C(r_refdef)+rd_vrectbottom,%edx
+	cmpl	%edx,%esi
+	jge		LNextVert
+
+//			zbuf = zspantable[fv->v[1]] + fv->v[0];
+	movl	C(zspantable)(,%esi,4),%edi
+
+//			z = fv->v[5]>>16;
+	movl	fv_v+20(%ebx),%edx
+	shrl	$16,%edx
+
+//			if (z >= *zbuf)
+//			{
+//				int		pix;
+	cmpw	(%edi,%eax,2),%dx
+	jl		LNextVert
+
+//				*zbuf = z;
+	movw	%dx,(%edi,%eax,2)
+
+//				pix = skintable[fv->v[3]>>16][fv->v[2]>>16];
+	movl	fv_v+12(%ebx),%edi
+	shrl	$16,%edi
+	movl	C(skintable)(,%edi,4),%edi
+	movl	fv_v+8(%ebx),%edx
+	shrl	$16,%edx
+	movb	(%edi,%edx),%dl
+
+//				pix = ((byte *)acolormap)[pix + (fv->v[4] & 0xFF00)];
+	movl	fv_v+16(%ebx),%edi
+	andl	$0xFF00,%edi
+	andl	$0x00FF,%edx
+	addl	%edx,%edi
+	movl	C(acolormap),%edx
+	movb	(%edx,%edi,1),%dl
+
+//				d_viewbuffer[d_scantable[fv->v[1]] + fv->v[0]] = pix;
+	movl	C(d_scantable)(,%esi,4),%edi
+	movl	C(d_viewbuffer),%esi
+	addl	%eax,%edi
+	movb	%dl,(%esi,%edi)
+
+//			}
+//		}
+//	}
+LNextVert:
+	addl	$(fv_size),%ebx
+	decl	%ecx
+	jnz		LFVLoop
+
+	popl	%edi
+	popl	%esi
+	popl	%ebx
+	popl	%ebp
+	ret
+
+
+//----------------------------------------------------------------------
+// Alias model non-subdivided polygon dispatching code
+//
+// not C-callable because of stack buffer cleanup
+//----------------------------------------------------------------------
+
+.globl C(D_DrawNonSubdiv)
+C(D_DrawNonSubdiv):
+	pushl	%ebp				// preserve caller stack frame pointer
+	movl	C(r_affinetridesc)+atd_numtriangles,%ebp
+	pushl	%ebx
+	shll	$(mtri_shift),%ebp
+	pushl	%esi				// preserve register variables
+	movl	C(r_affinetridesc)+atd_ptriangles,%esi
+	pushl	%edi
+
+//	mtriangle_t		*ptri;
+//	finalvert_t		*pfv, *index0, *index1, *index2;
+//	int				i;
+//	int				lnumtriangles;
+
+//	pfv = r_affinetridesc.pfinalverts;
+//	ptri = r_affinetridesc.ptriangles;
+//	lnumtriangles = r_affinetridesc.numtriangles;
+
+LNDLoop:
+
+//	for (i=0 ; i<lnumtriangles ; i++, ptri++)
+//	{
+//		index0 = pfv + ptri->vertindex[0];
+//		index1 = pfv + ptri->vertindex[1];
+//		index2 = pfv + ptri->vertindex[2];
+	movl	C(r_affinetridesc)+atd_pfinalverts,%edi
+	movl	mtri_vertindex+0-mtri_size(%esi,%ebp,1),%ecx
+	shll	$(fv_shift),%ecx
+	movl	mtri_vertindex+4-mtri_size(%esi,%ebp,1),%edx
+	shll	$(fv_shift),%edx
+	movl	mtri_vertindex+8-mtri_size(%esi,%ebp,1),%ebx
+	shll	$(fv_shift),%ebx
+	addl	%edi,%ecx
+	addl	%edi,%edx
+	addl	%edi,%ebx
+
+//		d_xdenom = (index0->v[1]-index1->v[1]) *
+//				(index0->v[0]-index2->v[0]) -
+//				(index0->v[0]-index1->v[0])*(index0->v[1]-index2->v[1]);
+	movl	fv_v+4(%ecx),%eax
+	movl	fv_v+0(%ecx),%esi
+	subl	fv_v+4(%edx),%eax
+	subl	fv_v+0(%ebx),%esi
+	imull	%esi,%eax
+	movl	fv_v+0(%ecx),%esi
+	movl	fv_v+4(%ecx),%edi
+	subl	fv_v+0(%edx),%esi
+	subl	fv_v+4(%ebx),%edi
+	imull	%esi,%edi
+	subl	%edi,%eax
+
+//		if (d_xdenom >= 0)
+//		{
+//			continue;
+	jns		LNextTri
+
+//		}
+
+	movl	%eax,C(d_xdenom)
+	fildl	C(d_xdenom)
+
+//		r_p0[0] = index0->v[0];		// u
+//		r_p0[1] = index0->v[1];		// v
+//		r_p0[2] = index0->v[2];		// s
+//		r_p0[3] = index0->v[3];		// t
+//		r_p0[4] = index0->v[4];		// light
+//		r_p0[5] = index0->v[5];		// iz
+	movl	fv_v+0(%ecx),%eax
+	movl	fv_v+4(%ecx),%esi
+	movl	%eax,C(r_p0)+0
+	movl	%esi,C(r_p0)+4
+	movl	fv_v+8(%ecx),%eax
+	movl	fv_v+12(%ecx),%esi
+	movl	%eax,C(r_p0)+8
+	movl	%esi,C(r_p0)+12
+	movl	fv_v+16(%ecx),%eax
+	movl	fv_v+20(%ecx),%esi
+	movl	%eax,C(r_p0)+16
+	movl	%esi,C(r_p0)+20
+
+	fdivrs	float_1
+
+//		r_p1[0] = index1->v[0];
+//		r_p1[1] = index1->v[1];
+//		r_p1[2] = index1->v[2];
+//		r_p1[3] = index1->v[3];
+//		r_p1[4] = index1->v[4];
+//		r_p1[5] = index1->v[5];
+	movl	fv_v+0(%edx),%eax
+	movl	fv_v+4(%edx),%esi
+	movl	%eax,C(r_p1)+0
+	movl	%esi,C(r_p1)+4
+	movl	fv_v+8(%edx),%eax
+	movl	fv_v+12(%edx),%esi
+	movl	%eax,C(r_p1)+8
+	movl	%esi,C(r_p1)+12
+	movl	fv_v+16(%edx),%eax
+	movl	fv_v+20(%edx),%esi
+	movl	%eax,C(r_p1)+16
+	movl	%esi,C(r_p1)+20
+
+//		r_p2[0] = index2->v[0];
+//		r_p2[1] = index2->v[1];
+//		r_p2[2] = index2->v[2];
+//		r_p2[3] = index2->v[3];
+//		r_p2[4] = index2->v[4];
+//		r_p2[5] = index2->v[5];
+	movl	fv_v+0(%ebx),%eax
+	movl	fv_v+4(%ebx),%esi
+	movl	%eax,C(r_p2)+0
+	movl	%esi,C(r_p2)+4
+	movl	fv_v+8(%ebx),%eax
+	movl	fv_v+12(%ebx),%esi
+	movl	%eax,C(r_p2)+8
+	movl	%esi,C(r_p2)+12
+	movl	fv_v+16(%ebx),%eax
+	movl	fv_v+20(%ebx),%esi
+	movl	%eax,C(r_p2)+16
+	movl	C(r_affinetridesc)+atd_ptriangles,%edi
+	movl	%esi,C(r_p2)+20
+	movl	mtri_facesfront-mtri_size(%edi,%ebp,1),%eax
+
+//		if (!ptri->facesfront)
+//		{
+	testl	%eax,%eax
+	jnz		LFacesFront
+
+//			if (index0->flags & ALIAS_ONSEAM)
+//				r_p0[2] += r_affinetridesc.seamfixupX16;
+	movl	fv_flags(%ecx),%eax
+	movl	fv_flags(%edx),%esi
+	movl	fv_flags(%ebx),%edi
+	testl	$(ALIAS_ONSEAM),%eax
+	movl	C(r_affinetridesc)+atd_seamfixupX16,%eax
+	jz		LOnseamDone0
+	addl	%eax,C(r_p0)+8
+LOnseamDone0:
+
+//			if (index1->flags & ALIAS_ONSEAM)
+// 				r_p1[2] += r_affinetridesc.seamfixupX16;
+	testl	$(ALIAS_ONSEAM),%esi
+	jz		LOnseamDone1
+	addl	%eax,C(r_p1)+8
+LOnseamDone1:
+
+//			if (index2->flags & ALIAS_ONSEAM)
+//				r_p2[2] += r_affinetridesc.seamfixupX16;
+	testl	$(ALIAS_ONSEAM),%edi
+	jz		LOnseamDone2
+	addl	%eax,C(r_p2)+8
+LOnseamDone2:
+
+//		}
+
+LFacesFront:
+
+	fstps	C(d_xdenom)
+
+//		D_PolysetSetEdgeTable ();
+//		D_RasterizeAliasPolySmooth ();
+		call	C(D_PolysetSetEdgeTable)
+		call	C(D_RasterizeAliasPolySmooth)
+
+LNextTri:
+		movl	C(r_affinetridesc)+atd_ptriangles,%esi
+		subl	$16,%ebp
+		jnz		LNDLoop
+//	}
+
+	popl	%edi
+	popl	%esi
+	popl	%ebx
+	popl	%ebp
+
+	addl	$(SPAN_SIZE),%esp
+
+	ret
+
+
+#endif	// id386
+
diff -ruN WinQuake/d_polysa.s sdlquake-1.0.9/d_polysa.s
--- WinQuake/d_polysa.s	Tue Dec 21 15:53:24 1999
+++ sdlquake-1.0.9/d_polysa.s	Wed Dec 31 16:00:00 1969
@@ -1,1744 +0,0 @@
-/*
-Copyright (C) 1996-1997 Id Software, Inc.
-
-This program is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License
-as published by the Free Software Foundation; either version 2
-of the License, or (at your option) any later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
-
-See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-*/
-//
-// d_polysa.s
-// x86 assembly-language polygon model drawing code
-//
-
-#include "asm_i386.h"
-#include "quakeasm.h"
-#include "asm_draw.h"
-#include "d_ifacea.h"
-
-#if	id386
-
-// !!! if this is changed, it must be changed in d_polyse.c too !!!
-#define DPS_MAXSPANS			MAXHEIGHT+1	
-									// 1 extra for spanpackage that marks end
-
-//#define	SPAN_SIZE	(((DPS_MAXSPANS + 1 + ((CACHE_SIZE - 1) / spanpackage_t_size)) + 1) * spanpackage_t_size)
-#define SPAN_SIZE (1024+1+1+1)*32
-
-
-	.data
-
-	.align	4
-p10_minus_p20:	.single		0
-p01_minus_p21:	.single		0
-temp0:			.single		0
-temp1:			.single		0
-Ltemp:			.single		0
-
-aff8entryvec_table:	.long	LDraw8, LDraw7, LDraw6, LDraw5
-				.long	LDraw4, LDraw3, LDraw2, LDraw1
-
-lzistepx:		.long	0
-
-
-	.text
-
-#ifndef NeXT
-	.extern C(D_PolysetSetEdgeTable)
-	.extern C(D_RasterizeAliasPolySmooth)
-#endif
-
-//----------------------------------------------------------------------
-// affine triangle gradient calculation code
-//----------------------------------------------------------------------
-
-#define skinwidth	4+0
-
-.globl C(D_PolysetCalcGradients)
-C(D_PolysetCalcGradients):
-
-//	p00_minus_p20 = r_p0[0] - r_p2[0];
-//	p01_minus_p21 = r_p0[1] - r_p2[1];
-//	p10_minus_p20 = r_p1[0] - r_p2[0];
-//	p11_minus_p21 = r_p1[1] - r_p2[1];
-//
-//	xstepdenominv = 1.0 / (p10_minus_p20 * p01_minus_p21 -
-//			     p00_minus_p20 * p11_minus_p21);
-//
-//	ystepdenominv = -xstepdenominv;
-
-	fildl	C(r_p0)+0		// r_p0[0]
-	fildl	C(r_p2)+0		// r_p2[0] | r_p0[0]
-	fildl	C(r_p0)+4		// r_p0[1] | r_p2[0] | r_p0[0]
-	fildl	C(r_p2)+4		// r_p2[1] | r_p0[1] | r_p2[0] | r_p0[0]
-	fildl	C(r_p1)+0		// r_p1[0] | r_p2[1] | r_p0[1] | r_p2[0] | r_p0[0]
-	fildl	C(r_p1)+4		// r_p1[1] | r_p1[0] | r_p2[1] | r_p0[1] |
-							//  r_p2[0] | r_p0[0]
-	fxch	%st(3)			// r_p0[1] | r_p1[0] | r_p2[1] | r_p1[1] |
-							//  r_p2[0] | r_p0[0]
-	fsub	%st(2),%st(0)	// p01_minus_p21 | r_p1[0] | r_p2[1] | r_p1[1] |
-							//  r_p2[0] | r_p0[0]
-	fxch	%st(1)			// r_p1[0] | p01_minus_p21 | r_p2[1] | r_p1[1] |
-							//  r_p2[0] | r_p0[0]
-	fsub	%st(4),%st(0)	// p10_minus_p20 | p01_minus_p21 | r_p2[1] |
-							//  r_p1[1] | r_p2[0] | r_p0[0]
-	fxch	%st(5)			// r_p0[0] | p01_minus_p21 | r_p2[1] |
-							//  r_p1[1] | r_p2[0] | p10_minus_p20
-	fsubp	%st(0),%st(4)	// p01_minus_p21 | r_p2[1] | r_p1[1] |
-							//  p00_minus_p20 | p10_minus_p20
-	fxch	%st(2)			// r_p1[1] | r_p2[1] | p01_minus_p21 |
-							//  p00_minus_p20 | p10_minus_p20
-	fsubp	%st(0),%st(1)	// p11_minus_p21 | p01_minus_p21 |
-							//  p00_minus_p20 | p10_minus_p20
-	fxch	%st(1)			// p01_minus_p21 | p11_minus_p21 |
-							//  p00_minus_p20 | p10_minus_p20
-	flds	C(d_xdenom)		// d_xdenom | p01_minus_p21 | p11_minus_p21 |
-							//  p00_minus_p20 | p10_minus_p20
-	fxch	%st(4)			// p10_minus_p20 | p01_minus_p21 | p11_minus_p21 |
-							//  p00_minus_p20 | d_xdenom
-	fstps	p10_minus_p20	// p01_minus_p21 | p11_minus_p21 |
-							//  p00_minus_p20 | d_xdenom
-	fstps	p01_minus_p21	// p11_minus_p21 | p00_minus_p20 | xstepdenominv
-	fxch	%st(2)			// xstepdenominv | p00_minus_p20 | p11_minus_p21
-
-//// ceil () for light so positive steps are exaggerated, negative steps
-//// diminished,  pushing us away from underflow toward overflow. Underflow is
-//// very visible, overflow is very unlikely, because of ambient lighting
-//	t0 = r_p0[4] - r_p2[4];
-//	t1 = r_p1[4] - r_p2[4];
-
-	fildl	C(r_p2)+16		// r_p2[4] | xstepdenominv | p00_minus_p20 |
-							//  p11_minus_p21
-	fildl	C(r_p0)+16		// r_p0[4] | r_p2[4] | xstepdenominv |
-							//  p00_minus_p20 | p11_minus_p21
-	fildl	C(r_p1)+16		// r_p1[4] | r_p0[4] | r_p2[4] | xstepdenominv |
-							//  p00_minus_p20 | p11_minus_p21
-	fxch	%st(2)			// r_p2[4] | r_p0[4] | r_p1[4] | xstepdenominv |
-							//  p00_minus_p20 | p11_minus_p21
-	fld		%st(0)			// r_p2[4] | r_p2[4] | r_p0[4] | r_p1[4] |
-							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
-	fsubrp	%st(0),%st(2)	// r_p2[4] | t0 | r_p1[4] | xstepdenominv |
-							//  p00_minus_p20 | p11_minus_p21
-	fsubrp	%st(0),%st(2)	// t0 | t1 | xstepdenominv | p00_minus_p20 |
-							//  p11_minus_p21
-
-//	r_lstepx = (int)
-//			ceil((t1 * p01_minus_p21 - t0 * p11_minus_p21) * xstepdenominv);
-//	r_lstepy = (int)
-//			ceil((t1 * p00_minus_p20 - t0 * p10_minus_p20) * ystepdenominv);
-
-	fld		%st(0)			// t0 | t0 | t1 | xstepdenominv | p00_minus_p20 |
-							//  p11_minus_p21
-	fmul	%st(5),%st(0)	// t0*p11_minus_p21 | t0 | t1 | xstepdenominv |
-							//  p00_minus_p20 | p11_minus_p21
-	fxch	%st(2)			// t1 | t0 | t0*p11_minus_p21 | xstepdenominv |
-							//  p00_minus_p20 | p11_minus_p21
-	fld		%st(0)			// t1 | t1 | t0 | t0*p11_minus_p21 |
-							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
-	fmuls	p01_minus_p21	// t1*p01_minus_p21 | t1 | t0 | t0*p11_minus_p21 |
-							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
-	fxch	%st(2)			// t0 | t1 | t1*p01_minus_p21 | t0*p11_minus_p21 |
-							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
-	fmuls	p10_minus_p20	// t0*p10_minus_p20 | t1 | t1*p01_minus_p21 |
-							//  t0*p11_minus_p21 | xstepdenominv |
-							//  p00_minus_p20 | p11_minus_p21
-	fxch	%st(1)			// t1 | t0*p10_minus_p20 | t1*p01_minus_p21 |
-							//  t0*p11_minus_p21 | xstepdenominv |
-							//  p00_minus_p20 | p11_minus_p21
-	fmul	%st(5),%st(0)	// t1*p00_minus_p20 | t0*p10_minus_p20 |
-							//  t1*p01_minus_p21 | t0*p11_minus_p21 |
-							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
-	fxch	%st(2)			// t1*p01_minus_p21 | t0*p10_minus_p20 |
-							//  t1*p00_minus_p20 | t0*p11_minus_p21 |
-							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
-	fsubp	%st(0),%st(3)	// t0*p10_minus_p20 | t1*p00_minus_p20 |
-							//  t1*p01_minus_p21 - t0*p11_minus_p21 |
-							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
-	fsubrp	%st(0),%st(1)	// t1*p00_minus_p20 - t0*p10_minus_p20 |
-							//  t1*p01_minus_p21 - t0*p11_minus_p21 |
-							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
-	fld		%st(2)			// xstepdenominv |
-							//  t1*p00_minus_p20 - t0*p10_minus_p20 |
-							//  t1*p01_minus_p21 - t0*p11_minus_p21 |
-							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
-	fmuls	float_minus_1	// ystepdenominv |
-							//  t1*p00_minus_p20 - t0*p10_minus_p20 |
-							//  t1*p01_minus_p21 - t0*p11_minus_p21 |
-							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
-	fxch	%st(2)			// t1*p01_minus_p21 - t0*p11_minus_p21 |
-							//  t1*p00_minus_p20 - t0*p10_minus_p20 |
-							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
-							//  p11_minus_p21
-	fmul	%st(3),%st(0)	// (t1*p01_minus_p21 - t0*p11_minus_p21)*
-							//   xstepdenominv |
-							//  t1*p00_minus_p20 - t0*p10_minus_p20 |
-							//   | ystepdenominv | xstepdenominv |
-							//   p00_minus_p20 | p11_minus_p21
-	fxch	%st(1)			// t1*p00_minus_p20 - t0*p10_minus_p20 |
-							//  (t1*p01_minus_p21 - t0*p11_minus_p21)*
-							//   xstepdenominv | ystepdenominv |
-							//   xstepdenominv | p00_minus_p20 | p11_minus_p21
-	fmul	%st(2),%st(0)	// (t1*p00_minus_p20 - t0*p10_minus_p20)*
-							//  ystepdenominv |
-							//  (t1*p01_minus_p21 - t0*p11_minus_p21)*
-							//  xstepdenominv | ystepdenominv |
-							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
-	fldcw	ceil_cw
-	fistpl	C(r_lstepy)		// r_lstepx | ystepdenominv | xstepdenominv |
-							//  p00_minus_p20 | p11_minus_p21
-	fistpl	C(r_lstepx)		// ystepdenominv | xstepdenominv | p00_minus_p20 |
-							//  p11_minus_p21
-	fldcw	single_cw
-
-//	t0 = r_p0[2] - r_p2[2];
-//	t1 = r_p1[2] - r_p2[2];
-
-	fildl	C(r_p2)+8		// r_p2[2] | ystepdenominv | xstepdenominv |
-							//  p00_minus_p20 | p11_minus_p21
-	fildl	C(r_p0)+8		// r_p0[2] | r_p2[2] | ystepdenominv |
-							//   xstepdenominv | p00_minus_p20 | p11_minus_p21
-	fildl	C(r_p1)+8		// r_p1[2] | r_p0[2] | r_p2[2] | ystepdenominv |
-							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
-	fxch	%st(2)			// r_p2[2] | r_p0[2] | r_p1[2] | ystepdenominv |
-							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
-	fld		%st(0)			// r_p2[2] | r_p2[2] | r_p0[2] | r_p1[2] |
-							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
-							//  p11_minus_p21
-	fsubrp	%st(0),%st(2)	// r_p2[2] | t0 | r_p1[2] | ystepdenominv |
-							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
-	fsubrp	%st(0),%st(2)	// t0 | t1 | ystepdenominv | xstepdenominv |
-							//  p00_minus_p20 | p11_minus_p21
-
-//	r_sstepx = (int)((t1 * p01_minus_p21 - t0 * p11_minus_p21) *
-//			xstepdenominv);
-//	r_sstepy = (int)((t1 * p00_minus_p20 - t0 * p10_minus_p20) *
-//			ystepdenominv);
-
-	fld		%st(0)			// t0 | t0 | t1 | ystepdenominv | xstepdenominv
-	fmul	%st(6),%st(0)	// t0*p11_minus_p21 | t0 | t1 | ystepdenominv |
-							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
-	fxch	%st(2)			// t1 | t0 | t0*p11_minus_p21 | ystepdenominv |
-							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
-	fld		%st(0)			// t1 | t1 | t0 | t0*p11_minus_p21 |
-							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
-							//  p11_minus_p21
-	fmuls	p01_minus_p21	// t1*p01_minus_p21 | t1 | t0 | t0*p11_minus_p21 |
-							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
-							//  p11_minus_p21
-	fxch	%st(2)			// t0 | t1 | t1*p01_minus_p21 | t0*p11_minus_p21 |
-							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
-							//  p11_minus_p21
-	fmuls	p10_minus_p20	// t0*p10_minus_p20 | t1 | t1*p01_minus_p21 |
-							//  t0*p11_minus_p21 | ystepdenominv |
-							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
-	fxch	%st(1)			// t1 | t0*p10_minus_p20 | t1*p01_minus_p21 |
-							//  t0*p11_minus_p21 | ystepdenominv |
-							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
-	fmul	%st(6),%st(0)	// t1*p00_minus_p20 | t0*p10_minus_p20 |
-							//  t1*p01_minus_p21 | t0*p11_minus_p21 |
-							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
-							//  p11_minus_p21
-	fxch	%st(2)			// t1*p01_minus_p21 | t0*p10_minus_p20 |
-							//  t1*p00_minus_p20 | t0*p11_minus_p21 |
-							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
-							//  p11_minus_p21
-	fsubp	%st(0),%st(3)	// t0*p10_minus_p20 | t1*p00_minus_p20 |
-							//  t1*p01_minus_p21 - t0*p11_minus_p21 |
-							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
-							//  p11_minus_p21
-	fsubrp	%st(0),%st(1)	// t1*p00_minus_p20 - t0*p10_minus_p20 |
-							//  t1*p01_minus_p21 - t0*p11_minus_p21 |
-							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
-							//  p11_minus_p21
-	fmul	%st(2),%st(0)	// (t1*p00_minus_p20 - t0*p10_minus_p20)*
-							//   ystepdenominv |
-							//  t1*p01_minus_p21 - t0*p11_minus_p21 |
-							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
-							//  p11_minus_p21
-	fxch	%st(1)			// t1*p01_minus_p21 - t0*p11_minus_p21 |
-							//  (t1*p00_minus_p20 - t0*p10_minus_p20)*
-							//   ystepdenominv | ystepdenominv |
-							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
-	fmul	%st(3),%st(0)	// (t1*p01_minus_p21 - t0*p11_minus_p21)*
-							//  xstepdenominv |
-							//  (t1*p00_minus_p20 - t0*p10_minus_p20)*
-							//  ystepdenominv | ystepdenominv |
-							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
-	fxch	%st(1)			// (t1*p00_minus_p20 - t0*p10_minus_p20)*
-							//  ystepdenominv |
-							//  (t1*p01_minus_p21 - t0*p11_minus_p21)*
-							//  xstepdenominv | ystepdenominv |
-							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
-	fistpl	C(r_sstepy)		// r_sstepx | ystepdenominv | xstepdenominv |
-							//  p00_minus_p20 | p11_minus_p21
-	fistpl	C(r_sstepx)		// ystepdenominv | xstepdenominv | p00_minus_p20 |
-							//  p11_minus_p21
-
-//	t0 = r_p0[3] - r_p2[3];
-//	t1 = r_p1[3] - r_p2[3];
-
-	fildl	C(r_p2)+12		// r_p2[3] | ystepdenominv | xstepdenominv |
-							//  p00_minus_p20 | p11_minus_p21
-	fildl	C(r_p0)+12		// r_p0[3] | r_p2[3] | ystepdenominv |
-							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
-	fildl	C(r_p1)+12		// r_p1[3] | r_p0[3] | r_p2[3] | ystepdenominv |
-							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
-	fxch	%st(2)			// r_p2[3] | r_p0[3] | r_p1[3] | ystepdenominv |
-							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
-	fld		%st(0)			// r_p2[3] | r_p2[3] | r_p0[3] | r_p1[3] |
-							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
-							//  p11_minus_p21
-	fsubrp	%st(0),%st(2)	// r_p2[3] | t0 | r_p1[3] | ystepdenominv |
-							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
-	fsubrp	%st(0),%st(2)	// t0 | t1 | ystepdenominv | xstepdenominv |
-							//  p00_minus_p20 | p11_minus_p21
-
-//	r_tstepx = (int)((t1 * p01_minus_p21 - t0 * p11_minus_p21) *
-//			xstepdenominv);
-//	r_tstepy = (int)((t1 * p00_minus_p20 - t0 * p10_minus_p20) *
-//			ystepdenominv);
-
-	fld		%st(0)			// t0 | t0 | t1 | ystepdenominv | xstepdenominv |
-							//  p00_minus_p20 | p11_minus_p21
-	fmul	%st(6),%st(0)	// t0*p11_minus_p21 | t0 | t1 | ystepdenominv |
-							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
-	fxch	%st(2)			// t1 | t0 | t0*p11_minus_p21 | ystepdenominv |
-							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
-	fld		%st(0)			// t1 | t1 | t0 | t0*p11_minus_p21 |
-							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
-							//  p11_minus_p21
-	fmuls	p01_minus_p21	// t1*p01_minus_p21 | t1 | t0 | t0*p11_minus_p21 |
-							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
-							//  p11_minus_p21
-	fxch	%st(2)			// t0 | t1 | t1*p01_minus_p21 | t0*p11_minus_p21 |
-							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
-							//  p11_minus_p21
-	fmuls	p10_minus_p20	// t0*p10_minus_p20 | t1 | t1*p01_minus_p21 |
-							//  t0*p11_minus_p21 | ystepdenominv |
-							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
-	fxch	%st(1)			// t1 | t0*p10_minus_p20 | t1*p01_minus_p21 |
-							//  t0*p11_minus_p21 | ystepdenominv |
-							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
-	fmul	%st(6),%st(0)	// t1*p00_minus_p20 | t0*p10_minus_p20 |
-							//  t1*p01_minus_p21 | t0*p11_minus_p21 |
-							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
-							//  p11_minus_p21
-	fxch	%st(2)			// t1*p01_minus_p21 | t0*p10_minus_p20 |
-							//  t1*p00_minus_p20 | t0*p11_minus_p21 |
-							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
-							//  p11_minus_p21
-	fsubp	%st(0),%st(3)	// t0*p10_minus_p20 | t1*p00_minus_p20 |
-							//  t1*p01_minus_p21 - t0*p11_minus_p21 |
-							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
-							//  p11_minus_p21
-	fsubrp	%st(0),%st(1)	// t1*p00_minus_p20 - t0*p10_minus_p20 |
-							//  t1*p01_minus_p21 - t0*p11_minus_p21 |
-							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
-							//  p11_minus_p21
-	fmul	%st(2),%st(0)	// (t1*p00_minus_p20 - t0*p10_minus_p20)*
-							//   ystepdenominv |
-							//  t1*p01_minus_p21 - t0*p11_minus_p21 |
-							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
-							//  p11_minus_p21
-	fxch	%st(1)			// t1*p01_minus_p21 - t0*p11_minus_p21 |
-							//  (t1*p00_minus_p20 - t0*p10_minus_p20)*
-							//  ystepdenominv | ystepdenominv |
-							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
-	fmul	%st(3),%st(0)	// (t1*p01_minus_p21 - t0*p11_minus_p21)*
-							//  xstepdenominv |
-							//  (t1*p00_minus_p20 - t0*p10_minus_p20)*
-							//  ystepdenominv | ystepdenominv |
-							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
-	fxch	%st(1)			// (t1*p00_minus_p20 - t0*p10_minus_p20)*
-							//  ystepdenominv |
-							//  (t1*p01_minus_p21 - t0*p11_minus_p21)*
-							//  xstepdenominv | ystepdenominv |
-							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
-	fistpl	C(r_tstepy)		// r_tstepx | ystepdenominv | xstepdenominv |
-							//  p00_minus_p20 | p11_minus_p21
-	fistpl	C(r_tstepx)		// ystepdenominv | xstepdenominv | p00_minus_p20 |
-							//  p11_minus_p21
-
-//	t0 = r_p0[5] - r_p2[5];
-//	t1 = r_p1[5] - r_p2[5];
-
-	fildl	C(r_p2)+20		// r_p2[5] | ystepdenominv | xstepdenominv |
-							//  p00_minus_p20 | p11_minus_p21
-	fildl	C(r_p0)+20		// r_p0[5] | r_p2[5] | ystepdenominv |
-							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
-	fildl	C(r_p1)+20		// r_p1[5] | r_p0[5] | r_p2[5] | ystepdenominv |
-							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
-	fxch	%st(2)			// r_p2[5] | r_p0[5] | r_p1[5] | ystepdenominv |
-							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
-	fld		%st(0)			// r_p2[5] | r_p2[5] | r_p0[5] | r_p1[5] |
-							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
-							//  p11_minus_p21
-	fsubrp	%st(0),%st(2)	// r_p2[5] | t0 | r_p1[5] | ystepdenominv |
-							//  xstepdenominv | p00_minus_p20 | p11_minus_p21
-	fsubrp	%st(0),%st(2)	// t0 | t1 | ystepdenominv | xstepdenominv |
-							//  p00_minus_p20 | p11_minus_p21
-
-//	r_zistepx = (int)((t1 * p01_minus_p21 - t0 * p11_minus_p21) *
-//			xstepdenominv);
-//	r_zistepy = (int)((t1 * p00_minus_p20 - t0 * p10_minus_p20) *
-//			ystepdenominv);
-
-	fld		%st(0)			// t0 | t0 | t1 | ystepdenominv | xstepdenominv |
-							//  p00_minus_p20 | p11_minus_p21
-	fmulp	%st(0),%st(6)	// t0 | t1 | ystepdenominv | xstepdenominv |
-							//  p00_minus_p20 | t0*p11_minus_p21
-	fxch	%st(1)			// t1 | t0 | ystepdenominv | xstepdenominv |
-							//  p00_minus_p20 | t0*p11_minus_p21
-	fld		%st(0)			// t1 | t1 | t0 | ystepdenominv | xstepdenominv |
-							//  p00_minus_p20 | t0*p11_minus_p21
-	fmuls	p01_minus_p21	// t1*p01_minus_p21 | t1 | t0 | ystepdenominv |
-							//  xstepdenominv | p00_minus_p20 |
-							//  t0*p11_minus_p21
-	fxch	%st(2)			// t0 | t1 | t1*p01_minus_p21 | ystepdenominv |
-							//  xstepdenominv | p00_minus_p20 |
-							//  t0*p11_minus_p21
-	fmuls	p10_minus_p20	// t0*p10_minus_p20 | t1 | t1*p01_minus_p21 |
-							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
-							//  t0*p11_minus_p21
-	fxch	%st(1)			// t1 | t0*p10_minus_p20 | t1*p01_minus_p21 |
-							//  ystepdenominv | xstepdenominv | p00_minus_p20 |
-							//  t0*p11_minus_p21
-	fmulp	%st(0),%st(5)	// t0*p10_minus_p20 | t1*p01_minus_p21 |
-							//  ystepdenominv | xstepdenominv |
-							//  t1*p00_minus_p20 | t0*p11_minus_p21
-	fxch	%st(5)			// t0*p11_minus_p21 | t1*p01_minus_p21 |
-							//  ystepdenominv | xstepdenominv |
-							//  t1*p00_minus_p20 | t0*p10_minus_p20
-	fsubrp	%st(0),%st(1)	// t1*p01_minus_p21 - t0*p11_minus_p21 |
-							//  ystepdenominv | xstepdenominv |
-							//  t1*p00_minus_p20 | t0*p10_minus_p20
-	fxch	%st(3)			// t1*p00_minus_p20 | ystepdenominv |
-							//  xstepdenominv |
-							//  t1*p01_minus_p21 - t0*p11_minus_p21 |
-							//  t0*p10_minus_p20
-	fsubp	%st(0),%st(4)	// ystepdenominv | xstepdenominv |
-							//  t1*p01_minus_p21 - t0*p11_minus_p21 |
-							//  t1*p00_minus_p20 - t0*p10_minus_p20
-	fxch	%st(1)			// xstepdenominv | ystepdenominv |
-							//  t1*p01_minus_p21 - t0*p11_minus_p21 |
-							//  t1*p00_minus_p20 - t0*p10_minus_p20
-	fmulp	%st(0),%st(2)	// ystepdenominv |
-							//  (t1*p01_minus_p21 - t0*p11_minus_p21) *
-							//  xstepdenominv |
-							//  t1*p00_minus_p20 - t0*p10_minus_p20
-	fmulp	%st(0),%st(2)	// (t1*p01_minus_p21 - t0*p11_minus_p21) *
-							//  xstepdenominv |
-							//  (t1*p00_minus_p20 - t0*p10_minus_p20) *
-							//  ystepdenominv
-	fistpl	C(r_zistepx)	// (t1*p00_minus_p20 - t0*p10_minus_p20) *
-							//  ystepdenominv
-	fistpl	C(r_zistepy)
-
-//	a_sstepxfrac = r_sstepx << 16;
-//	a_tstepxfrac = r_tstepx << 16;
-//
-//	a_ststepxwhole = r_affinetridesc.skinwidth * (r_tstepx >> 16) +
-//			(r_sstepx >> 16);
-
-	movl	C(r_sstepx),%eax
-	movl	C(r_tstepx),%edx
-	shll	$16,%eax
-	shll	$16,%edx
-	movl	%eax,C(a_sstepxfrac)
-	movl	%edx,C(a_tstepxfrac)
-
-	movl	C(r_sstepx),%ecx
-	movl	C(r_tstepx),%eax
-	sarl	$16,%ecx
-	sarl	$16,%eax
-	imull	skinwidth(%esp)
-	addl	%ecx,%eax
-	movl	%eax,C(a_ststepxwhole)
-
-	ret
-
-
-//----------------------------------------------------------------------
-// recursive subdivision affine triangle drawing code
-//
-// not C-callable because of stdcall return
-//----------------------------------------------------------------------
-
-#define lp1	4+16
-#define lp2	8+16
-#define lp3	12+16
-
-.globl C(D_PolysetRecursiveTriangle)
-C(D_PolysetRecursiveTriangle):
-	pushl	%ebp				// preserve caller stack frame pointer
-	pushl	%esi				// preserve register variables
-	pushl	%edi
-	pushl	%ebx
-
-//	int		*temp;
-//	int		d;
-//	int		new[6];
-//	int		i;
-//	int		z;
-//	short	*zbuf;
-	movl	lp2(%esp),%esi
-	movl	lp1(%esp),%ebx
-	movl	lp3(%esp),%edi
-
-//	d = lp2[0] - lp1[0];
-//	if (d < -1 || d > 1)
-//		goto split;
-	movl	0(%esi),%eax
-
-	movl	0(%ebx),%edx
-	movl	4(%esi),%ebp
-
-	subl	%edx,%eax
-	movl	4(%ebx),%ecx
-
-	subl	%ecx,%ebp
-	incl	%eax
-
-	cmpl	$2,%eax
-	ja		LSplit
-
-//	d = lp2[1] - lp1[1];
-//	if (d < -1 || d > 1)
-//		goto split;
-	movl	0(%edi),%eax
-	incl	%ebp
-
-	cmpl	$2,%ebp
-	ja		LSplit
-
-//	d = lp3[0] - lp2[0];
-//	if (d < -1 || d > 1)
-//		goto split2;
-	movl	0(%esi),%edx
-	movl	4(%edi),%ebp
-
-	subl	%edx,%eax
-	movl	4(%esi),%ecx
-
-	subl	%ecx,%ebp
-	incl	%eax
-
-	cmpl	$2,%eax
-	ja		LSplit2
-
-//	d = lp3[1] - lp2[1];
-//	if (d < -1 || d > 1)
-//		goto split2;
-	movl	0(%ebx),%eax
-	incl	%ebp
-
-	cmpl	$2,%ebp
-	ja		LSplit2
-
-//	d = lp1[0] - lp3[0];
-//	if (d < -1 || d > 1)
-//		goto split3;
-	movl	0(%edi),%edx
-	movl	4(%ebx),%ebp
-
-	subl	%edx,%eax
-	movl	4(%edi),%ecx
-
-	subl	%ecx,%ebp
-	incl	%eax
-
-	incl	%ebp
-	movl	%ebx,%edx
-
-	cmpl	$2,%eax
-	ja		LSplit3
-
-//	d = lp1[1] - lp3[1];
-//	if (d < -1 || d > 1)
-//	{
-//split3:
-//		temp = lp1;
-//		lp3 = lp2;
-//		lp1 = lp3;
-//		lp2 = temp;
-//		goto split;
-//	}
-//
-//	return;			// entire tri is filled
-//
-	cmpl	$2,%ebp
-	jna		LDone
-
-LSplit3:
-	movl	%edi,%ebx
-	movl	%esi,%edi
-	movl	%edx,%esi
-	jmp		LSplit
-
-//split2:
-LSplit2:
-
-//	temp = lp1;
-//	lp1 = lp2;
-//	lp2 = lp3;
-//	lp3 = temp;
-	movl	%ebx,%eax
-	movl	%esi,%ebx
-	movl	%edi,%esi
-	movl	%eax,%edi
-
-//split:
-LSplit:
-
-	subl	$24,%esp		// allocate space for a new vertex
-
-//// split this edge
-//	new[0] = (lp1[0] + lp2[0]) >> 1;
-//	new[1] = (lp1[1] + lp2[1]) >> 1;
-//	new[2] = (lp1[2] + lp2[2]) >> 1;
-//	new[3] = (lp1[3] + lp2[3]) >> 1;
-//	new[5] = (lp1[5] + lp2[5]) >> 1;
-	movl	8(%ebx),%eax
-
-	movl	8(%esi),%edx
-	movl	12(%ebx),%ecx
-
-	addl	%edx,%eax
-	movl	12(%esi),%edx
-
-	sarl	$1,%eax
-	addl	%edx,%ecx
-
-	movl	%eax,8(%esp)
-	movl	20(%ebx),%eax
-
-	sarl	$1,%ecx
-	movl	20(%esi),%edx
-
-	movl	%ecx,12(%esp)
-	addl	%edx,%eax
-
-	movl	0(%ebx),%ecx
-	movl	0(%esi),%edx
-
-	sarl	$1,%eax
-	addl	%ecx,%edx
-
-	movl	%eax,20(%esp)
-	movl	4(%ebx),%eax
-
-	sarl	$1,%edx
-	movl	4(%esi),%ebp
-
-	movl	%edx,0(%esp)
-	addl	%eax,%ebp
-
-	sarl	$1,%ebp
-	movl	%ebp,4(%esp)
-
-//// draw the point if splitting a leading edge
-//	if (lp2[1] > lp1[1])
-//		goto nodraw;
-	cmpl	%eax,4(%esi)
-	jg		LNoDraw
-
-//	if ((lp2[1] == lp1[1]) && (lp2[0] < lp1[0]))
-//		goto nodraw;
-	movl	0(%esi),%edx
-	jnz		LDraw
-
-	cmpl	%ecx,%edx
-	jl		LNoDraw
-
-LDraw:
-
-// z = new[5] >> 16;
-	movl	20(%esp),%edx
-	movl	4(%esp),%ecx
-
-	sarl	$16,%edx
-	movl	0(%esp),%ebp
-
-//	zbuf = zspantable[new[1]] + new[0];
-	movl	C(zspantable)(,%ecx,4),%eax
-
-//	if (z >= *zbuf)
-//	{
-	cmpw	(%eax,%ebp,2),%dx
-	jnge	LNoDraw
-
-//		int		pix;
-//		
-//		*zbuf = z;
-	movw	%dx,(%eax,%ebp,2)
-
-//		pix = d_pcolormap[skintable[new[3]>>16][new[2]>>16]];
-	movl	12(%esp),%eax
-
-	sarl	$16,%eax
-	movl	8(%esp),%edx
-
-	sarl	$16,%edx
-	subl	%ecx,%ecx
-
-	movl	C(skintable)(,%eax,4),%eax
-	movl	4(%esp),%ebp
-
-	movb	(%eax,%edx,),%cl
-	movl	C(d_pcolormap),%edx
-
-	movb	(%edx,%ecx,),%dl
-	movl	0(%esp),%ecx
-
-//		d_viewbuffer[d_scantable[new[1]] + new[0]] = pix;
-	movl	C(d_scantable)(,%ebp,4),%eax
-	addl	%eax,%ecx
-	movl	C(d_viewbuffer),%eax
-	movb	%dl,(%eax,%ecx,1)
-
-//	}
-//
-//nodraw:
-LNoDraw:
-
-//// recursively continue
-//	D_PolysetRecursiveTriangle (lp3, lp1, new);
-	pushl	%esp
-	pushl	%ebx
-	pushl	%edi
-	call	C(D_PolysetRecursiveTriangle)
-
-//	D_PolysetRecursiveTriangle (lp3, new, lp2);
-	movl	%esp,%ebx
-	pushl	%esi
-	pushl	%ebx
-	pushl	%edi
-	call	C(D_PolysetRecursiveTriangle)
-	addl	$24,%esp
-
-LDone:
-	popl	%ebx				// restore register variables
-	popl	%edi
-	popl	%esi
-	popl	%ebp				// restore caller stack frame pointer
-	ret		$12
-
-
-//----------------------------------------------------------------------
-// 8-bpp horizontal span drawing code for affine polygons, with smooth
-// shading and no transparency
-//----------------------------------------------------------------------
-
-#define pspans	4+8
-
-.globl C(D_PolysetAff8Start)
-C(D_PolysetAff8Start):
-
-.globl C(D_PolysetDrawSpans8)
-C(D_PolysetDrawSpans8):
-	pushl	%esi				// preserve register variables
-	pushl	%ebx
-
-	movl	pspans(%esp),%esi	// point to the first span descriptor
-	movl	C(r_zistepx),%ecx
-
-	pushl	%ebp				// preserve caller's stack frame
-	pushl	%edi
-
-	rorl	$16,%ecx			// put high 16 bits of 1/z step in low word
-	movl	spanpackage_t_count(%esi),%edx
-
-	movl	%ecx,lzistepx
-
-LSpanLoop:
-
-//		lcount = d_aspancount - pspanpackage->count;
-//
-//		errorterm += erroradjustup;
-//		if (errorterm >= 0)
-//		{
-//			d_aspancount += d_countextrastep;
-//			errorterm -= erroradjustdown;
-//		}
-//		else
-//		{
-//			d_aspancount += ubasestep;
-//		}
-	movl	C(d_aspancount),%eax
-	subl	%edx,%eax
-
-	movl	C(erroradjustup),%edx
-	movl	C(errorterm),%ebx
-	addl	%edx,%ebx
-	js		LNoTurnover
-
-	movl	C(erroradjustdown),%edx
-	movl	C(d_countextrastep),%edi
-	subl	%edx,%ebx
-	movl	C(d_aspancount),%ebp
-	movl	%ebx,C(errorterm)
-	addl	%edi,%ebp
-	movl	%ebp,C(d_aspancount)
-	jmp		LRightEdgeStepped
-
-LNoTurnover:
-	movl	C(d_aspancount),%edi
-	movl	C(ubasestep),%edx
-	movl	%ebx,C(errorterm)
-	addl	%edx,%edi
-	movl	%edi,C(d_aspancount)
-
-LRightEdgeStepped:
-	cmpl	$1,%eax
-
-	jl		LNextSpan
-	jz		LExactlyOneLong
-
-//
-// set up advancetable
-//
-	movl	C(a_ststepxwhole),%ecx
-	movl	C(r_affinetridesc)+atd_skinwidth,%edx
-
-	movl	%ecx,advancetable+4	// advance base in t
-	addl	%edx,%ecx
-
-	movl	%ecx,advancetable	// advance extra in t
-	movl	C(a_tstepxfrac),%ecx
-
-	movw	C(r_lstepx),%cx
-	movl	%eax,%edx			// count
-
-	movl	%ecx,tstep
-	addl	$7,%edx
-
-	shrl	$3,%edx				// count of full and partial loops
-	movl	spanpackage_t_sfrac(%esi),%ebx
-
-	movw	%dx,%bx
-	movl	spanpackage_t_pz(%esi),%ecx
-
-	negl	%eax
-
-	movl	spanpackage_t_pdest(%esi),%edi
-	andl	$7,%eax		// 0->0, 1->7, 2->6, ... , 7->1
-
-	subl	%eax,%edi	// compensate for hardwired offsets
-	subl	%eax,%ecx
-
-	subl	%eax,%ecx
-	movl	spanpackage_t_tfrac(%esi),%edx
-
-	movw	spanpackage_t_light(%esi),%dx
-	movl	spanpackage_t_zi(%esi),%ebp
-
-	rorl	$16,%ebp	// put high 16 bits of 1/z in low word
-	pushl	%esi
-
-	movl	spanpackage_t_ptex(%esi),%esi
-	jmp		aff8entryvec_table(,%eax,4)
-
-// %bx = count of full and partial loops
-// %ebx high word = sfrac
-// %ecx = pz
-// %dx = light
-// %edx high word = tfrac
-// %esi = ptex
-// %edi = pdest
-// %ebp = 1/z
-// tstep low word = C(r_lstepx)
-// tstep high word = C(a_tstepxfrac)
-// C(a_sstepxfrac) low word = 0
-// C(a_sstepxfrac) high word = C(a_sstepxfrac)
-
-LDrawLoop:
-
-// FIXME: do we need to clamp light? We may need at least a buffer bit to
-// keep it from poking into tfrac and causing problems
-
-LDraw8:
-	cmpw	(%ecx),%bp
-	jl		Lp1
-	xorl	%eax,%eax
-	movb	%dh,%ah
-	movb	(%esi),%al
-	movw	%bp,(%ecx)
-	movb	0x12345678(%eax),%al
-LPatch8:
-	movb	%al,(%edi)
-Lp1:
-	addl	tstep,%edx
-	sbbl	%eax,%eax
-	addl	lzistepx,%ebp
-	adcl	$0,%ebp
-	addl	C(a_sstepxfrac),%ebx
-	adcl	advancetable+4(,%eax,4),%esi
-
-LDraw7:
-	cmpw	2(%ecx),%bp
-	jl		Lp2
-	xorl	%eax,%eax
-	movb	%dh,%ah
-	movb	(%esi),%al
-	movw	%bp,2(%ecx)
-	movb	0x12345678(%eax),%al
-LPatch7:
-	movb	%al,1(%edi)
-Lp2:
-	addl	tstep,%edx
-	sbbl	%eax,%eax
-	addl	lzistepx,%ebp
-	adcl	$0,%ebp
-	addl	C(a_sstepxfrac),%ebx
-	adcl	advancetable+4(,%eax,4),%esi
-
-LDraw6:
-	cmpw	4(%ecx),%bp
-	jl		Lp3
-	xorl	%eax,%eax
-	movb	%dh,%ah
-	movb	(%esi),%al
-	movw	%bp,4(%ecx)
-	movb	0x12345678(%eax),%al
-LPatch6:
-	movb	%al,2(%edi)
-Lp3:
-	addl	tstep,%edx
-	sbbl	%eax,%eax
-	addl	lzistepx,%ebp
-	adcl	$0,%ebp
-	addl	C(a_sstepxfrac),%ebx
-	adcl	advancetable+4(,%eax,4),%esi
-
-LDraw5:
-	cmpw	6(%ecx),%bp
-	jl		Lp4
-	xorl	%eax,%eax
-	movb	%dh,%ah
-	movb	(%esi),%al
-	movw	%bp,6(%ecx)
-	movb	0x12345678(%eax),%al
-LPatch5:
-	movb	%al,3(%edi)
-Lp4:
-	addl	tstep,%edx
-	sbbl	%eax,%eax
-	addl	lzistepx,%ebp
-	adcl	$0,%ebp
-	addl	C(a_sstepxfrac),%ebx
-	adcl	advancetable+4(,%eax,4),%esi
-
-LDraw4:
-	cmpw	8(%ecx),%bp
-	jl		Lp5
-	xorl	%eax,%eax
-	movb	%dh,%ah
-	movb	(%esi),%al
-	movw	%bp,8(%ecx)
-	movb	0x12345678(%eax),%al
-LPatch4:
-	movb	%al,4(%edi)
-Lp5:
-	addl	tstep,%edx
-	sbbl	%eax,%eax
-	addl	lzistepx,%ebp
-	adcl	$0,%ebp
-	addl	C(a_sstepxfrac),%ebx
-	adcl	advancetable+4(,%eax,4),%esi
-
-LDraw3:
-	cmpw	10(%ecx),%bp
-	jl		Lp6
-	xorl	%eax,%eax
-	movb	%dh,%ah
-	movb	(%esi),%al
-	movw	%bp,10(%ecx)
-	movb	0x12345678(%eax),%al
-LPatch3:
-	movb	%al,5(%edi)
-Lp6:
-	addl	tstep,%edx
-	sbbl	%eax,%eax
-	addl	lzistepx,%ebp
-	adcl	$0,%ebp
-	addl	C(a_sstepxfrac),%ebx
-	adcl	advancetable+4(,%eax,4),%esi
-
-LDraw2:
-	cmpw	12(%ecx),%bp
-	jl		Lp7
-	xorl	%eax,%eax
-	movb	%dh,%ah
-	movb	(%esi),%al
-	movw	%bp,12(%ecx)
-	movb	0x12345678(%eax),%al
-LPatch2:
-	movb	%al,6(%edi)
-Lp7:
-	addl	tstep,%edx
-	sbbl	%eax,%eax
-	addl	lzistepx,%ebp
-	adcl	$0,%ebp
-	addl	C(a_sstepxfrac),%ebx
-	adcl	advancetable+4(,%eax,4),%esi
-
-LDraw1:
-	cmpw	14(%ecx),%bp
-	jl		Lp8
-	xorl	%eax,%eax
-	movb	%dh,%ah
-	movb	(%esi),%al
-	movw	%bp,14(%ecx)
-	movb	0x12345678(%eax),%al
-LPatch1:
-	movb	%al,7(%edi)
-Lp8:
-	addl	tstep,%edx
-	sbbl	%eax,%eax
-	addl	lzistepx,%ebp
-	adcl	$0,%ebp
-	addl	C(a_sstepxfrac),%ebx
-	adcl	advancetable+4(,%eax,4),%esi
-
-	addl	$8,%edi
-	addl	$16,%ecx
-
-	decw	%bx
-	jnz		LDrawLoop
-
-	popl	%esi				// restore spans pointer
-LNextSpan:
-	addl	$(spanpackage_t_size),%esi	// point to next span
-LNextSpanESISet:
-	movl	spanpackage_t_count(%esi),%edx
-	cmpl	$-999999,%edx		// any more spans?
-	jnz		LSpanLoop			// yes
-
-	popl	%edi
-	popl	%ebp				// restore the caller's stack frame
-	popl	%ebx				// restore register variables
-	popl	%esi
-	ret
-
-
-// draw a one-long span
-
-LExactlyOneLong:
-
-	movl	spanpackage_t_pz(%esi),%ecx
-	movl	spanpackage_t_zi(%esi),%ebp
-
-	rorl	$16,%ebp	// put high 16 bits of 1/z in low word
-	movl	spanpackage_t_ptex(%esi),%ebx
-
-	cmpw	(%ecx),%bp
-	jl		LNextSpan
-	xorl	%eax,%eax
-	movl	spanpackage_t_pdest(%esi),%edi
-	movb	spanpackage_t_light+1(%esi),%ah
-	addl	$(spanpackage_t_size),%esi	// point to next span
-	movb	(%ebx),%al
-	movw	%bp,(%ecx)
-	movb	0x12345678(%eax),%al
-LPatch9:
-	movb	%al,(%edi)
-
-	jmp		LNextSpanESISet
-
-.globl C(D_PolysetAff8End)
-C(D_PolysetAff8End):
-
-
-#define pcolormap		4
-
-.globl C(D_Aff8Patch)
-C(D_Aff8Patch):
-	movl	pcolormap(%esp),%eax
-	movl	%eax,LPatch1-4
-	movl	%eax,LPatch2-4
-	movl	%eax,LPatch3-4
-	movl	%eax,LPatch4-4
-	movl	%eax,LPatch5-4
-	movl	%eax,LPatch6-4
-	movl	%eax,LPatch7-4
-	movl	%eax,LPatch8-4
-	movl	%eax,LPatch9-4
-
-	ret
-
-
-//----------------------------------------------------------------------
-// Alias model polygon dispatching code, combined with subdivided affine
-// triangle drawing code
-//----------------------------------------------------------------------
-
-.globl C(D_PolysetDraw)
-C(D_PolysetDraw):
-
-//	spanpackage_t	spans[DPS_MAXSPANS + 1 +
-//			((CACHE_SIZE - 1) / sizeof(spanpackage_t)) + 1];
-//						// one extra because of cache line pretouching
-//
-//	a_spans = (spanpackage_t *)
-//			(((long)&spans[0] + CACHE_SIZE - 1) & ~(CACHE_SIZE - 1));
-	subl	$(SPAN_SIZE),%esp
-	movl	%esp,%eax
-	addl	$(CACHE_SIZE - 1),%eax
-	andl	$(~(CACHE_SIZE - 1)),%eax
-	movl	%eax,C(a_spans)
-
-//	if (r_affinetridesc.drawtype)
-//		D_DrawSubdiv ();
-//	else
-//		D_DrawNonSubdiv ();
-	movl	C(r_affinetridesc)+atd_drawtype,%eax
-	testl	%eax,%eax
-	jz		C(D_DrawNonSubdiv)
-
-	pushl	%ebp				// preserve caller stack frame pointer
-
-//	lnumtriangles = r_affinetridesc.numtriangles;
-	movl	C(r_affinetridesc)+atd_numtriangles,%ebp
-
-	pushl	%esi				// preserve register variables
-	shll	$4,%ebp
-
-	pushl	%ebx
-//	ptri = r_affinetridesc.ptriangles;
-	movl	C(r_affinetridesc)+atd_ptriangles,%ebx
-
-	pushl	%edi
-
-//	mtriangle_t		*ptri;
-//	finalvert_t		*pfv, *index0, *index1, *index2;
-//	int				i;
-//	int				lnumtriangles;
-//	int				s0, s1, s2;
-
-//	pfv = r_affinetridesc.pfinalverts;
-	movl	C(r_affinetridesc)+atd_pfinalverts,%edi
-
-//	for (i=0 ; i<lnumtriangles ; i++)
-//	{
-
-Llooptop:
-
-//		index0 = pfv + ptri[i].vertindex[0];
-//		index1 = pfv + ptri[i].vertindex[1];
-//		index2 = pfv + ptri[i].vertindex[2];
-	movl	mtri_vertindex-16+0(%ebx,%ebp,),%ecx
-	movl	mtri_vertindex-16+4(%ebx,%ebp,),%esi
-
-	shll	$(fv_shift),%ecx
-	movl	mtri_vertindex-16+8(%ebx,%ebp,),%edx
-
-	shll	$(fv_shift),%esi
-	addl	%edi,%ecx
-
-	shll	$(fv_shift),%edx
-	addl	%edi,%esi
-
-	addl	%edi,%edx
-
-//		if (((index0->v[1]-index1->v[1]) *
-//				(index0->v[0]-index2->v[0]) -
-//				(index0->v[0]-index1->v[0])*(index0->v[1]-index2->v[1])) >= 0)
-//		{
-//			continue;
-//		}
-//
-//		d_pcolormap = &((byte *)acolormap)[index0->v[4] & 0xFF00];
-	fildl	fv_v+4(%ecx)	// i0v1
-	fildl	fv_v+4(%esi)	// i1v1 | i0v1
-	fildl	fv_v+0(%ecx)	// i0v0 | i1v1 | i0v1
-	fildl	fv_v+0(%edx)	// i2v0 | i0v0 | i1v1 | i0v1
-	fxch	%st(2)			// i1v1 | i0v0 | i2v0 | i0v1
-	fsubr	%st(3),%st(0)	// i0v1-i1v1 | i0v0 | i2v0 | i0v1
-	fildl	fv_v+0(%esi)	// i1v0 | i0v1-i1v1 | i0v0 | i2v0 | i0v1
-	fxch	%st(2)			// i0v0 | i0v1-i1v1 | i1v0 | i2v0 | i0v1
-	fsub	%st(0),%st(3)	// i0v0 | i0v1-i1v1 | i1v0 | i0v0-i2v0 | i0v1
-	fildl	fv_v+4(%edx)	// i2v1 | i0v0 | i0v1-i1v1 | i1v0 | i0v0-i2v0| i0v1
-	fxch	%st(1)			// i0v0 | i2v1 | i0v1-i1v1 | i1v0 | i0v0-i2v0| i0v1
-	fsubp	%st(0),%st(3)	// i2v1 | i0v1-i1v1 | i0v0-i1v0 | i0v0-i2v0 | i0v1
-	fxch	%st(1)			// i0v1-i1v1 | i2v1 | i0v0-i1v0 | i0v0-i2v0 | i0v1
-	fmulp	%st(0),%st(3)	// i2v1 | i0v0-i1v0 | i0v1-i1v1*i0v0-i2v0 | i0v1
-	fsubrp	%st(0),%st(3)	// i0v0-i1v0 | i0v1-i1v1*i0v0-i2v0 | i0v1-i2v1
-	movl	fv_v+16(%ecx),%eax
-	andl	$0xFF00,%eax
-	fmulp	%st(0),%st(2)	// i0v1-i1v1*i0v0-i2v0 | i0v0-i1v0*i0v1-i2v1
-	addl	C(acolormap),%eax
-	fsubp	%st(0),%st(1)	// (i0v1-i1v1)*(i0v0-i2v0)-(i0v0-i1v0)*(i0v1-i2v1)
-	movl	%eax,C(d_pcolormap)
-	fstps	Ltemp
-	movl	Ltemp,%eax
-	subl	$0x80000001,%eax
-	jc		Lskip
-
-//		if (ptri[i].facesfront)
-//		{
-//			D_PolysetRecursiveTriangle(index0->v, index1->v, index2->v);
-	movl	mtri_facesfront-16(%ebx,%ebp,),%eax
-	testl	%eax,%eax
-	jz		Lfacesback
-
-	pushl	%edx
-	pushl	%esi
-	pushl	%ecx
-	call	C(D_PolysetRecursiveTriangle)
-
-	subl	$16,%ebp
-	jnz		Llooptop
-	jmp		Ldone2
-
-//		}
-//		else
-//		{
-Lfacesback:
-
-//			s0 = index0->v[2];
-//			s1 = index1->v[2];
-//			s2 = index2->v[2];
-	movl	fv_v+8(%ecx),%eax
-	pushl	%eax
-	movl	fv_v+8(%esi),%eax
-	pushl	%eax
-	movl	fv_v+8(%edx),%eax
-	pushl	%eax
-	pushl	%ecx
-	pushl	%edx
-
-//			if (index0->flags & ALIAS_ONSEAM)
-//				index0->v[2] += r_affinetridesc.seamfixupX16;
-	movl	C(r_affinetridesc)+atd_seamfixupX16,%eax
-	testl	$(ALIAS_ONSEAM),fv_flags(%ecx)
-	jz		Lp11
-	addl	%eax,fv_v+8(%ecx)
-Lp11:
-
-//			if (index1->flags & ALIAS_ONSEAM)
-//				index1->v[2] += r_affinetridesc.seamfixupX16;
-	testl	$(ALIAS_ONSEAM),fv_flags(%esi)
-	jz		Lp12
-	addl	%eax,fv_v+8(%esi)
-Lp12:
-
-//			if (index2->flags & ALIAS_ONSEAM)
-//				index2->v[2] += r_affinetridesc.seamfixupX16;
-	testl	$(ALIAS_ONSEAM),fv_flags(%edx)
-	jz		Lp13
-	addl	%eax,fv_v+8(%edx)
-Lp13:
-
-//			D_PolysetRecursiveTriangle(index0->v, index1->v, index2->v);
-	pushl	%edx
-	pushl	%esi
-	pushl	%ecx
-	call	C(D_PolysetRecursiveTriangle)
-
-//			index0->v[2] = s0;
-//			index1->v[2] = s1;
-//			index2->v[2] = s2;
-	popl	%edx
-	popl	%ecx
-	popl	%eax
-	movl	%eax,fv_v+8(%edx)
-	popl	%eax
-	movl	%eax,fv_v+8(%esi)
-	popl	%eax
-	movl	%eax,fv_v+8(%ecx)
-
-//		}
-//	}
-Lskip:
-	subl	$16,%ebp
-	jnz		Llooptop
-
-Ldone2:
-	popl	%edi				// restore the caller's stack frame
-	popl	%ebx
-	popl	%esi				// restore register variables
-	popl	%ebp
-
-	addl	$(SPAN_SIZE),%esp
-
-	ret
-
-
-//----------------------------------------------------------------------
-// Alias model triangle left-edge scanning code
-//----------------------------------------------------------------------
-
-#define height	4+16
-
-.globl C(D_PolysetScanLeftEdge)
-C(D_PolysetScanLeftEdge):
-	pushl	%ebp				// preserve caller stack frame pointer
-	pushl	%esi				// preserve register variables
-	pushl	%edi
-	pushl	%ebx
-
-	movl	height(%esp),%eax
-	movl	C(d_sfrac),%ecx
-	andl	$0xFFFF,%eax
-	movl	C(d_ptex),%ebx
-	orl		%eax,%ecx
-	movl	C(d_pedgespanpackage),%esi
-	movl	C(d_tfrac),%edx
-	movl	C(d_light),%edi
-	movl	C(d_zi),%ebp
-
-// %eax: scratch
-// %ebx: d_ptex
-// %ecx: d_sfrac in high word, count in low word
-// %edx: d_tfrac
-// %esi: d_pedgespanpackage, errorterm, scratch alternately
-// %edi: d_light
-// %ebp: d_zi
-
-//	do
-//	{
-
-LScanLoop:
-
-//		d_pedgespanpackage->ptex = ptex;
-//		d_pedgespanpackage->pdest = d_pdest;
-//		d_pedgespanpackage->pz = d_pz;
-//		d_pedgespanpackage->count = d_aspancount;
-//		d_pedgespanpackage->light = d_light;
-//		d_pedgespanpackage->zi = d_zi;
-//		d_pedgespanpackage->sfrac = d_sfrac << 16;
-//		d_pedgespanpackage->tfrac = d_tfrac << 16;
-	movl	%ebx,spanpackage_t_ptex(%esi)
-	movl	C(d_pdest),%eax
-	movl	%eax,spanpackage_t_pdest(%esi)
-	movl	C(d_pz),%eax
-	movl	%eax,spanpackage_t_pz(%esi)
-	movl	C(d_aspancount),%eax
-	movl	%eax,spanpackage_t_count(%esi)
-	movl	%edi,spanpackage_t_light(%esi)
-	movl	%ebp,spanpackage_t_zi(%esi)
-	movl	%ecx,spanpackage_t_sfrac(%esi)
-	movl	%edx,spanpackage_t_tfrac(%esi)
-
-// pretouch the next cache line
-	movb	spanpackage_t_size(%esi),%al
-
-//		d_pedgespanpackage++;
-	addl	$(spanpackage_t_size),%esi
-	movl	C(erroradjustup),%eax
-	movl	%esi,C(d_pedgespanpackage)
-
-//		errorterm += erroradjustup;
-	movl	C(errorterm),%esi
-	addl	%eax,%esi
-	movl	C(d_pdest),%eax
-
-//		if (errorterm >= 0)
-//		{
-	js		LNoLeftEdgeTurnover
-
-//			errorterm -= erroradjustdown;
-//			d_pdest += d_pdestextrastep;
-	subl	C(erroradjustdown),%esi
-	addl	C(d_pdestextrastep),%eax
-	movl	%esi,C(errorterm)
-	movl	%eax,C(d_pdest)
-
-//			d_pz += d_pzextrastep;
-//			d_aspancount += d_countextrastep;
-//			d_ptex += d_ptexextrastep;
-//			d_sfrac += d_sfracextrastep;
-//			d_ptex += d_sfrac >> 16;
-//			d_sfrac &= 0xFFFF;
-//			d_tfrac += d_tfracextrastep;
-	movl	C(d_pz),%eax
-	movl	C(d_aspancount),%esi
-	addl	C(d_pzextrastep),%eax
-	addl	C(d_sfracextrastep),%ecx
-	adcl	C(d_ptexextrastep),%ebx
-	addl	C(d_countextrastep),%esi
-	movl	%eax,C(d_pz)
-	movl	C(d_tfracextrastep),%eax
-	movl	%esi,C(d_aspancount)
-	addl	%eax,%edx
-
-//			if (d_tfrac & 0x10000)
-//			{
-	jnc		LSkip1
-
-//				d_ptex += r_affinetridesc.skinwidth;
-//				d_tfrac &= 0xFFFF;
-	addl	C(r_affinetridesc)+atd_skinwidth,%ebx
-
-//			}
-
-LSkip1:
-
-//			d_light += d_lightextrastep;
-//			d_zi += d_ziextrastep;
-	addl	C(d_lightextrastep),%edi
-	addl	C(d_ziextrastep),%ebp
-
-//		}
-	movl	C(d_pedgespanpackage),%esi
-	decl	%ecx
-	testl	$0xFFFF,%ecx
-	jnz		LScanLoop
-
-	popl	%ebx
-	popl	%edi
-	popl	%esi
-	popl	%ebp
-	ret
-
-//		else
-//		{
-
-LNoLeftEdgeTurnover:
-	movl	%esi,C(errorterm)
-
-//			d_pdest += d_pdestbasestep;
-	addl	C(d_pdestbasestep),%eax
-	movl	%eax,C(d_pdest)
-
-//			d_pz += d_pzbasestep;
-//			d_aspancount += ubasestep;
-//			d_ptex += d_ptexbasestep;
-//			d_sfrac += d_sfracbasestep;
-//			d_ptex += d_sfrac >> 16;
-//			d_sfrac &= 0xFFFF;
-	movl	C(d_pz),%eax
-	movl	C(d_aspancount),%esi
-	addl	C(d_pzbasestep),%eax
-	addl	C(d_sfracbasestep),%ecx
-	adcl	C(d_ptexbasestep),%ebx
-	addl	C(ubasestep),%esi
-	movl	%eax,C(d_pz)
-	movl	%esi,C(d_aspancount)
-
-//			d_tfrac += d_tfracbasestep;
-	movl	C(d_tfracbasestep),%esi
-	addl	%esi,%edx
-
-//			if (d_tfrac & 0x10000)
-//			{
-	jnc		LSkip2
-
-//				d_ptex += r_affinetridesc.skinwidth;
-//				d_tfrac &= 0xFFFF;
-	addl	C(r_affinetridesc)+atd_skinwidth,%ebx
-
-//			}
-
-LSkip2:
-
-//			d_light += d_lightbasestep;
-//			d_zi += d_zibasestep;
-	addl	C(d_lightbasestep),%edi
-	addl	C(d_zibasestep),%ebp
-
-//		}
-//	} while (--height);
-	movl	C(d_pedgespanpackage),%esi
-	decl	%ecx
-	testl	$0xFFFF,%ecx
-	jnz		LScanLoop
-
-	popl	%ebx
-	popl	%edi
-	popl	%esi
-	popl	%ebp
-	ret
-
-
-//----------------------------------------------------------------------
-// Alias model vertex drawing code
-//----------------------------------------------------------------------
-
-#define fv			4+8
-#define	numverts	8+8
-
-.globl C(D_PolysetDrawFinalVerts)
-C(D_PolysetDrawFinalVerts):
-	pushl	%ebp				// preserve caller stack frame pointer
-	pushl	%ebx
-
-//	int		i, z;
-//	short	*zbuf;
-
-	movl	numverts(%esp),%ecx
-	movl	fv(%esp),%ebx
-
-	pushl	%esi				// preserve register variables
-	pushl	%edi
-
-LFVLoop:
-
-//	for (i=0 ; i<numverts ; i++, fv++)
-//	{
-//	// valid triangle coordinates for filling can include the bottom and
-//	// right clip edges, due to the fill rule; these shouldn't be drawn
-//		if ((fv->v[0] < r_refdef.vrectright) &&
-//			(fv->v[1] < r_refdef.vrectbottom))
-//		{
-	movl	fv_v+0(%ebx),%eax
-	movl	C(r_refdef)+rd_vrectright,%edx
-	cmpl	%edx,%eax
-	jge		LNextVert
-	movl	fv_v+4(%ebx),%esi
-	movl	C(r_refdef)+rd_vrectbottom,%edx
-	cmpl	%edx,%esi
-	jge		LNextVert
-
-//			zbuf = zspantable[fv->v[1]] + fv->v[0];
-	movl	C(zspantable)(,%esi,4),%edi
-
-//			z = fv->v[5]>>16;
-	movl	fv_v+20(%ebx),%edx
-	shrl	$16,%edx
-
-//			if (z >= *zbuf)
-//			{
-//				int		pix;
-	cmpw	(%edi,%eax,2),%dx
-	jl		LNextVert
-
-//				*zbuf = z;
-	movw	%dx,(%edi,%eax,2)
-
-//				pix = skintable[fv->v[3]>>16][fv->v[2]>>16];
-	movl	fv_v+12(%ebx),%edi
-	shrl	$16,%edi
-	movl	C(skintable)(,%edi,4),%edi
-	movl	fv_v+8(%ebx),%edx
-	shrl	$16,%edx
-	movb	(%edi,%edx),%dl
-
-//				pix = ((byte *)acolormap)[pix + (fv->v[4] & 0xFF00)];
-	movl	fv_v+16(%ebx),%edi
-	andl	$0xFF00,%edi
-	andl	$0x00FF,%edx
-	addl	%edx,%edi
-	movl	C(acolormap),%edx
-	movb	(%edx,%edi,1),%dl
-
-//				d_viewbuffer[d_scantable[fv->v[1]] + fv->v[0]] = pix;
-	movl	C(d_scantable)(,%esi,4),%edi
-	movl	C(d_viewbuffer),%esi
-	addl	%eax,%edi
-	movb	%dl,(%esi,%edi)
-
-//			}
-//		}
-//	}
-LNextVert:
-	addl	$(fv_size),%ebx
-	decl	%ecx
-	jnz		LFVLoop
-
-	popl	%edi
-	popl	%esi
-	popl	%ebx
-	popl	%ebp
-	ret
-
-
-//----------------------------------------------------------------------
-// Alias model non-subdivided polygon dispatching code
-//
-// not C-callable because of stack buffer cleanup
-//----------------------------------------------------------------------
-
-.globl C(D_DrawNonSubdiv)
-C(D_DrawNonSubdiv):
-	pushl	%ebp				// preserve caller stack frame pointer
-	movl	C(r_affinetridesc)+atd_numtriangles,%ebp
-	pushl	%ebx
-	shll	$(mtri_shift),%ebp
-	pushl	%esi				// preserve register variables
-	movl	C(r_affinetridesc)+atd_ptriangles,%esi
-	pushl	%edi
-
-//	mtriangle_t		*ptri;
-//	finalvert_t		*pfv, *index0, *index1, *index2;
-//	int				i;
-//	int				lnumtriangles;
-
-//	pfv = r_affinetridesc.pfinalverts;
-//	ptri = r_affinetridesc.ptriangles;
-//	lnumtriangles = r_affinetridesc.numtriangles;
-
-LNDLoop:
-
-//	for (i=0 ; i<lnumtriangles ; i++, ptri++)
-//	{
-//		index0 = pfv + ptri->vertindex[0];
-//		index1 = pfv + ptri->vertindex[1];
-//		index2 = pfv + ptri->vertindex[2];
-	movl	C(r_affinetridesc)+atd_pfinalverts,%edi
-	movl	mtri_vertindex+0-mtri_size(%esi,%ebp,1),%ecx
-	shll	$(fv_shift),%ecx
-	movl	mtri_vertindex+4-mtri_size(%esi,%ebp,1),%edx
-	shll	$(fv_shift),%edx
-	movl	mtri_vertindex+8-mtri_size(%esi,%ebp,1),%ebx
-	shll	$(fv_shift),%ebx
-	addl	%edi,%ecx
-	addl	%edi,%edx
-	addl	%edi,%ebx
-
-//		d_xdenom = (index0->v[1]-index1->v[1]) *
-//				(index0->v[0]-index2->v[0]) -
-//				(index0->v[0]-index1->v[0])*(index0->v[1]-index2->v[1]);
-	movl	fv_v+4(%ecx),%eax
-	movl	fv_v+0(%ecx),%esi
-	subl	fv_v+4(%edx),%eax
-	subl	fv_v+0(%ebx),%esi
-	imull	%esi,%eax
-	movl	fv_v+0(%ecx),%esi
-	movl	fv_v+4(%ecx),%edi
-	subl	fv_v+0(%edx),%esi
-	subl	fv_v+4(%ebx),%edi
-	imull	%esi,%edi
-	subl	%edi,%eax
-
-//		if (d_xdenom >= 0)
-//		{
-//			continue;
-	jns		LNextTri
-
-//		}
-
-	movl	%eax,C(d_xdenom)
-	fildl	C(d_xdenom)
-
-//		r_p0[0] = index0->v[0];		// u
-//		r_p0[1] = index0->v[1];		// v
-//		r_p0[2] = index0->v[2];		// s
-//		r_p0[3] = index0->v[3];		// t
-//		r_p0[4] = index0->v[4];		// light
-//		r_p0[5] = index0->v[5];		// iz
-	movl	fv_v+0(%ecx),%eax
-	movl	fv_v+4(%ecx),%esi
-	movl	%eax,C(r_p0)+0
-	movl	%esi,C(r_p0)+4
-	movl	fv_v+8(%ecx),%eax
-	movl	fv_v+12(%ecx),%esi
-	movl	%eax,C(r_p0)+8
-	movl	%esi,C(r_p0)+12
-	movl	fv_v+16(%ecx),%eax
-	movl	fv_v+20(%ecx),%esi
-	movl	%eax,C(r_p0)+16
-	movl	%esi,C(r_p0)+20
-
-	fdivrs	float_1
-
-//		r_p1[0] = index1->v[0];
-//		r_p1[1] = index1->v[1];
-//		r_p1[2] = index1->v[2];
-//		r_p1[3] = index1->v[3];
-//		r_p1[4] = index1->v[4];
-//		r_p1[5] = index1->v[5];
-	movl	fv_v+0(%edx),%eax
-	movl	fv_v+4(%edx),%esi
-	movl	%eax,C(r_p1)+0
-	movl	%esi,C(r_p1)+4
-	movl	fv_v+8(%edx),%eax
-	movl	fv_v+12(%edx),%esi
-	movl	%eax,C(r_p1)+8
-	movl	%esi,C(r_p1)+12
-	movl	fv_v+16(%edx),%eax
-	movl	fv_v+20(%edx),%esi
-	movl	%eax,C(r_p1)+16
-	movl	%esi,C(r_p1)+20
-
-//		r_p2[0] = index2->v[0];
-//		r_p2[1] = index2->v[1];
-//		r_p2[2] = index2->v[2];
-//		r_p2[3] = index2->v[3];
-//		r_p2[4] = index2->v[4];
-//		r_p2[5] = index2->v[5];
-	movl	fv_v+0(%ebx),%eax
-	movl	fv_v+4(%ebx),%esi
-	movl	%eax,C(r_p2)+0
-	movl	%esi,C(r_p2)+4
-	movl	fv_v+8(%ebx),%eax
-	movl	fv_v+12(%ebx),%esi
-	movl	%eax,C(r_p2)+8
-	movl	%esi,C(r_p2)+12
-	movl	fv_v+16(%ebx),%eax
-	movl	fv_v+20(%ebx),%esi
-	movl	%eax,C(r_p2)+16
-	movl	C(r_affinetridesc)+atd_ptriangles,%edi
-	movl	%esi,C(r_p2)+20
-	movl	mtri_facesfront-mtri_size(%edi,%ebp,1),%eax
-
-//		if (!ptri->facesfront)
-//		{
-	testl	%eax,%eax
-	jnz		LFacesFront
-
-//			if (index0->flags & ALIAS_ONSEAM)
-//				r_p0[2] += r_affinetridesc.seamfixupX16;
-	movl	fv_flags(%ecx),%eax
-	movl	fv_flags(%edx),%esi
-	movl	fv_flags(%ebx),%edi
-	testl	$(ALIAS_ONSEAM),%eax
-	movl	C(r_affinetridesc)+atd_seamfixupX16,%eax
-	jz		LOnseamDone0
-	addl	%eax,C(r_p0)+8
-LOnseamDone0:
-
-//			if (index1->flags & ALIAS_ONSEAM)
-// 				r_p1[2] += r_affinetridesc.seamfixupX16;
-	testl	$(ALIAS_ONSEAM),%esi
-	jz		LOnseamDone1
-	addl	%eax,C(r_p1)+8
-LOnseamDone1:
-
-//			if (index2->flags & ALIAS_ONSEAM)
-//				r_p2[2] += r_affinetridesc.seamfixupX16;
-	testl	$(ALIAS_ONSEAM),%edi
-	jz		LOnseamDone2
-	addl	%eax,C(r_p2)+8
-LOnseamDone2:
-
-//		}
-
-LFacesFront:
-
-	fstps	C(d_xdenom)
-
-//		D_PolysetSetEdgeTable ();
-//		D_RasterizeAliasPolySmooth ();
-		call	C(D_PolysetSetEdgeTable)
-		call	C(D_RasterizeAliasPolySmooth)
-
-LNextTri:
-		movl	C(r_affinetridesc)+atd_ptriangles,%esi
-		subl	$16,%ebp
-		jnz		LNDLoop
-//	}
-
-	popl	%edi
-	popl	%esi
-	popl	%ebx
-	popl	%ebp
-
-	addl	$(SPAN_SIZE),%esp
-
-	ret
-
-
-#endif	// id386
-
diff -ruN WinQuake/d_scana.S sdlquake-1.0.9/d_scana.S
--- WinQuake/d_scana.S	Wed Dec 31 16:00:00 1969
+++ sdlquake-1.0.9/d_scana.S	Sat Dec 25 03:38:02 1999
@@ -0,0 +1,89 @@
+/*
+Copyright (C) 1996-1997 Id Software, Inc.
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation; either version 2
+of the License, or (at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
+
+See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+//
+// d_scana.s
+// x86 assembly-language turbulent texture mapping code
+//
+
+#include "asm_i386.h"
+#include "quakeasm.h"
+#include "asm_draw.h"
+#include "d_ifacea.h"
+
+#if id386
+
+	.data
+
+	.text
+
+//----------------------------------------------------------------------
+// turbulent texture mapping code
+//----------------------------------------------------------------------
+
+	.align 4
+.globl C(D_DrawTurbulent8Span)
+C(D_DrawTurbulent8Span):
+	pushl	%ebp				// preserve caller's stack frame pointer
+	pushl	%esi				// preserve register variables
+	pushl	%edi
+	pushl	%ebx
+
+	movl	C(r_turb_s),%esi
+	movl	C(r_turb_t),%ecx
+	movl	C(r_turb_pdest),%edi
+	movl	C(r_turb_spancount),%ebx
+
+Llp:
+	movl	%ecx,%eax
+	movl	%esi,%edx
+	sarl	$16,%eax
+	movl	C(r_turb_turb),%ebp
+	sarl	$16,%edx
+	andl	$(CYCLE-1),%eax
+	andl	$(CYCLE-1),%edx
+	movl	(%ebp,%eax,4),%eax
+	movl	(%ebp,%edx,4),%edx
+	addl	%esi,%eax
+	sarl	$16,%eax
+	addl	%ecx,%edx
+	sarl	$16,%edx
+	andl	$(TURB_TEX_SIZE-1),%eax
+	andl	$(TURB_TEX_SIZE-1),%edx
+	shll	$6,%edx
+	movl	C(r_turb_pbase),%ebp
+	addl	%eax,%edx
+	incl	%edi
+	addl	C(r_turb_sstep),%esi
+	addl	C(r_turb_tstep),%ecx
+	movb	(%ebp,%edx,1),%dl
+	decl	%ebx
+	movb	%dl,-1(%edi)
+	jnz		Llp
+
+	movl	%edi,C(r_turb_pdest)
+
+	popl	%ebx				// restore register variables
+	popl	%edi
+	popl	%esi
+	popl	%ebp				// restore caller's stack frame pointer
+	ret
+
+#endif	// id386
+
diff -ruN WinQuake/d_scana.s sdlquake-1.0.9/d_scana.s
--- WinQuake/d_scana.s	Tue Dec 21 15:53:24 1999
+++ sdlquake-1.0.9/d_scana.s	Wed Dec 31 16:00:00 1969
@@ -1,89 +0,0 @@
-/*
-Copyright (C) 1996-1997 Id Software, Inc.
-
-This program is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License
-as published by the Free Software Foundation; either version 2
-of the License, or (at your option) any later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
-
-See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-*/
-//
-// d_scana.s
-// x86 assembly-language turbulent texture mapping code
-//
-
-#include "asm_i386.h"
-#include "quakeasm.h"
-#include "asm_draw.h"
-#include "d_ifacea.h"
-
-#if id386
-
-	.data
-
-	.text
-
-//----------------------------------------------------------------------
-// turbulent texture mapping code
-//----------------------------------------------------------------------
-
-	.align 4
-.globl C(D_DrawTurbulent8Span)
-C(D_DrawTurbulent8Span):
-	pushl	%ebp				// preserve caller's stack frame pointer
-	pushl	%esi				// preserve register variables
-	pushl	%edi
-	pushl	%ebx
-
-	movl	C(r_turb_s),%esi
-	movl	C(r_turb_t),%ecx
-	movl	C(r_turb_pdest),%edi
-	movl	C(r_turb_spancount),%ebx
-
-Llp:
-	movl	%ecx,%eax
-	movl	%esi,%edx
-	sarl	$16,%eax
-	movl	C(r_turb_turb),%ebp
-	sarl	$16,%edx
-	andl	$(CYCLE-1),%eax
-	andl	$(CYCLE-1),%edx
-	movl	(%ebp,%eax,4),%eax
-	movl	(%ebp,%edx,4),%edx
-	addl	%esi,%eax
-	sarl	$16,%eax
-	addl	%ecx,%edx
-	sarl	$16,%edx
-	andl	$(TURB_TEX_SIZE-1),%eax
-	andl	$(TURB_TEX_SIZE-1),%edx
-	shll	$6,%edx
-	movl	C(r_turb_pbase),%ebp
-	addl	%eax,%edx
-	incl	%edi
-	addl	C(r_turb_sstep),%esi
-	addl	C(r_turb_tstep),%ecx
-	movb	(%ebp,%edx,1),%dl
-	decl	%ebx
-	movb	%dl,-1(%edi)
-	jnz		Llp
-
-	movl	%edi,C(r_turb_pdest)
-
-	popl	%ebx				// restore register variables
-	popl	%edi
-	popl	%esi
-	popl	%ebp				// restore caller's stack frame pointer
-	ret
-
-#endif	// id386
-
diff -ruN WinQuake/d_spr8.S sdlquake-1.0.9/d_spr8.S
--- WinQuake/d_spr8.S	Wed Dec 31 16:00:00 1969
+++ sdlquake-1.0.9/d_spr8.S	Sat Dec 25 03:38:02 1999
@@ -0,0 +1,900 @@
+/*
+Copyright (C) 1996-1997 Id Software, Inc.
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation; either version 2
+of the License, or (at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
+
+See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+//
+// d_spr8.s
+// x86 assembly-language horizontal 8-bpp transparent span-drawing code.
+//
+
+#include "asm_i386.h"
+#include "quakeasm.h"
+#include "asm_draw.h"
+
+#if id386
+
+//----------------------------------------------------------------------
+// 8-bpp horizontal span drawing code for polygons, with transparency.
+//----------------------------------------------------------------------
+
+	.text
+
+// out-of-line, rarely-needed clamping code
+
+LClampHigh0:
+	movl	C(bbextents),%esi
+	jmp		LClampReentry0
+LClampHighOrLow0:
+	jg		LClampHigh0
+	xorl	%esi,%esi
+	jmp		LClampReentry0
+
+LClampHigh1:
+	movl	C(bbextentt),%edx
+	jmp		LClampReentry1
+LClampHighOrLow1:
+	jg		LClampHigh1
+	xorl	%edx,%edx
+	jmp		LClampReentry1
+
+LClampLow2:
+	movl	$2048,%ebp
+	jmp		LClampReentry2
+LClampHigh2:
+	movl	C(bbextents),%ebp
+	jmp		LClampReentry2
+
+LClampLow3:
+	movl	$2048,%ecx
+	jmp		LClampReentry3
+LClampHigh3:
+	movl	C(bbextentt),%ecx
+	jmp		LClampReentry3
+
+LClampLow4:
+	movl	$2048,%eax
+	jmp		LClampReentry4
+LClampHigh4:
+	movl	C(bbextents),%eax
+	jmp		LClampReentry4
+
+LClampLow5:
+	movl	$2048,%ebx
+	jmp		LClampReentry5
+LClampHigh5:
+	movl	C(bbextentt),%ebx
+	jmp		LClampReentry5
+
+
+#define pspans	4+16
+
+	.align 4
+.globl C(D_SpriteDrawSpans)
+C(D_SpriteDrawSpans):
+	pushl	%ebp				// preserve caller's stack frame
+	pushl	%edi
+	pushl	%esi				// preserve register variables
+	pushl	%ebx
+
+//
+// set up scaled-by-8 steps, for 8-long segments; also set up cacheblock
+// and span list pointers, and 1/z step in 0.32 fixed-point
+//
+// FIXME: any overlap from rearranging?
+	flds	C(d_sdivzstepu)
+	fmuls	fp_8
+	movl	C(cacheblock),%edx
+	flds	C(d_tdivzstepu)
+	fmuls	fp_8
+	movl	pspans(%esp),%ebx	// point to the first span descriptor
+	flds	C(d_zistepu)
+	fmuls	fp_8
+	movl	%edx,pbase			// pbase = cacheblock
+	flds	C(d_zistepu)
+	fmuls	fp_64kx64k
+	fxch	%st(3)
+	fstps	sdivz8stepu
+	fstps	zi8stepu
+	fstps	tdivz8stepu
+	fistpl	izistep
+	movl	izistep,%eax
+	rorl	$16,%eax		// put upper 16 bits in low word
+	movl	sspan_t_count(%ebx),%ecx
+	movl	%eax,izistep
+
+	cmpl	$0,%ecx
+	jle		LNextSpan
+
+LSpanLoop:
+
+//
+// set up the initial s/z, t/z, and 1/z on the FP stack, and generate the
+// initial s and t values
+//
+// FIXME: pipeline FILD?
+	fildl	sspan_t_v(%ebx)
+	fildl	sspan_t_u(%ebx)
+
+	fld		%st(1)			// dv | du | dv
+	fmuls	C(d_sdivzstepv)	// dv*d_sdivzstepv | du | dv
+	fld		%st(1)			// du | dv*d_sdivzstepv | du | dv
+	fmuls	C(d_sdivzstepu)	// du*d_sdivzstepu | dv*d_sdivzstepv | du | dv
+	fld		%st(2)			// du | du*d_sdivzstepu | dv*d_sdivzstepv | du | dv
+	fmuls	C(d_tdivzstepu)	// du*d_tdivzstepu | du*d_sdivzstepu |
+							//  dv*d_sdivzstepv | du | dv
+	fxch	%st(1)			// du*d_sdivzstepu | du*d_tdivzstepu |
+							//  dv*d_sdivzstepv | du | dv
+	faddp	%st(0),%st(2)	// du*d_tdivzstepu |
+							//  du*d_sdivzstepu + dv*d_sdivzstepv | du | dv
+	fxch	%st(1)			// du*d_sdivzstepu + dv*d_sdivzstepv |
+							//  du*d_tdivzstepu | du | dv
+	fld		%st(3)			// dv | du*d_sdivzstepu + dv*d_sdivzstepv |
+							//  du*d_tdivzstepu | du | dv
+	fmuls	C(d_tdivzstepv)	// dv*d_tdivzstepv |
+							//  du*d_sdivzstepu + dv*d_sdivzstepv |
+							//  du*d_tdivzstepu | du | dv
+	fxch	%st(1)			// du*d_sdivzstepu + dv*d_sdivzstepv |
+							//  dv*d_tdivzstepv | du*d_tdivzstepu | du | dv
+	fadds	C(d_sdivzorigin) // sdivz = d_sdivzorigin + dv*d_sdivzstepv +
+							//  du*d_sdivzstepu; stays in %st(2) at end
+	fxch	%st(4)			// dv | dv*d_tdivzstepv | du*d_tdivzstepu | du |
+							//  s/z
+	fmuls	C(d_zistepv)		// dv*d_zistepv | dv*d_tdivzstepv |
+							//  du*d_tdivzstepu | du | s/z
+	fxch	%st(1)			// dv*d_tdivzstepv |  dv*d_zistepv |
+							//  du*d_tdivzstepu | du | s/z
+	faddp	%st(0),%st(2)	// dv*d_zistepv |
+							//  dv*d_tdivzstepv + du*d_tdivzstepu | du | s/z
+	fxch	%st(2)			// du | dv*d_tdivzstepv + du*d_tdivzstepu |
+							//  dv*d_zistepv | s/z
+	fmuls	C(d_zistepu)		// du*d_zistepu |
+							//  dv*d_tdivzstepv + du*d_tdivzstepu |
+							//  dv*d_zistepv | s/z
+	fxch	%st(1)			// dv*d_tdivzstepv + du*d_tdivzstepu |
+							//  du*d_zistepu | dv*d_zistepv | s/z
+	fadds	C(d_tdivzorigin)	// tdivz = d_tdivzorigin + dv*d_tdivzstepv +
+							//  du*d_tdivzstepu; stays in %st(1) at end
+	fxch	%st(2)			// dv*d_zistepv | du*d_zistepu | t/z | s/z
+	faddp	%st(0),%st(1)	// dv*d_zistepv + du*d_zistepu | t/z | s/z
+
+	flds	fp_64k			// fp_64k | dv*d_zistepv + du*d_zistepu | t/z | s/z
+	fxch	%st(1)			// dv*d_zistepv + du*d_zistepu | fp_64k | t/z | s/z
+	fadds	C(d_ziorigin)		// zi = d_ziorigin + dv*d_zistepv +
+							//  du*d_zistepu; stays in %st(0) at end
+							// 1/z | fp_64k | t/z | s/z
+
+	fld		%st(0)			// FIXME: get rid of stall on FMUL?
+	fmuls	fp_64kx64k
+	fxch	%st(1)
+
+//
+// calculate and clamp s & t
+//
+	fdivr	%st(0),%st(2)	// 1/z | z*64k | t/z | s/z
+	fxch	%st(1)
+
+	fistpl	izi				// 0.32 fixed-point 1/z
+	movl	izi,%ebp
+
+//
+// set pz to point to the first z-buffer pixel in the span
+//
+	rorl	$16,%ebp		// put upper 16 bits in low word
+	movl	sspan_t_v(%ebx),%eax
+	movl	%ebp,izi
+	movl	sspan_t_u(%ebx),%ebp
+	imull	C(d_zrowbytes)
+	shll	$1,%ebp					// a word per pixel
+	addl	C(d_pzbuffer),%eax
+	addl	%ebp,%eax
+	movl	%eax,pz
+
+//
+// point %edi to the first pixel in the span
+//
+	movl	C(d_viewbuffer),%ebp
+	movl	sspan_t_v(%ebx),%eax
+	pushl	%ebx		// preserve spans pointer
+	movl	C(tadjust),%edx
+	movl	C(sadjust),%esi
+	movl	C(d_scantable)(,%eax,4),%edi	// v * screenwidth
+	addl	%ebp,%edi
+	movl	sspan_t_u(%ebx),%ebp
+	addl	%ebp,%edi				// pdest = &pdestspan[scans->u];
+
+//
+// now start the FDIV for the end of the span
+//
+	cmpl	$8,%ecx
+	ja		LSetupNotLast1
+
+	decl	%ecx
+	jz		LCleanup1		// if only one pixel, no need to start an FDIV
+	movl	%ecx,spancountminus1
+
+// finish up the s and t calcs
+	fxch	%st(1)			// z*64k | 1/z | t/z | s/z
+
+	fld		%st(0)			// z*64k | z*64k | 1/z | t/z | s/z
+	fmul	%st(4),%st(0)	// s | z*64k | 1/z | t/z | s/z
+	fxch	%st(1)			// z*64k | s | 1/z | t/z | s/z
+	fmul	%st(3),%st(0)	// t | s | 1/z | t/z | s/z
+	fxch	%st(1)			// s | t | 1/z | t/z | s/z
+	fistpl	s				// 1/z | t | t/z | s/z
+	fistpl	t				// 1/z | t/z | s/z
+
+	fildl	spancountminus1
+
+	flds	C(d_tdivzstepu)	// _d_tdivzstepu | spancountminus1
+	flds	C(d_zistepu)	// _d_zistepu | _d_tdivzstepu | spancountminus1
+	fmul	%st(2),%st(0)	// _d_zistepu*scm1 | _d_tdivzstepu | scm1
+	fxch	%st(1)			// _d_tdivzstepu | _d_zistepu*scm1 | scm1
+	fmul	%st(2),%st(0)	// _d_tdivzstepu*scm1 | _d_zistepu*scm1 | scm1
+	fxch	%st(2)			// scm1 | _d_zistepu*scm1 | _d_tdivzstepu*scm1
+	fmuls	C(d_sdivzstepu)	// _d_sdivzstepu*scm1 | _d_zistepu*scm1 |
+							//  _d_tdivzstepu*scm1
+	fxch	%st(1)			// _d_zistepu*scm1 | _d_sdivzstepu*scm1 |
+							//  _d_tdivzstepu*scm1
+	faddp	%st(0),%st(3)	// _d_sdivzstepu*scm1 | _d_tdivzstepu*scm1
+	fxch	%st(1)			// _d_tdivzstepu*scm1 | _d_sdivzstepu*scm1
+	faddp	%st(0),%st(3)	// _d_sdivzstepu*scm1
+	faddp	%st(0),%st(3)
+
+	flds	fp_64k
+	fdiv	%st(1),%st(0)	// this is what we've gone to all this trouble to
+							//  overlap
+	jmp		LFDIVInFlight1
+
+LCleanup1:
+// finish up the s and t calcs
+	fxch	%st(1)			// z*64k | 1/z | t/z | s/z
+
+	fld		%st(0)			// z*64k | z*64k | 1/z | t/z | s/z
+	fmul	%st(4),%st(0)	// s | z*64k | 1/z | t/z | s/z
+	fxch	%st(1)			// z*64k | s | 1/z | t/z | s/z
+	fmul	%st(3),%st(0)	// t | s | 1/z | t/z | s/z
+	fxch	%st(1)			// s | t | 1/z | t/z | s/z
+	fistpl	s				// 1/z | t | t/z | s/z
+	fistpl	t				// 1/z | t/z | s/z
+	jmp		LFDIVInFlight1
+
+	.align	4
+LSetupNotLast1:
+// finish up the s and t calcs
+	fxch	%st(1)			// z*64k | 1/z | t/z | s/z
+
+	fld		%st(0)			// z*64k | z*64k | 1/z | t/z | s/z
+	fmul	%st(4),%st(0)	// s | z*64k | 1/z | t/z | s/z
+	fxch	%st(1)			// z*64k | s | 1/z | t/z | s/z
+	fmul	%st(3),%st(0)	// t | s | 1/z | t/z | s/z
+	fxch	%st(1)			// s | t | 1/z | t/z | s/z
+	fistpl	s				// 1/z | t | t/z | s/z
+	fistpl	t				// 1/z | t/z | s/z
+
+	fadds	zi8stepu
+	fxch	%st(2)
+	fadds	sdivz8stepu
+	fxch	%st(2)
+	flds	tdivz8stepu
+	faddp	%st(0),%st(2)
+	flds	fp_64k
+	fdiv	%st(1),%st(0)	// z = 1/1/z
+							// this is what we've gone to all this trouble to
+							//  overlap
+LFDIVInFlight1:
+
+	addl	s,%esi
+	addl	t,%edx
+	movl	C(bbextents),%ebx
+	movl	C(bbextentt),%ebp
+	cmpl	%ebx,%esi
+	ja		LClampHighOrLow0
+LClampReentry0:
+	movl	%esi,s
+	movl	pbase,%ebx
+	shll	$16,%esi
+	cmpl	%ebp,%edx
+	movl	%esi,sfracf
+	ja		LClampHighOrLow1
+LClampReentry1:
+	movl	%edx,t
+	movl	s,%esi					// sfrac = scans->sfrac;
+	shll	$16,%edx
+	movl	t,%eax					// tfrac = scans->tfrac;
+	sarl	$16,%esi
+	movl	%edx,tfracf
+
+//
+// calculate the texture starting address
+//
+	sarl	$16,%eax
+	addl	%ebx,%esi
+	imull	C(cachewidth),%eax		// (tfrac >> 16) * cachewidth
+	addl	%eax,%esi				// psource = pbase + (sfrac >> 16) +
+									//           ((tfrac >> 16) * cachewidth);
+
+//
+// determine whether last span or not
+//
+	cmpl	$8,%ecx
+	jna		LLastSegment
+
+//
+// not the last segment; do full 8-wide segment
+//
+LNotLastSegment:
+
+//
+// advance s/z, t/z, and 1/z, and calculate s & t at end of span and steps to
+// get there
+//
+
+// pick up after the FDIV that was left in flight previously
+
+	fld		%st(0)			// duplicate it
+	fmul	%st(4),%st(0)	// s = s/z * z
+	fxch	%st(1)
+	fmul	%st(3),%st(0)	// t = t/z * z
+	fxch	%st(1)
+	fistpl	snext
+	fistpl	tnext
+	movl	snext,%eax
+	movl	tnext,%edx
+
+	subl	$8,%ecx		// count off this segments' pixels
+	movl	C(sadjust),%ebp
+	pushl	%ecx		// remember count of remaining pixels
+	movl	C(tadjust),%ecx
+
+	addl	%eax,%ebp
+	addl	%edx,%ecx
+
+	movl	C(bbextents),%eax
+	movl	C(bbextentt),%edx
+
+	cmpl	$2048,%ebp
+	jl		LClampLow2
+	cmpl	%eax,%ebp
+	ja		LClampHigh2
+LClampReentry2:
+
+	cmpl	$2048,%ecx
+	jl		LClampLow3
+	cmpl	%edx,%ecx
+	ja		LClampHigh3
+LClampReentry3:
+
+	movl	%ebp,snext
+	movl	%ecx,tnext
+
+	subl	s,%ebp
+	subl	t,%ecx
+	
+//
+// set up advancetable
+//
+	movl	%ecx,%eax
+	movl	%ebp,%edx
+	sarl	$19,%edx			// sstep >>= 16;
+	movl	C(cachewidth),%ebx
+	sarl	$19,%eax			// tstep >>= 16;
+	jz		LIsZero
+	imull	%ebx,%eax			// (tstep >> 16) * cachewidth;
+LIsZero:
+	addl	%edx,%eax			// add in sstep
+								// (tstep >> 16) * cachewidth + (sstep >> 16);
+	movl	tfracf,%edx
+	movl	%eax,advancetable+4	// advance base in t
+	addl	%ebx,%eax			// ((tstep >> 16) + 1) * cachewidth +
+								//  (sstep >> 16);
+	shll	$13,%ebp			// left-justify sstep fractional part
+	movl	%ebp,sstep
+	movl	sfracf,%ebx
+	shll	$13,%ecx			// left-justify tstep fractional part
+	movl	%eax,advancetable	// advance extra in t
+	movl	%ecx,tstep
+
+	movl	pz,%ecx
+	movl	izi,%ebp
+
+	cmpw	(%ecx),%bp
+	jl		Lp1
+	movb	(%esi),%al			// get first source texel
+	cmpb	$(TRANSPARENT_COLOR),%al
+	jz		Lp1
+	movw	%bp,(%ecx)
+	movb	%al,(%edi)			// store first dest pixel
+Lp1:
+	addl	izistep,%ebp
+	adcl	$0,%ebp
+	addl	tstep,%edx			// advance tfrac fractional part by tstep frac
+
+	sbbl	%eax,%eax			// turn tstep carry into -1 (0 if none)
+	addl	sstep,%ebx			// advance sfrac fractional part by sstep frac
+	adcl	advancetable+4(,%eax,4),%esi	// point to next source texel
+
+	cmpw	2(%ecx),%bp
+	jl		Lp2
+	movb	(%esi),%al
+	cmpb	$(TRANSPARENT_COLOR),%al
+	jz		Lp2
+	movw	%bp,2(%ecx)
+	movb	%al,1(%edi)
+Lp2:
+	addl	izistep,%ebp
+	adcl	$0,%ebp
+	addl	tstep,%edx
+	sbbl	%eax,%eax
+	addl	sstep,%ebx
+	adcl	advancetable+4(,%eax,4),%esi
+
+	cmpw	4(%ecx),%bp
+	jl		Lp3
+	movb	(%esi),%al
+	cmpb	$(TRANSPARENT_COLOR),%al
+	jz		Lp3
+	movw	%bp,4(%ecx)
+	movb	%al,2(%edi)
+Lp3:
+	addl	izistep,%ebp
+	adcl	$0,%ebp
+	addl	tstep,%edx
+	sbbl	%eax,%eax
+	addl	sstep,%ebx
+	adcl	advancetable+4(,%eax,4),%esi
+
+	cmpw	6(%ecx),%bp
+	jl		Lp4
+	movb	(%esi),%al
+	cmpb	$(TRANSPARENT_COLOR),%al
+	jz		Lp4
+	movw	%bp,6(%ecx)
+	movb	%al,3(%edi)
+Lp4:
+	addl	izistep,%ebp
+	adcl	$0,%ebp
+	addl	tstep,%edx
+	sbbl	%eax,%eax
+	addl	sstep,%ebx
+	adcl	advancetable+4(,%eax,4),%esi
+
+	cmpw	8(%ecx),%bp
+	jl		Lp5
+	movb	(%esi),%al
+	cmpb	$(TRANSPARENT_COLOR),%al
+	jz		Lp5
+	movw	%bp,8(%ecx)
+	movb	%al,4(%edi)
+Lp5:
+	addl	izistep,%ebp
+	adcl	$0,%ebp
+	addl	tstep,%edx
+	sbbl	%eax,%eax
+	addl	sstep,%ebx
+	adcl	advancetable+4(,%eax,4),%esi
+
+//
+// start FDIV for end of next segment in flight, so it can overlap
+//
+	popl	%eax
+	cmpl	$8,%eax			// more than one segment after this?
+	ja		LSetupNotLast2	// yes
+
+	decl	%eax
+	jz		LFDIVInFlight2	// if only one pixel, no need to start an FDIV
+	movl	%eax,spancountminus1
+	fildl	spancountminus1
+
+	flds	C(d_zistepu)		// _d_zistepu | spancountminus1
+	fmul	%st(1),%st(0)	// _d_zistepu*scm1 | scm1
+	flds	C(d_tdivzstepu)	// _d_tdivzstepu | _d_zistepu*scm1 | scm1
+	fmul	%st(2),%st(0)	// _d_tdivzstepu*scm1 | _d_zistepu*scm1 | scm1
+	fxch	%st(1)			// _d_zistepu*scm1 | _d_tdivzstepu*scm1 | scm1
+	faddp	%st(0),%st(3)	// _d_tdivzstepu*scm1 | scm1
+	fxch	%st(1)			// scm1 | _d_tdivzstepu*scm1
+	fmuls	C(d_sdivzstepu)	// _d_sdivzstepu*scm1 | _d_tdivzstepu*scm1
+	fxch	%st(1)			// _d_tdivzstepu*scm1 | _d_sdivzstepu*scm1
+	faddp	%st(0),%st(3)	// _d_sdivzstepu*scm1
+	flds	fp_64k			// 64k | _d_sdivzstepu*scm1
+	fxch	%st(1)			// _d_sdivzstepu*scm1 | 64k
+	faddp	%st(0),%st(4)	// 64k
+
+	fdiv	%st(1),%st(0)	// this is what we've gone to all this trouble to
+							//  overlap
+	jmp		LFDIVInFlight2
+
+	.align	4
+LSetupNotLast2:
+	fadds	zi8stepu
+	fxch	%st(2)
+	fadds	sdivz8stepu
+	fxch	%st(2)
+	flds	tdivz8stepu
+	faddp	%st(0),%st(2)
+	flds	fp_64k
+	fdiv	%st(1),%st(0)	// z = 1/1/z
+							// this is what we've gone to all this trouble to
+							//  overlap
+LFDIVInFlight2:
+	pushl	%eax
+
+	cmpw	10(%ecx),%bp
+	jl		Lp6
+	movb	(%esi),%al
+	cmpb	$(TRANSPARENT_COLOR),%al
+	jz		Lp6
+	movw	%bp,10(%ecx)
+	movb	%al,5(%edi)
+Lp6:
+	addl	izistep,%ebp
+	adcl	$0,%ebp
+	addl	tstep,%edx
+	sbbl	%eax,%eax
+	addl	sstep,%ebx
+	adcl	advancetable+4(,%eax,4),%esi
+
+	cmpw	12(%ecx),%bp
+	jl		Lp7
+	movb	(%esi),%al
+	cmpb	$(TRANSPARENT_COLOR),%al
+	jz		Lp7
+	movw	%bp,12(%ecx)
+	movb	%al,6(%edi)
+Lp7:
+	addl	izistep,%ebp
+	adcl	$0,%ebp
+	addl	tstep,%edx
+	sbbl	%eax,%eax
+	addl	sstep,%ebx
+	adcl	advancetable+4(,%eax,4),%esi
+
+	cmpw	14(%ecx),%bp
+	jl		Lp8
+	movb	(%esi),%al
+	cmpb	$(TRANSPARENT_COLOR),%al
+	jz		Lp8
+	movw	%bp,14(%ecx)
+	movb	%al,7(%edi)
+Lp8:
+	addl	izistep,%ebp
+	adcl	$0,%ebp
+	addl	tstep,%edx
+	sbbl	%eax,%eax
+	addl	sstep,%ebx
+	adcl	advancetable+4(,%eax,4),%esi
+
+	addl	$8,%edi
+	addl	$16,%ecx
+	movl	%edx,tfracf
+	movl	snext,%edx
+	movl	%ebx,sfracf
+	movl	tnext,%ebx
+	movl	%edx,s
+	movl	%ebx,t
+
+	movl	%ecx,pz
+	movl	%ebp,izi
+
+	popl	%ecx				// retrieve count
+
+//
+// determine whether last span or not
+//
+	cmpl	$8,%ecx				// are there multiple segments remaining?
+	ja		LNotLastSegment		// yes
+
+//
+// last segment of scan
+//
+LLastSegment:
+
+//
+// advance s/z, t/z, and 1/z, and calculate s & t at end of span and steps to
+// get there. The number of pixels left is variable, and we want to land on the
+// last pixel, not step one past it, so we can't run into arithmetic problems
+//
+	testl	%ecx,%ecx
+	jz		LNoSteps		// just draw the last pixel and we're done
+
+// pick up after the FDIV that was left in flight previously
+
+
+	fld		%st(0)			// duplicate it
+	fmul	%st(4),%st(0)	// s = s/z * z
+	fxch	%st(1)
+	fmul	%st(3),%st(0)	// t = t/z * z
+	fxch	%st(1)
+	fistpl	snext
+	fistpl	tnext
+
+	movl	C(tadjust),%ebx
+	movl	C(sadjust),%eax
+
+	addl	snext,%eax
+	addl	tnext,%ebx
+
+	movl	C(bbextents),%ebp
+	movl	C(bbextentt),%edx
+
+	cmpl	$2048,%eax
+	jl		LClampLow4
+	cmpl	%ebp,%eax
+	ja		LClampHigh4
+LClampReentry4:
+	movl	%eax,snext
+
+	cmpl	$2048,%ebx
+	jl		LClampLow5
+	cmpl	%edx,%ebx
+	ja		LClampHigh5
+LClampReentry5:
+
+	cmpl	$1,%ecx			// don't bother 
+	je		LOnlyOneStep	// if two pixels in segment, there's only one step,
+							//  of the segment length
+	subl	s,%eax
+	subl	t,%ebx
+
+	addl	%eax,%eax		// convert to 15.17 format so multiply by 1.31
+	addl	%ebx,%ebx		//  reciprocal yields 16.48
+	imull	reciprocal_table-8(,%ecx,4) // sstep = (snext - s) / (spancount-1)
+	movl	%edx,%ebp
+
+	movl	%ebx,%eax
+	imull	reciprocal_table-8(,%ecx,4) // tstep = (tnext - t) / (spancount-1)
+
+LSetEntryvec:
+//
+// set up advancetable
+//
+	movl	spr8entryvec_table(,%ecx,4),%ebx
+	movl	%edx,%eax
+	pushl	%ebx				// entry point into code for RET later
+	movl	%ebp,%ecx
+	sarl	$16,%ecx			// sstep >>= 16;
+	movl	C(cachewidth),%ebx
+	sarl	$16,%edx			// tstep >>= 16;
+	jz		LIsZeroLast
+	imull	%ebx,%edx			// (tstep >> 16) * cachewidth;
+LIsZeroLast:
+	addl	%ecx,%edx			// add in sstep
+								// (tstep >> 16) * cachewidth + (sstep >> 16);
+	movl	tfracf,%ecx
+	movl	%edx,advancetable+4	// advance base in t
+	addl	%ebx,%edx			// ((tstep >> 16) + 1) * cachewidth +
+								//  (sstep >> 16);
+	shll	$16,%ebp			// left-justify sstep fractional part
+	movl	sfracf,%ebx
+	shll	$16,%eax			// left-justify tstep fractional part
+	movl	%edx,advancetable	// advance extra in t
+
+	movl	%eax,tstep
+	movl	%ebp,sstep
+	movl	%ecx,%edx
+
+	movl	pz,%ecx
+	movl	izi,%ebp
+
+	ret							// jump to the number-of-pixels handler
+
+//----------------------------------------
+
+LNoSteps:
+	movl	pz,%ecx
+	subl	$7,%edi			// adjust for hardwired offset
+	subl	$14,%ecx
+	jmp		LEndSpan
+
+
+LOnlyOneStep:
+	subl	s,%eax
+	subl	t,%ebx
+	movl	%eax,%ebp
+	movl	%ebx,%edx
+	jmp		LSetEntryvec
+
+//----------------------------------------
+
+.globl	Spr8Entry2_8
+Spr8Entry2_8:
+	subl	$6,%edi		// adjust for hardwired offsets
+	subl	$12,%ecx
+	movb	(%esi),%al
+	jmp		LLEntry2_8
+
+//----------------------------------------
+
+.globl	Spr8Entry3_8
+Spr8Entry3_8:
+	subl	$5,%edi		// adjust for hardwired offsets
+	subl	$10,%ecx
+	jmp		LLEntry3_8
+
+//----------------------------------------
+
+.globl	Spr8Entry4_8
+Spr8Entry4_8:
+	subl	$4,%edi		// adjust for hardwired offsets
+	subl	$8,%ecx
+	jmp		LLEntry4_8
+
+//----------------------------------------
+
+.globl	Spr8Entry5_8
+Spr8Entry5_8:
+	subl	$3,%edi		// adjust for hardwired offsets
+	subl	$6,%ecx
+	jmp		LLEntry5_8
+
+//----------------------------------------
+
+.globl	Spr8Entry6_8
+Spr8Entry6_8:
+	subl	$2,%edi		// adjust for hardwired offsets
+	subl	$4,%ecx
+	jmp		LLEntry6_8
+
+//----------------------------------------
+
+.globl	Spr8Entry7_8
+Spr8Entry7_8:
+	decl	%edi		// adjust for hardwired offsets
+	subl	$2,%ecx
+	jmp		LLEntry7_8
+
+//----------------------------------------
+
+.globl	Spr8Entry8_8
+Spr8Entry8_8:
+	cmpw	(%ecx),%bp
+	jl		Lp9
+	movb	(%esi),%al
+	cmpb	$(TRANSPARENT_COLOR),%al
+	jz		Lp9
+	movw	%bp,(%ecx)
+	movb	%al,(%edi)
+Lp9:
+	addl	izistep,%ebp
+	adcl	$0,%ebp
+	addl	tstep,%edx
+	sbbl	%eax,%eax
+	addl	sstep,%ebx
+	adcl	advancetable+4(,%eax,4),%esi
+LLEntry7_8:
+	cmpw	2(%ecx),%bp
+	jl		Lp10
+	movb	(%esi),%al
+	cmpb	$(TRANSPARENT_COLOR),%al
+	jz		Lp10
+	movw	%bp,2(%ecx)
+	movb	%al,1(%edi)
+Lp10:
+	addl	izistep,%ebp
+	adcl	$0,%ebp
+	addl	tstep,%edx
+	sbbl	%eax,%eax
+	addl	sstep,%ebx
+	adcl	advancetable+4(,%eax,4),%esi
+LLEntry6_8:
+	cmpw	4(%ecx),%bp
+	jl		Lp11
+	movb	(%esi),%al
+	cmpb	$(TRANSPARENT_COLOR),%al
+	jz		Lp11
+	movw	%bp,4(%ecx)
+	movb	%al,2(%edi)
+Lp11:
+	addl	izistep,%ebp
+	adcl	$0,%ebp
+	addl	tstep,%edx
+	sbbl	%eax,%eax
+	addl	sstep,%ebx
+	adcl	advancetable+4(,%eax,4),%esi
+LLEntry5_8:
+	cmpw	6(%ecx),%bp
+	jl		Lp12
+	movb	(%esi),%al
+	cmpb	$(TRANSPARENT_COLOR),%al
+	jz		Lp12
+	movw	%bp,6(%ecx)
+	movb	%al,3(%edi)
+Lp12:
+	addl	izistep,%ebp
+	adcl	$0,%ebp
+	addl	tstep,%edx
+	sbbl	%eax,%eax
+	addl	sstep,%ebx
+	adcl	advancetable+4(,%eax,4),%esi
+LLEntry4_8:
+	cmpw	8(%ecx),%bp
+	jl		Lp13
+	movb	(%esi),%al
+	cmpb	$(TRANSPARENT_COLOR),%al
+	jz		Lp13
+	movw	%bp,8(%ecx)
+	movb	%al,4(%edi)
+Lp13:
+	addl	izistep,%ebp
+	adcl	$0,%ebp
+	addl	tstep,%edx
+	sbbl	%eax,%eax
+	addl	sstep,%ebx
+	adcl	advancetable+4(,%eax,4),%esi
+LLEntry3_8:
+	cmpw	10(%ecx),%bp
+	jl		Lp14
+	movb	(%esi),%al
+	cmpb	$(TRANSPARENT_COLOR),%al
+	jz		Lp14
+	movw	%bp,10(%ecx)
+	movb	%al,5(%edi)
+Lp14:
+	addl	izistep,%ebp
+	adcl	$0,%ebp
+	addl	tstep,%edx
+	sbbl	%eax,%eax
+	addl	sstep,%ebx
+	adcl	advancetable+4(,%eax,4),%esi
+LLEntry2_8:
+	cmpw	12(%ecx),%bp
+	jl		Lp15
+	movb	(%esi),%al
+	cmpb	$(TRANSPARENT_COLOR),%al
+	jz		Lp15
+	movw	%bp,12(%ecx)
+	movb	%al,6(%edi)
+Lp15:
+	addl	izistep,%ebp
+	adcl	$0,%ebp
+	addl	tstep,%edx
+	sbbl	%eax,%eax
+	addl	sstep,%ebx
+	adcl	advancetable+4(,%eax,4),%esi
+
+LEndSpan:
+	cmpw	14(%ecx),%bp
+	jl		Lp16
+	movb	(%esi),%al		// load first texel in segment
+	cmpb	$(TRANSPARENT_COLOR),%al
+	jz		Lp16
+	movw	%bp,14(%ecx)
+	movb	%al,7(%edi)
+Lp16:
+
+//
+// clear s/z, t/z, 1/z from FP stack
+//
+	fstp %st(0)
+	fstp %st(0)
+	fstp %st(0)
+
+	popl	%ebx				// restore spans pointer
+LNextSpan:
+	addl	$(sspan_t_size),%ebx // point to next span
+	movl	sspan_t_count(%ebx),%ecx
+	cmpl	$0,%ecx				// any more spans?
+	jg		LSpanLoop			// yes
+	jz		LNextSpan			// yes, but this one's empty
+
+	popl	%ebx				// restore register variables
+	popl	%esi
+	popl	%edi
+	popl	%ebp				// restore the caller's stack frame
+	ret
+
+#endif	// id386
diff -ruN WinQuake/d_spr8.s sdlquake-1.0.9/d_spr8.s
--- WinQuake/d_spr8.s	Tue Dec 21 15:53:24 1999
+++ sdlquake-1.0.9/d_spr8.s	Wed Dec 31 16:00:00 1969
@@ -1,900 +0,0 @@
-/*
-Copyright (C) 1996-1997 Id Software, Inc.
-
-This program is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License
-as published by the Free Software Foundation; either version 2
-of the License, or (at your option) any later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
-
-See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-*/
-//
-// d_spr8.s
-// x86 assembly-language horizontal 8-bpp transparent span-drawing code.
-//
-
-#include "asm_i386.h"
-#include "quakeasm.h"
-#include "asm_draw.h"
-
-#if id386
-
-//----------------------------------------------------------------------
-// 8-bpp horizontal span drawing code for polygons, with transparency.
-//----------------------------------------------------------------------
-
-	.text
-
-// out-of-line, rarely-needed clamping code
-
-LClampHigh0:
-	movl	C(bbextents),%esi
-	jmp		LClampReentry0
-LClampHighOrLow0:
-	jg		LClampHigh0
-	xorl	%esi,%esi
-	jmp		LClampReentry0
-
-LClampHigh1:
-	movl	C(bbextentt),%edx
-	jmp		LClampReentry1
-LClampHighOrLow1:
-	jg		LClampHigh1
-	xorl	%edx,%edx
-	jmp		LClampReentry1
-
-LClampLow2:
-	movl	$2048,%ebp
-	jmp		LClampReentry2
-LClampHigh2:
-	movl	C(bbextents),%ebp
-	jmp		LClampReentry2
-
-LClampLow3:
-	movl	$2048,%ecx
-	jmp		LClampReentry3
-LClampHigh3:
-	movl	C(bbextentt),%ecx
-	jmp		LClampReentry3
-
-LClampLow4:
-	movl	$2048,%eax
-	jmp		LClampReentry4
-LClampHigh4:
-	movl	C(bbextents),%eax
-	jmp		LClampReentry4
-
-LClampLow5:
-	movl	$2048,%ebx
-	jmp		LClampReentry5
-LClampHigh5:
-	movl	C(bbextentt),%ebx
-	jmp		LClampReentry5
-
-
-#define pspans	4+16
-
-	.align 4
-.globl C(D_SpriteDrawSpans)
-C(D_SpriteDrawSpans):
-	pushl	%ebp				// preserve caller's stack frame
-	pushl	%edi
-	pushl	%esi				// preserve register variables
-	pushl	%ebx
-
-//
-// set up scaled-by-8 steps, for 8-long segments; also set up cacheblock
-// and span list pointers, and 1/z step in 0.32 fixed-point
-//
-// FIXME: any overlap from rearranging?
-	flds	C(d_sdivzstepu)
-	fmuls	fp_8
-	movl	C(cacheblock),%edx
-	flds	C(d_tdivzstepu)
-	fmuls	fp_8
-	movl	pspans(%esp),%ebx	// point to the first span descriptor
-	flds	C(d_zistepu)
-	fmuls	fp_8
-	movl	%edx,pbase			// pbase = cacheblock
-	flds	C(d_zistepu)
-	fmuls	fp_64kx64k
-	fxch	%st(3)
-	fstps	sdivz8stepu
-	fstps	zi8stepu
-	fstps	tdivz8stepu
-	fistpl	izistep
-	movl	izistep,%eax
-	rorl	$16,%eax		// put upper 16 bits in low word
-	movl	sspan_t_count(%ebx),%ecx
-	movl	%eax,izistep
-
-	cmpl	$0,%ecx
-	jle		LNextSpan
-
-LSpanLoop:
-
-//
-// set up the initial s/z, t/z, and 1/z on the FP stack, and generate the
-// initial s and t values
-//
-// FIXME: pipeline FILD?
-	fildl	sspan_t_v(%ebx)
-	fildl	sspan_t_u(%ebx)
-
-	fld		%st(1)			// dv | du | dv
-	fmuls	C(d_sdivzstepv)	// dv*d_sdivzstepv | du | dv
-	fld		%st(1)			// du | dv*d_sdivzstepv | du | dv
-	fmuls	C(d_sdivzstepu)	// du*d_sdivzstepu | dv*d_sdivzstepv | du | dv
-	fld		%st(2)			// du | du*d_sdivzstepu | dv*d_sdivzstepv | du | dv
-	fmuls	C(d_tdivzstepu)	// du*d_tdivzstepu | du*d_sdivzstepu |
-							//  dv*d_sdivzstepv | du | dv
-	fxch	%st(1)			// du*d_sdivzstepu | du*d_tdivzstepu |
-							//  dv*d_sdivzstepv | du | dv
-	faddp	%st(0),%st(2)	// du*d_tdivzstepu |
-							//  du*d_sdivzstepu + dv*d_sdivzstepv | du | dv
-	fxch	%st(1)			// du*d_sdivzstepu + dv*d_sdivzstepv |
-							//  du*d_tdivzstepu | du | dv
-	fld		%st(3)			// dv | du*d_sdivzstepu + dv*d_sdivzstepv |
-							//  du*d_tdivzstepu | du | dv
-	fmuls	C(d_tdivzstepv)	// dv*d_tdivzstepv |
-							//  du*d_sdivzstepu + dv*d_sdivzstepv |
-							//  du*d_tdivzstepu | du | dv
-	fxch	%st(1)			// du*d_sdivzstepu + dv*d_sdivzstepv |
-							//  dv*d_tdivzstepv | du*d_tdivzstepu | du | dv
-	fadds	C(d_sdivzorigin) // sdivz = d_sdivzorigin + dv*d_sdivzstepv +
-							//  du*d_sdivzstepu; stays in %st(2) at end
-	fxch	%st(4)			// dv | dv*d_tdivzstepv | du*d_tdivzstepu | du |
-							//  s/z
-	fmuls	C(d_zistepv)		// dv*d_zistepv | dv*d_tdivzstepv |
-							//  du*d_tdivzstepu | du | s/z
-	fxch	%st(1)			// dv*d_tdivzstepv |  dv*d_zistepv |
-							//  du*d_tdivzstepu | du | s/z
-	faddp	%st(0),%st(2)	// dv*d_zistepv |
-							//  dv*d_tdivzstepv + du*d_tdivzstepu | du | s/z
-	fxch	%st(2)			// du | dv*d_tdivzstepv + du*d_tdivzstepu |
-							//  dv*d_zistepv | s/z
-	fmuls	C(d_zistepu)		// du*d_zistepu |
-							//  dv*d_tdivzstepv + du*d_tdivzstepu |
-							//  dv*d_zistepv | s/z
-	fxch	%st(1)			// dv*d_tdivzstepv + du*d_tdivzstepu |
-							//  du*d_zistepu | dv*d_zistepv | s/z
-	fadds	C(d_tdivzorigin)	// tdivz = d_tdivzorigin + dv*d_tdivzstepv +
-							//  du*d_tdivzstepu; stays in %st(1) at end
-	fxch	%st(2)			// dv*d_zistepv | du*d_zistepu | t/z | s/z
-	faddp	%st(0),%st(1)	// dv*d_zistepv + du*d_zistepu | t/z | s/z
-
-	flds	fp_64k			// fp_64k | dv*d_zistepv + du*d_zistepu | t/z | s/z
-	fxch	%st(1)			// dv*d_zistepv + du*d_zistepu | fp_64k | t/z | s/z
-	fadds	C(d_ziorigin)		// zi = d_ziorigin + dv*d_zistepv +
-							//  du*d_zistepu; stays in %st(0) at end
-							// 1/z | fp_64k | t/z | s/z
-
-	fld		%st(0)			// FIXME: get rid of stall on FMUL?
-	fmuls	fp_64kx64k
-	fxch	%st(1)
-
-//
-// calculate and clamp s & t
-//
-	fdivr	%st(0),%st(2)	// 1/z | z*64k | t/z | s/z
-	fxch	%st(1)
-
-	fistpl	izi				// 0.32 fixed-point 1/z
-	movl	izi,%ebp
-
-//
-// set pz to point to the first z-buffer pixel in the span
-//
-	rorl	$16,%ebp		// put upper 16 bits in low word
-	movl	sspan_t_v(%ebx),%eax
-	movl	%ebp,izi
-	movl	sspan_t_u(%ebx),%ebp
-	imull	C(d_zrowbytes)
-	shll	$1,%ebp					// a word per pixel
-	addl	C(d_pzbuffer),%eax
-	addl	%ebp,%eax
-	movl	%eax,pz
-
-//
-// point %edi to the first pixel in the span
-//
-	movl	C(d_viewbuffer),%ebp
-	movl	sspan_t_v(%ebx),%eax
-	pushl	%ebx		// preserve spans pointer
-	movl	C(tadjust),%edx
-	movl	C(sadjust),%esi
-	movl	C(d_scantable)(,%eax,4),%edi	// v * screenwidth
-	addl	%ebp,%edi
-	movl	sspan_t_u(%ebx),%ebp
-	addl	%ebp,%edi				// pdest = &pdestspan[scans->u];
-
-//
-// now start the FDIV for the end of the span
-//
-	cmpl	$8,%ecx
-	ja		LSetupNotLast1
-
-	decl	%ecx
-	jz		LCleanup1		// if only one pixel, no need to start an FDIV
-	movl	%ecx,spancountminus1
-
-// finish up the s and t calcs
-	fxch	%st(1)			// z*64k | 1/z | t/z | s/z
-
-	fld		%st(0)			// z*64k | z*64k | 1/z | t/z | s/z
-	fmul	%st(4),%st(0)	// s | z*64k | 1/z | t/z | s/z
-	fxch	%st(1)			// z*64k | s | 1/z | t/z | s/z
-	fmul	%st(3),%st(0)	// t | s | 1/z | t/z | s/z
-	fxch	%st(1)			// s | t | 1/z | t/z | s/z
-	fistpl	s				// 1/z | t | t/z | s/z
-	fistpl	t				// 1/z | t/z | s/z
-
-	fildl	spancountminus1
-
-	flds	C(d_tdivzstepu)	// _d_tdivzstepu | spancountminus1
-	flds	C(d_zistepu)	// _d_zistepu | _d_tdivzstepu | spancountminus1
-	fmul	%st(2),%st(0)	// _d_zistepu*scm1 | _d_tdivzstepu | scm1
-	fxch	%st(1)			// _d_tdivzstepu | _d_zistepu*scm1 | scm1
-	fmul	%st(2),%st(0)	// _d_tdivzstepu*scm1 | _d_zistepu*scm1 | scm1
-	fxch	%st(2)			// scm1 | _d_zistepu*scm1 | _d_tdivzstepu*scm1
-	fmuls	C(d_sdivzstepu)	// _d_sdivzstepu*scm1 | _d_zistepu*scm1 |
-							//  _d_tdivzstepu*scm1
-	fxch	%st(1)			// _d_zistepu*scm1 | _d_sdivzstepu*scm1 |
-							//  _d_tdivzstepu*scm1
-	faddp	%st(0),%st(3)	// _d_sdivzstepu*scm1 | _d_tdivzstepu*scm1
-	fxch	%st(1)			// _d_tdivzstepu*scm1 | _d_sdivzstepu*scm1
-	faddp	%st(0),%st(3)	// _d_sdivzstepu*scm1
-	faddp	%st(0),%st(3)
-
-	flds	fp_64k
-	fdiv	%st(1),%st(0)	// this is what we've gone to all this trouble to
-							//  overlap
-	jmp		LFDIVInFlight1
-
-LCleanup1:
-// finish up the s and t calcs
-	fxch	%st(1)			// z*64k | 1/z | t/z | s/z
-
-	fld		%st(0)			// z*64k | z*64k | 1/z | t/z | s/z
-	fmul	%st(4),%st(0)	// s | z*64k | 1/z | t/z | s/z
-	fxch	%st(1)			// z*64k | s | 1/z | t/z | s/z
-	fmul	%st(3),%st(0)	// t | s | 1/z | t/z | s/z
-	fxch	%st(1)			// s | t | 1/z | t/z | s/z
-	fistpl	s				// 1/z | t | t/z | s/z
-	fistpl	t				// 1/z | t/z | s/z
-	jmp		LFDIVInFlight1
-
-	.align	4
-LSetupNotLast1:
-// finish up the s and t calcs
-	fxch	%st(1)			// z*64k | 1/z | t/z | s/z
-
-	fld		%st(0)			// z*64k | z*64k | 1/z | t/z | s/z
-	fmul	%st(4),%st(0)	// s | z*64k | 1/z | t/z | s/z
-	fxch	%st(1)			// z*64k | s | 1/z | t/z | s/z
-	fmul	%st(3),%st(0)	// t | s | 1/z | t/z | s/z
-	fxch	%st(1)			// s | t | 1/z | t/z | s/z
-	fistpl	s				// 1/z | t | t/z | s/z
-	fistpl	t				// 1/z | t/z | s/z
-
-	fadds	zi8stepu
-	fxch	%st(2)
-	fadds	sdivz8stepu
-	fxch	%st(2)
-	flds	tdivz8stepu
-	faddp	%st(0),%st(2)
-	flds	fp_64k
-	fdiv	%st(1),%st(0)	// z = 1/1/z
-							// this is what we've gone to all this trouble to
-							//  overlap
-LFDIVInFlight1:
-
-	addl	s,%esi
-	addl	t,%edx
-	movl	C(bbextents),%ebx
-	movl	C(bbextentt),%ebp
-	cmpl	%ebx,%esi
-	ja		LClampHighOrLow0
-LClampReentry0:
-	movl	%esi,s
-	movl	pbase,%ebx
-	shll	$16,%esi
-	cmpl	%ebp,%edx
-	movl	%esi,sfracf
-	ja		LClampHighOrLow1
-LClampReentry1:
-	movl	%edx,t
-	movl	s,%esi					// sfrac = scans->sfrac;
-	shll	$16,%edx
-	movl	t,%eax					// tfrac = scans->tfrac;
-	sarl	$16,%esi
-	movl	%edx,tfracf
-
-//
-// calculate the texture starting address
-//
-	sarl	$16,%eax
-	addl	%ebx,%esi
-	imull	C(cachewidth),%eax		// (tfrac >> 16) * cachewidth
-	addl	%eax,%esi				// psource = pbase + (sfrac >> 16) +
-									//           ((tfrac >> 16) * cachewidth);
-
-//
-// determine whether last span or not
-//
-	cmpl	$8,%ecx
-	jna		LLastSegment
-
-//
-// not the last segment; do full 8-wide segment
-//
-LNotLastSegment:
-
-//
-// advance s/z, t/z, and 1/z, and calculate s & t at end of span and steps to
-// get there
-//
-
-// pick up after the FDIV that was left in flight previously
-
-	fld		%st(0)			// duplicate it
-	fmul	%st(4),%st(0)	// s = s/z * z
-	fxch	%st(1)
-	fmul	%st(3),%st(0)	// t = t/z * z
-	fxch	%st(1)
-	fistpl	snext
-	fistpl	tnext
-	movl	snext,%eax
-	movl	tnext,%edx
-
-	subl	$8,%ecx		// count off this segments' pixels
-	movl	C(sadjust),%ebp
-	pushl	%ecx		// remember count of remaining pixels
-	movl	C(tadjust),%ecx
-
-	addl	%eax,%ebp
-	addl	%edx,%ecx
-
-	movl	C(bbextents),%eax
-	movl	C(bbextentt),%edx
-
-	cmpl	$2048,%ebp
-	jl		LClampLow2
-	cmpl	%eax,%ebp
-	ja		LClampHigh2
-LClampReentry2:
-
-	cmpl	$2048,%ecx
-	jl		LClampLow3
-	cmpl	%edx,%ecx
-	ja		LClampHigh3
-LClampReentry3:
-
-	movl	%ebp,snext
-	movl	%ecx,tnext
-
-	subl	s,%ebp
-	subl	t,%ecx
-	
-//
-// set up advancetable
-//
-	movl	%ecx,%eax
-	movl	%ebp,%edx
-	sarl	$19,%edx			// sstep >>= 16;
-	movl	C(cachewidth),%ebx
-	sarl	$19,%eax			// tstep >>= 16;
-	jz		LIsZero
-	imull	%ebx,%eax			// (tstep >> 16) * cachewidth;
-LIsZero:
-	addl	%edx,%eax			// add in sstep
-								// (tstep >> 16) * cachewidth + (sstep >> 16);
-	movl	tfracf,%edx
-	movl	%eax,advancetable+4	// advance base in t
-	addl	%ebx,%eax			// ((tstep >> 16) + 1) * cachewidth +
-								//  (sstep >> 16);
-	shll	$13,%ebp			// left-justify sstep fractional part
-	movl	%ebp,sstep
-	movl	sfracf,%ebx
-	shll	$13,%ecx			// left-justify tstep fractional part
-	movl	%eax,advancetable	// advance extra in t
-	movl	%ecx,tstep
-
-	movl	pz,%ecx
-	movl	izi,%ebp
-
-	cmpw	(%ecx),%bp
-	jl		Lp1
-	movb	(%esi),%al			// get first source texel
-	cmpb	$(TRANSPARENT_COLOR),%al
-	jz		Lp1
-	movw	%bp,(%ecx)
-	movb	%al,(%edi)			// store first dest pixel
-Lp1:
-	addl	izistep,%ebp
-	adcl	$0,%ebp
-	addl	tstep,%edx			// advance tfrac fractional part by tstep frac
-
-	sbbl	%eax,%eax			// turn tstep carry into -1 (0 if none)
-	addl	sstep,%ebx			// advance sfrac fractional part by sstep frac
-	adcl	advancetable+4(,%eax,4),%esi	// point to next source texel
-
-	cmpw	2(%ecx),%bp
-	jl		Lp2
-	movb	(%esi),%al
-	cmpb	$(TRANSPARENT_COLOR),%al
-	jz		Lp2
-	movw	%bp,2(%ecx)
-	movb	%al,1(%edi)
-Lp2:
-	addl	izistep,%ebp
-	adcl	$0,%ebp
-	addl	tstep,%edx
-	sbbl	%eax,%eax
-	addl	sstep,%ebx
-	adcl	advancetable+4(,%eax,4),%esi
-
-	cmpw	4(%ecx),%bp
-	jl		Lp3
-	movb	(%esi),%al
-	cmpb	$(TRANSPARENT_COLOR),%al
-	jz		Lp3
-	movw	%bp,4(%ecx)
-	movb	%al,2(%edi)
-Lp3:
-	addl	izistep,%ebp
-	adcl	$0,%ebp
-	addl	tstep,%edx
-	sbbl	%eax,%eax
-	addl	sstep,%ebx
-	adcl	advancetable+4(,%eax,4),%esi
-
-	cmpw	6(%ecx),%bp
-	jl		Lp4
-	movb	(%esi),%al
-	cmpb	$(TRANSPARENT_COLOR),%al
-	jz		Lp4
-	movw	%bp,6(%ecx)
-	movb	%al,3(%edi)
-Lp4:
-	addl	izistep,%ebp
-	adcl	$0,%ebp
-	addl	tstep,%edx
-	sbbl	%eax,%eax
-	addl	sstep,%ebx
-	adcl	advancetable+4(,%eax,4),%esi
-
-	cmpw	8(%ecx),%bp
-	jl		Lp5
-	movb	(%esi),%al
-	cmpb	$(TRANSPARENT_COLOR),%al
-	jz		Lp5
-	movw	%bp,8(%ecx)
-	movb	%al,4(%edi)
-Lp5:
-	addl	izistep,%ebp
-	adcl	$0,%ebp
-	addl	tstep,%edx
-	sbbl	%eax,%eax
-	addl	sstep,%ebx
-	adcl	advancetable+4(,%eax,4),%esi
-
-//
-// start FDIV for end of next segment in flight, so it can overlap
-//
-	popl	%eax
-	cmpl	$8,%eax			// more than one segment after this?
-	ja		LSetupNotLast2	// yes
-
-	decl	%eax
-	jz		LFDIVInFlight2	// if only one pixel, no need to start an FDIV
-	movl	%eax,spancountminus1
-	fildl	spancountminus1
-
-	flds	C(d_zistepu)		// _d_zistepu | spancountminus1
-	fmul	%st(1),%st(0)	// _d_zistepu*scm1 | scm1
-	flds	C(d_tdivzstepu)	// _d_tdivzstepu | _d_zistepu*scm1 | scm1
-	fmul	%st(2),%st(0)	// _d_tdivzstepu*scm1 | _d_zistepu*scm1 | scm1
-	fxch	%st(1)			// _d_zistepu*scm1 | _d_tdivzstepu*scm1 | scm1
-	faddp	%st(0),%st(3)	// _d_tdivzstepu*scm1 | scm1
-	fxch	%st(1)			// scm1 | _d_tdivzstepu*scm1
-	fmuls	C(d_sdivzstepu)	// _d_sdivzstepu*scm1 | _d_tdivzstepu*scm1
-	fxch	%st(1)			// _d_tdivzstepu*scm1 | _d_sdivzstepu*scm1
-	faddp	%st(0),%st(3)	// _d_sdivzstepu*scm1
-	flds	fp_64k			// 64k | _d_sdivzstepu*scm1
-	fxch	%st(1)			// _d_sdivzstepu*scm1 | 64k
-	faddp	%st(0),%st(4)	// 64k
-
-	fdiv	%st(1),%st(0)	// this is what we've gone to all this trouble to
-							//  overlap
-	jmp		LFDIVInFlight2
-
-	.align	4
-LSetupNotLast2:
-	fadds	zi8stepu
-	fxch	%st(2)
-	fadds	sdivz8stepu
-	fxch	%st(2)
-	flds	tdivz8stepu
-	faddp	%st(0),%st(2)
-	flds	fp_64k
-	fdiv	%st(1),%st(0)	// z = 1/1/z
-							// this is what we've gone to all this trouble to
-							//  overlap
-LFDIVInFlight2:
-	pushl	%eax
-
-	cmpw	10(%ecx),%bp
-	jl		Lp6
-	movb	(%esi),%al
-	cmpb	$(TRANSPARENT_COLOR),%al
-	jz		Lp6
-	movw	%bp,10(%ecx)
-	movb	%al,5(%edi)
-Lp6:
-	addl	izistep,%ebp
-	adcl	$0,%ebp
-	addl	tstep,%edx
-	sbbl	%eax,%eax
-	addl	sstep,%ebx
-	adcl	advancetable+4(,%eax,4),%esi
-
-	cmpw	12(%ecx),%bp
-	jl		Lp7
-	movb	(%esi),%al
-	cmpb	$(TRANSPARENT_COLOR),%al
-	jz		Lp7
-	movw	%bp,12(%ecx)
-	movb	%al,6(%edi)
-Lp7:
-	addl	izistep,%ebp
-	adcl	$0,%ebp
-	addl	tstep,%edx
-	sbbl	%eax,%eax
-	addl	sstep,%ebx
-	adcl	advancetable+4(,%eax,4),%esi
-
-	cmpw	14(%ecx),%bp
-	jl		Lp8
-	movb	(%esi),%al
-	cmpb	$(TRANSPARENT_COLOR),%al
-	jz		Lp8
-	movw	%bp,14(%ecx)
-	movb	%al,7(%edi)
-Lp8:
-	addl	izistep,%ebp
-	adcl	$0,%ebp
-	addl	tstep,%edx
-	sbbl	%eax,%eax
-	addl	sstep,%ebx
-	adcl	advancetable+4(,%eax,4),%esi
-
-	addl	$8,%edi
-	addl	$16,%ecx
-	movl	%edx,tfracf
-	movl	snext,%edx
-	movl	%ebx,sfracf
-	movl	tnext,%ebx
-	movl	%edx,s
-	movl	%ebx,t
-
-	movl	%ecx,pz
-	movl	%ebp,izi
-
-	popl	%ecx				// retrieve count
-
-//
-// determine whether last span or not
-//
-	cmpl	$8,%ecx				// are there multiple segments remaining?
-	ja		LNotLastSegment		// yes
-
-//
-// last segment of scan
-//
-LLastSegment:
-
-//
-// advance s/z, t/z, and 1/z, and calculate s & t at end of span and steps to
-// get there. The number of pixels left is variable, and we want to land on the
-// last pixel, not step one past it, so we can't run into arithmetic problems
-//
-	testl	%ecx,%ecx
-	jz		LNoSteps		// just draw the last pixel and we're done
-
-// pick up after the FDIV that was left in flight previously
-
-
-	fld		%st(0)			// duplicate it
-	fmul	%st(4),%st(0)	// s = s/z * z
-	fxch	%st(1)
-	fmul	%st(3),%st(0)	// t = t/z * z
-	fxch	%st(1)
-	fistpl	snext
-	fistpl	tnext
-
-	movl	C(tadjust),%ebx
-	movl	C(sadjust),%eax
-
-	addl	snext,%eax
-	addl	tnext,%ebx
-
-	movl	C(bbextents),%ebp
-	movl	C(bbextentt),%edx
-
-	cmpl	$2048,%eax
-	jl		LClampLow4
-	cmpl	%ebp,%eax
-	ja		LClampHigh4
-LClampReentry4:
-	movl	%eax,snext
-
-	cmpl	$2048,%ebx
-	jl		LClampLow5
-	cmpl	%edx,%ebx
-	ja		LClampHigh5
-LClampReentry5:
-
-	cmpl	$1,%ecx			// don't bother 
-	je		LOnlyOneStep	// if two pixels in segment, there's only one step,
-							//  of the segment length
-	subl	s,%eax
-	subl	t,%ebx
-
-	addl	%eax,%eax		// convert to 15.17 format so multiply by 1.31
-	addl	%ebx,%ebx		//  reciprocal yields 16.48
-	imull	reciprocal_table-8(,%ecx,4) // sstep = (snext - s) / (spancount-1)
-	movl	%edx,%ebp
-
-	movl	%ebx,%eax
-	imull	reciprocal_table-8(,%ecx,4) // tstep = (tnext - t) / (spancount-1)
-
-LSetEntryvec:
-//
-// set up advancetable
-//
-	movl	spr8entryvec_table(,%ecx,4),%ebx
-	movl	%edx,%eax
-	pushl	%ebx				// entry point into code for RET later
-	movl	%ebp,%ecx
-	sarl	$16,%ecx			// sstep >>= 16;
-	movl	C(cachewidth),%ebx
-	sarl	$16,%edx			// tstep >>= 16;
-	jz		LIsZeroLast
-	imull	%ebx,%edx			// (tstep >> 16) * cachewidth;
-LIsZeroLast:
-	addl	%ecx,%edx			// add in sstep
-								// (tstep >> 16) * cachewidth + (sstep >> 16);
-	movl	tfracf,%ecx
-	movl	%edx,advancetable+4	// advance base in t
-	addl	%ebx,%edx			// ((tstep >> 16) + 1) * cachewidth +
-								//  (sstep >> 16);
-	shll	$16,%ebp			// left-justify sstep fractional part
-	movl	sfracf,%ebx
-	shll	$16,%eax			// left-justify tstep fractional part
-	movl	%edx,advancetable	// advance extra in t
-
-	movl	%eax,tstep
-	movl	%ebp,sstep
-	movl	%ecx,%edx
-
-	movl	pz,%ecx
-	movl	izi,%ebp
-
-	ret							// jump to the number-of-pixels handler
-
-//----------------------------------------
-
-LNoSteps:
-	movl	pz,%ecx
-	subl	$7,%edi			// adjust for hardwired offset
-	subl	$14,%ecx
-	jmp		LEndSpan
-
-
-LOnlyOneStep:
-	subl	s,%eax
-	subl	t,%ebx
-	movl	%eax,%ebp
-	movl	%ebx,%edx
-	jmp		LSetEntryvec
-
-//----------------------------------------
-
-.globl	Spr8Entry2_8
-Spr8Entry2_8:
-	subl	$6,%edi		// adjust for hardwired offsets
-	subl	$12,%ecx
-	movb	(%esi),%al
-	jmp		LLEntry2_8
-
-//----------------------------------------
-
-.globl	Spr8Entry3_8
-Spr8Entry3_8:
-	subl	$5,%edi		// adjust for hardwired offsets
-	subl	$10,%ecx
-	jmp		LLEntry3_8
-
-//----------------------------------------
-
-.globl	Spr8Entry4_8
-Spr8Entry4_8:
-	subl	$4,%edi		// adjust for hardwired offsets
-	subl	$8,%ecx
-	jmp		LLEntry4_8
-
-//----------------------------------------
-
-.globl	Spr8Entry5_8
-Spr8Entry5_8:
-	subl	$3,%edi		// adjust for hardwired offsets
-	subl	$6,%ecx
-	jmp		LLEntry5_8
-
-//----------------------------------------
-
-.globl	Spr8Entry6_8
-Spr8Entry6_8:
-	subl	$2,%edi		// adjust for hardwired offsets
-	subl	$4,%ecx
-	jmp		LLEntry6_8
-
-//----------------------------------------
-
-.globl	Spr8Entry7_8
-Spr8Entry7_8:
-	decl	%edi		// adjust for hardwired offsets
-	subl	$2,%ecx
-	jmp		LLEntry7_8
-
-//----------------------------------------
-
-.globl	Spr8Entry8_8
-Spr8Entry8_8:
-	cmpw	(%ecx),%bp
-	jl		Lp9
-	movb	(%esi),%al
-	cmpb	$(TRANSPARENT_COLOR),%al
-	jz		Lp9
-	movw	%bp,(%ecx)
-	movb	%al,(%edi)
-Lp9:
-	addl	izistep,%ebp
-	adcl	$0,%ebp
-	addl	tstep,%edx
-	sbbl	%eax,%eax
-	addl	sstep,%ebx
-	adcl	advancetable+4(,%eax,4),%esi
-LLEntry7_8:
-	cmpw	2(%ecx),%bp
-	jl		Lp10
-	movb	(%esi),%al
-	cmpb	$(TRANSPARENT_COLOR),%al
-	jz		Lp10
-	movw	%bp,2(%ecx)
-	movb	%al,1(%edi)
-Lp10:
-	addl	izistep,%ebp
-	adcl	$0,%ebp
-	addl	tstep,%edx
-	sbbl	%eax,%eax
-	addl	sstep,%ebx
-	adcl	advancetable+4(,%eax,4),%esi
-LLEntry6_8:
-	cmpw	4(%ecx),%bp
-	jl		Lp11
-	movb	(%esi),%al
-	cmpb	$(TRANSPARENT_COLOR),%al
-	jz		Lp11
-	movw	%bp,4(%ecx)
-	movb	%al,2(%edi)
-Lp11:
-	addl	izistep,%ebp
-	adcl	$0,%ebp
-	addl	tstep,%edx
-	sbbl	%eax,%eax
-	addl	sstep,%ebx
-	adcl	advancetable+4(,%eax,4),%esi
-LLEntry5_8:
-	cmpw	6(%ecx),%bp
-	jl		Lp12
-	movb	(%esi),%al
-	cmpb	$(TRANSPARENT_COLOR),%al
-	jz		Lp12
-	movw	%bp,6(%ecx)
-	movb	%al,3(%edi)
-Lp12:
-	addl	izistep,%ebp
-	adcl	$0,%ebp
-	addl	tstep,%edx
-	sbbl	%eax,%eax
-	addl	sstep,%ebx
-	adcl	advancetable+4(,%eax,4),%esi
-LLEntry4_8:
-	cmpw	8(%ecx),%bp
-	jl		Lp13
-	movb	(%esi),%al
-	cmpb	$(TRANSPARENT_COLOR),%al
-	jz		Lp13
-	movw	%bp,8(%ecx)
-	movb	%al,4(%edi)
-Lp13:
-	addl	izistep,%ebp
-	adcl	$0,%ebp
-	addl	tstep,%edx
-	sbbl	%eax,%eax
-	addl	sstep,%ebx
-	adcl	advancetable+4(,%eax,4),%esi
-LLEntry3_8:
-	cmpw	10(%ecx),%bp
-	jl		Lp14
-	movb	(%esi),%al
-	cmpb	$(TRANSPARENT_COLOR),%al
-	jz		Lp14
-	movw	%bp,10(%ecx)
-	movb	%al,5(%edi)
-Lp14:
-	addl	izistep,%ebp
-	adcl	$0,%ebp
-	addl	tstep,%edx
-	sbbl	%eax,%eax
-	addl	sstep,%ebx
-	adcl	advancetable+4(,%eax,4),%esi
-LLEntry2_8:
-	cmpw	12(%ecx),%bp
-	jl		Lp15
-	movb	(%esi),%al
-	cmpb	$(TRANSPARENT_COLOR),%al
-	jz		Lp15
-	movw	%bp,12(%ecx)
-	movb	%al,6(%edi)
-Lp15:
-	addl	izistep,%ebp
-	adcl	$0,%ebp
-	addl	tstep,%edx
-	sbbl	%eax,%eax
-	addl	sstep,%ebx
-	adcl	advancetable+4(,%eax,4),%esi
-
-LEndSpan:
-	cmpw	14(%ecx),%bp
-	jl		Lp16
-	movb	(%esi),%al		// load first texel in segment
-	cmpb	$(TRANSPARENT_COLOR),%al
-	jz		Lp16
-	movw	%bp,14(%ecx)
-	movb	%al,7(%edi)
-Lp16:
-
-//
-// clear s/z, t/z, 1/z from FP stack
-//
-	fstp %st(0)
-	fstp %st(0)
-	fstp %st(0)
-
-	popl	%ebx				// restore spans pointer
-LNextSpan:
-	addl	$(sspan_t_size),%ebx // point to next span
-	movl	sspan_t_count(%ebx),%ecx
-	cmpl	$0,%ecx				// any more spans?
-	jg		LSpanLoop			// yes
-	jz		LNextSpan			// yes, but this one's empty
-
-	popl	%ebx				// restore register variables
-	popl	%esi
-	popl	%edi
-	popl	%ebp				// restore the caller's stack frame
-	ret
-
-#endif	// id386
diff -ruN WinQuake/d_vars.c sdlquake-1.0.9/d_vars.c
--- WinQuake/d_vars.c	Tue Dec 21 15:53:24 1999
+++ sdlquake-1.0.9/d_vars.c	Sat Dec 25 03:38:02 1999
@@ -19,9 +19,9 @@
 */
 // r_vars.c: global refresh variables
 
-#if	!id386
-
 #include	"quakedef.h"
+
+#if	!id386
 
 // all global and static refresh variables are collected in a contiguous block
 // to avoid cache conflicts.
diff -ruN WinQuake/d_varsa.S sdlquake-1.0.9/d_varsa.S
--- WinQuake/d_varsa.S	Wed Dec 31 16:00:00 1969
+++ sdlquake-1.0.9/d_varsa.S	Sat Dec 25 03:38:02 1999
@@ -0,0 +1,213 @@
+/*
+Copyright (C) 1996-1997 Id Software, Inc.
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation; either version 2
+of the License, or (at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
+
+See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+//
+// d_varsa.s
+//
+
+#include "asm_i386.h"
+#include "quakeasm.h"
+#include "asm_draw.h"
+#include "d_ifacea.h"
+
+#if	id386
+
+	.data
+
+//-------------------------------------------------------
+// global refresh variables
+//-------------------------------------------------------
+
+// FIXME: put all refresh variables into one contiguous block. Make into one
+// big structure, like cl or sv?
+
+	.align	4
+.globl	C(d_sdivzstepu)
+.globl	C(d_tdivzstepu)
+.globl	C(d_zistepu)
+.globl	C(d_sdivzstepv)
+.globl	C(d_tdivzstepv)
+.globl	C(d_zistepv)
+.globl	C(d_sdivzorigin)
+.globl	C(d_tdivzorigin)
+.globl	C(d_ziorigin)
+C(d_sdivzstepu):	.single	0
+C(d_tdivzstepu):	.single	0
+C(d_zistepu):		.single	0
+C(d_sdivzstepv):	.single	0
+C(d_tdivzstepv):	.single	0
+C(d_zistepv):		.single	0
+C(d_sdivzorigin):	.single	0
+C(d_tdivzorigin):	.single	0
+C(d_ziorigin):		.single	0
+
+.globl	C(sadjust)
+.globl	C(tadjust)
+.globl	C(bbextents)
+.globl	C(bbextentt)
+C(sadjust):			.long	0
+C(tadjust):			.long	0
+C(bbextents):		.long	0
+C(bbextentt):		.long	0
+
+.globl	C(cacheblock)
+.globl	C(d_viewbuffer)
+.globl	C(cachewidth)
+.globl	C(d_pzbuffer)
+.globl	C(d_zrowbytes)
+.globl	C(d_zwidth)
+C(cacheblock):		.long	0
+C(cachewidth):		.long	0
+C(d_viewbuffer):	.long	0
+C(d_pzbuffer):		.long	0
+C(d_zrowbytes):		.long	0
+C(d_zwidth):		.long	0
+
+
+//-------------------------------------------------------
+// ASM-only variables
+//-------------------------------------------------------
+.globl	izi
+izi:			.long	0
+
+.globl	pbase, s, t, sfracf, tfracf, snext, tnext
+.globl	spancountminus1, zi16stepu, sdivz16stepu, tdivz16stepu
+.globl	zi8stepu, sdivz8stepu, tdivz8stepu, pz
+s:				.long	0
+t:				.long	0
+snext:			.long	0
+tnext:			.long	0
+sfracf:			.long	0
+tfracf:			.long	0
+pbase:			.long	0
+zi8stepu:		.long	0
+sdivz8stepu:	.long	0
+tdivz8stepu:	.long	0
+zi16stepu:		.long	0
+sdivz16stepu:	.long	0
+tdivz16stepu:	.long	0
+spancountminus1: .long	0
+pz:				.long	0
+
+.globl	izistep
+izistep:				.long	0
+
+//-------------------------------------------------------
+// local variables for d_draw16.s
+//-------------------------------------------------------
+
+.globl	reciprocal_table_16, entryvec_table_16
+// 1/2, 1/3, 1/4, 1/5, 1/6, 1/7, 1/8, 1/9, 1/10, 1/11, 1/12, 1/13,
+// 1/14, and 1/15 in 0.32 form
+reciprocal_table_16:	.long	0x40000000, 0x2aaaaaaa, 0x20000000
+						.long	0x19999999, 0x15555555, 0x12492492
+						.long	0x10000000, 0xe38e38e, 0xccccccc, 0xba2e8ba
+						.long	0xaaaaaaa, 0x9d89d89, 0x9249249, 0x8888888
+
+#ifndef NeXT
+	.extern Entry2_16
+	.extern Entry3_16
+	.extern Entry4_16
+	.extern Entry5_16
+	.extern Entry6_16
+	.extern Entry7_16
+	.extern Entry8_16
+	.extern Entry9_16
+	.extern Entry10_16
+	.extern Entry11_16
+	.extern Entry12_16
+	.extern Entry13_16
+	.extern Entry14_16
+	.extern Entry15_16
+	.extern Entry16_16
+#endif
+
+entryvec_table_16:	.long	0, Entry2_16, Entry3_16, Entry4_16
+					.long	Entry5_16, Entry6_16, Entry7_16, Entry8_16
+					.long	Entry9_16, Entry10_16, Entry11_16, Entry12_16
+					.long	Entry13_16, Entry14_16, Entry15_16, Entry16_16
+
+//-------------------------------------------------------
+// local variables for d_parta.s
+//-------------------------------------------------------
+.globl	DP_Count, DP_u, DP_v, DP_32768, DP_Color, DP_Pix, DP_EntryTable
+DP_Count:		.long	0
+DP_u:			.long	0
+DP_v:			.long	0
+DP_32768:		.single	32768.0
+DP_Color:		.long	0
+DP_Pix:			.long	0
+
+
+#ifndef NeXT
+	.extern DP_1x1
+	.extern DP_2x2
+	.extern DP_3x3
+	.extern DP_4x4
+#endif
+
+DP_EntryTable:	.long	DP_1x1, DP_2x2, DP_3x3, DP_4x4
+
+//
+// advancetable is 8 bytes, but points to the middle of that range so negative
+// offsets will work
+//
+.globl	advancetable, sstep, tstep, pspantemp, counttemp, jumptemp
+advancetable:	.long	0, 0
+sstep:			.long	0
+tstep:			.long	0
+
+pspantemp:		.long	0
+counttemp:		.long	0
+jumptemp:		.long	0
+
+// 1/2, 1/3, 1/4, 1/5, 1/6, and 1/7 in 0.32 form
+.globl	reciprocal_table, entryvec_table
+reciprocal_table:	.long	0x40000000, 0x2aaaaaaa, 0x20000000
+					.long	0x19999999, 0x15555555, 0x12492492
+
+#ifndef NeXT
+	.extern Entry2_8
+	.extern Entry3_8
+	.extern Entry4_8
+	.extern Entry5_8
+	.extern Entry6_8
+	.extern Entry7_8
+	.extern Entry8_8
+#endif
+
+entryvec_table:	.long	0, Entry2_8, Entry3_8, Entry4_8
+				.long	Entry5_8, Entry6_8, Entry7_8, Entry8_8
+
+#ifndef NeXT
+	.extern Spr8Entry2_8
+	.extern Spr8Entry3_8
+	.extern Spr8Entry4_8
+	.extern Spr8Entry5_8
+	.extern Spr8Entry6_8
+	.extern Spr8Entry7_8
+	.extern Spr8Entry8_8
+#endif
+	
+.globl spr8entryvec_table
+spr8entryvec_table:	.long	0, Spr8Entry2_8, Spr8Entry3_8, Spr8Entry4_8
+					.long	Spr8Entry5_8, Spr8Entry6_8, Spr8Entry7_8, Spr8Entry8_8
+
+#endif	// id386
+
diff -ruN WinQuake/d_varsa.s sdlquake-1.0.9/d_varsa.s
--- WinQuake/d_varsa.s	Tue Dec 21 15:53:24 1999
+++ sdlquake-1.0.9/d_varsa.s	Wed Dec 31 16:00:00 1969
@@ -1,213 +0,0 @@
-/*
-Copyright (C) 1996-1997 Id Software, Inc.
-
-This program is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License
-as published by the Free Software Foundation; either version 2
-of the License, or (at your option) any later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
-
-See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-*/
-//
-// d_varsa.s
-//
-
-#include "asm_i386.h"
-#include "quakeasm.h"
-#include "asm_draw.h"
-#include "d_ifacea.h"
-
-#if	id386
-
-	.data
-
-//-------------------------------------------------------
-// global refresh variables
-//-------------------------------------------------------
-
-// FIXME: put all refresh variables into one contiguous block. Make into one
-// big structure, like cl or sv?
-
-	.align	4
-.globl	C(d_sdivzstepu)
-.globl	C(d_tdivzstepu)
-.globl	C(d_zistepu)
-.globl	C(d_sdivzstepv)
-.globl	C(d_tdivzstepv)
-.globl	C(d_zistepv)
-.globl	C(d_sdivzorigin)
-.globl	C(d_tdivzorigin)
-.globl	C(d_ziorigin)
-C(d_sdivzstepu):	.single	0
-C(d_tdivzstepu):	.single	0
-C(d_zistepu):		.single	0
-C(d_sdivzstepv):	.single	0
-C(d_tdivzstepv):	.single	0
-C(d_zistepv):		.single	0
-C(d_sdivzorigin):	.single	0
-C(d_tdivzorigin):	.single	0
-C(d_ziorigin):		.single	0
-
-.globl	C(sadjust)
-.globl	C(tadjust)
-.globl	C(bbextents)
-.globl	C(bbextentt)
-C(sadjust):			.long	0
-C(tadjust):			.long	0
-C(bbextents):		.long	0
-C(bbextentt):		.long	0
-
-.globl	C(cacheblock)
-.globl	C(d_viewbuffer)
-.globl	C(cachewidth)
-.globl	C(d_pzbuffer)
-.globl	C(d_zrowbytes)
-.globl	C(d_zwidth)
-C(cacheblock):		.long	0
-C(cachewidth):		.long	0
-C(d_viewbuffer):	.long	0
-C(d_pzbuffer):		.long	0
-C(d_zrowbytes):		.long	0
-C(d_zwidth):		.long	0
-
-
-//-------------------------------------------------------
-// ASM-only variables
-//-------------------------------------------------------
-.globl	izi
-izi:			.long	0
-
-.globl	pbase, s, t, sfracf, tfracf, snext, tnext
-.globl	spancountminus1, zi16stepu, sdivz16stepu, tdivz16stepu
-.globl	zi8stepu, sdivz8stepu, tdivz8stepu, pz
-s:				.long	0
-t:				.long	0
-snext:			.long	0
-tnext:			.long	0
-sfracf:			.long	0
-tfracf:			.long	0
-pbase:			.long	0
-zi8stepu:		.long	0
-sdivz8stepu:	.long	0
-tdivz8stepu:	.long	0
-zi16stepu:		.long	0
-sdivz16stepu:	.long	0
-tdivz16stepu:	.long	0
-spancountminus1: .long	0
-pz:				.long	0
-
-.globl	izistep
-izistep:				.long	0
-
-//-------------------------------------------------------
-// local variables for d_draw16.s
-//-------------------------------------------------------
-
-.globl	reciprocal_table_16, entryvec_table_16
-// 1/2, 1/3, 1/4, 1/5, 1/6, 1/7, 1/8, 1/9, 1/10, 1/11, 1/12, 1/13,
-// 1/14, and 1/15 in 0.32 form
-reciprocal_table_16:	.long	0x40000000, 0x2aaaaaaa, 0x20000000
-						.long	0x19999999, 0x15555555, 0x12492492
-						.long	0x10000000, 0xe38e38e, 0xccccccc, 0xba2e8ba
-						.long	0xaaaaaaa, 0x9d89d89, 0x9249249, 0x8888888
-
-#ifndef NeXT
-	.extern Entry2_16
-	.extern Entry3_16
-	.extern Entry4_16
-	.extern Entry5_16
-	.extern Entry6_16
-	.extern Entry7_16
-	.extern Entry8_16
-	.extern Entry9_16
-	.extern Entry10_16
-	.extern Entry11_16
-	.extern Entry12_16
-	.extern Entry13_16
-	.extern Entry14_16
-	.extern Entry15_16
-	.extern Entry16_16
-#endif
-
-entryvec_table_16:	.long	0, Entry2_16, Entry3_16, Entry4_16
-					.long	Entry5_16, Entry6_16, Entry7_16, Entry8_16
-					.long	Entry9_16, Entry10_16, Entry11_16, Entry12_16
-					.long	Entry13_16, Entry14_16, Entry15_16, Entry16_16
-
-//-------------------------------------------------------
-// local variables for d_parta.s
-//-------------------------------------------------------
-.globl	DP_Count, DP_u, DP_v, DP_32768, DP_Color, DP_Pix, DP_EntryTable
-DP_Count:		.long	0
-DP_u:			.long	0
-DP_v:			.long	0
-DP_32768:		.single	32768.0
-DP_Color:		.long	0
-DP_Pix:			.long	0
-
-
-#ifndef NeXT
-	.extern DP_1x1
-	.extern DP_2x2
-	.extern DP_3x3
-	.extern DP_4x4
-#endif
-
-DP_EntryTable:	.long	DP_1x1, DP_2x2, DP_3x3, DP_4x4
-
-//
-// advancetable is 8 bytes, but points to the middle of that range so negative
-// offsets will work
-//
-.globl	advancetable, sstep, tstep, pspantemp, counttemp, jumptemp
-advancetable:	.long	0, 0
-sstep:			.long	0
-tstep:			.long	0
-
-pspantemp:		.long	0
-counttemp:		.long	0
-jumptemp:		.long	0
-
-// 1/2, 1/3, 1/4, 1/5, 1/6, and 1/7 in 0.32 form
-.globl	reciprocal_table, entryvec_table
-reciprocal_table:	.long	0x40000000, 0x2aaaaaaa, 0x20000000
-					.long	0x19999999, 0x15555555, 0x12492492
-
-#ifndef NeXT
-	.extern Entry2_8
-	.extern Entry3_8
-	.extern Entry4_8
-	.extern Entry5_8
-	.extern Entry6_8
-	.extern Entry7_8
-	.extern Entry8_8
-#endif
-
-entryvec_table:	.long	0, Entry2_8, Entry3_8, Entry4_8
-				.long	Entry5_8, Entry6_8, Entry7_8, Entry8_8
-
-#ifndef NeXT
-	.extern Spr8Entry2_8
-	.extern Spr8Entry3_8
-	.extern Spr8Entry4_8
-	.extern Spr8Entry5_8
-	.extern Spr8Entry6_8
-	.extern Spr8Entry7_8
-	.extern Spr8Entry8_8
-#endif
-	
-.globl spr8entryvec_table
-spr8entryvec_table:	.long	0, Spr8Entry2_8, Spr8Entry3_8, Spr8Entry4_8
-					.long	Spr8Entry5_8, Spr8Entry6_8, Spr8Entry7_8, Spr8Entry8_8
-
-#endif	// id386
-
diff -ruN WinQuake/dosasm.S sdlquake-1.0.9/dosasm.S
--- WinQuake/dosasm.S	Wed Dec 31 16:00:00 1969
+++ sdlquake-1.0.9/dosasm.S	Sat Dec 25 03:38:02 1999
@@ -0,0 +1,77 @@
+#include "asm_i386.h"
+
+.data
+fpenv:	.long	0, 0, 0, 0, 0, 0, 0, 0
+
+.text
+.globl	C(StartMSRInterval)
+C(StartMSRInterval):
+	movl	$0x11,%ecx	// read the CESR
+	.byte	0x0F
+	.byte	0x32		// RDMSR
+
+	andl	$0xFE3FFE3F,%eax	// stop both counters
+	.byte	0x0F
+	.byte	0x30		// WRMSR
+
+	movl	4(%esp),%eax	// point counter 0 to desired event, with counters
+	andl	$0x3F,%eax		//  still stopped
+	movl	$0x11,%ecx
+	.byte	0x0F
+	.byte	0x30		// WRMSR
+
+	movl	$0x12,%ecx	// set counter 0 to the value 0
+	subl	%eax,%eax
+	subl	%edx,%edx
+	.byte	0x0F
+	.byte	0x30		// WRMSR
+	
+	movl	4(%esp),%eax // restart counter 0 with selected event
+	andl	$0x3F,%eax
+	subl	%edx,%edx
+	orl		$0xC0,%eax
+	movl	$0x11,%ecx	// control and event select
+	.byte	0x0F
+	.byte	0x30		// WRMSR
+
+	ret
+
+.globl	C(EndMSRInterval)
+C(EndMSRInterval):
+	movl	$0x12,%ecx	// counter 0
+	.byte	0x0F
+	.byte	0x32		// RDMSR
+
+	ret					// lower 32 bits of count in %eax
+
+#if 0
+	.data
+Lxxx:	.long	0
+
+	.text
+
+.globl C(setstackcheck)
+C(setstackcheck):
+
+	movl	%esp,%eax
+	subl	$0x38000,%eax
+	movl	$0x5A5A5A5A,(%eax)
+	movl	%eax,Lxxx
+
+	ret
+
+
+.globl C(dostackcheck)
+C(dostackcheck):
+
+	movl	Lxxx,%edx
+	movl	$0,%eax
+
+	cmpl	$0x5A5A5A5A,(%edx)
+	jz		qqq
+	incl	%eax
+qqq:
+
+	ret
+#endif
+
diff -ruN WinQuake/dosasm.s sdlquake-1.0.9/dosasm.s
--- WinQuake/dosasm.s	Wed Aug 12 12:45:08 1998
+++ sdlquake-1.0.9/dosasm.s	Wed Dec 31 16:00:00 1969
@@ -1,77 +0,0 @@
-#include "asm_i386.h"
-
-.data
-fpenv:	.long	0, 0, 0, 0, 0, 0, 0, 0
-
-.text
-.globl	C(StartMSRInterval)
-C(StartMSRInterval):
-	movl	$0x11,%ecx	// read the CESR
-	.byte	0x0F
-	.byte	0x32		// RDMSR
-
-	andl	$0xFE3FFE3F,%eax	// stop both counters
-	.byte	0x0F
-	.byte	0x30		// WRMSR
-
-	movl	4(%esp),%eax	// point counter 0 to desired event, with counters
-	andl	$0x3F,%eax		//  still stopped
-	movl	$0x11,%ecx
-	.byte	0x0F
-	.byte	0x30		// WRMSR
-
-	movl	$0x12,%ecx	// set counter 0 to the value 0
-	subl	%eax,%eax
-	subl	%edx,%edx
-	.byte	0x0F
-	.byte	0x30		// WRMSR
-	
-	movl	4(%esp),%eax // restart counter 0 with selected event
-	andl	$0x3F,%eax
-	subl	%edx,%edx
-	orl		$0xC0,%eax
-	movl	$0x11,%ecx	// control and event select
-	.byte	0x0F
-	.byte	0x30		// WRMSR
-
-	ret
-
-.globl	C(EndMSRInterval)
-C(EndMSRInterval):
-	movl	$0x12,%ecx	// counter 0
-	.byte	0x0F
-	.byte	0x32		// RDMSR
-
-	ret					// lower 32 bits of count in %eax
-
-#if 0
-	.data
-Lxxx:	.long	0
-
-	.text
-
-.globl C(setstackcheck)
-C(setstackcheck):
-
-	movl	%esp,%eax
-	subl	$0x38000,%eax
-	movl	$0x5A5A5A5A,(%eax)
-	movl	%eax,Lxxx
-
-	ret
-
-
-.globl C(dostackcheck)
-C(dostackcheck):
-
-	movl	Lxxx,%edx
-	movl	$0,%eax
-
-	cmpl	$0x5A5A5A5A,(%edx)
-	jz		qqq
-	incl	%eax
-qqq:
-
-	ret
-#endif
-
diff -ruN WinQuake/install-sh sdlquake-1.0.9/install-sh
--- WinQuake/install-sh	Wed Dec 31 16:00:00 1969
+++ sdlquake-1.0.9/install-sh	Sat Dec 25 03:38:02 1999
@@ -0,0 +1,251 @@
+#!/bin/sh
+#
+# install - install a program, script, or datafile
+# This comes from X11R5 (mit/util/scripts/install.sh).
+#
+# Copyright 1991 by the Massachusetts Institute of Technology
+#
+# Permission to use, copy, modify, distribute, and sell this software and its
+# documentation for any purpose is hereby granted without fee, provided that
+# the above copyright notice appear in all copies and that both that
+# copyright notice and this permission notice appear in supporting
+# documentation, and that the name of M.I.T. not be used in advertising or
+# publicity pertaining to distribution of the software without specific,
+# written prior permission.  M.I.T. makes no representations about the
+# suitability of this software for any purpose.  It is provided "as is"
+# without express or implied warranty.
+#
+# Calling this script install-sh is preferred over install.sh, to prevent
+# `make' implicit rules from creating a file called install from it
+# when there is no Makefile.
+#
+# This script is compatible with the BSD install script, but was written
+# from scratch.  It can only install one file at a time, a restriction
+# shared with many OS's install programs.
+
+
+# set DOITPROG to echo to test this script
+
+# Don't use :- since 4.3BSD and earlier shells don't like it.
+doit="${DOITPROG-}"
+
+
+# put in absolute paths if you don't have them in your path; or use env. vars.
+
+mvprog="${MVPROG-mv}"
+cpprog="${CPPROG-cp}"
+chmodprog="${CHMODPROG-chmod}"
+chownprog="${CHOWNPROG-chown}"
+chgrpprog="${CHGRPPROG-chgrp}"
+stripprog="${STRIPPROG-strip}"
+rmprog="${RMPROG-rm}"
+mkdirprog="${MKDIRPROG-mkdir}"
+
+transformbasename=""
+transform_arg=""
+instcmd="$mvprog"
+chmodcmd="$chmodprog 0755"
+chowncmd=""
+chgrpcmd=""
+stripcmd=""
+rmcmd="$rmprog -f"
+mvcmd="$mvprog"
+src=""
+dst=""
+dir_arg=""
+
+while [ x"$1" != x ]; do
+    case $1 in
+	-c) instcmd="$cpprog"
+	    shift
+	    continue;;
+
+	-d) dir_arg=true
+	    shift
+	    continue;;
+
+	-m) chmodcmd="$chmodprog $2"
+	    shift
+	    shift
+	    continue;;
+
+	-o) chowncmd="$chownprog $2"
+	    shift
+	    shift
+	    continue;;
+
+	-g) chgrpcmd="$chgrpprog $2"
+	    shift
+	    shift
+	    continue;;
+
+	-s) stripcmd="$stripprog"
+	    shift
+	    continue;;
+
+	-t=*) transformarg=`echo $1 | sed 's/-t=//'`
+	    shift
+	    continue;;
+
+	-b=*) transformbasename=`echo $1 | sed 's/-b=//'`
+	    shift
+	    continue;;
+
+	*)  if [ x"$src" = x ]
+	    then
+		src=$1
+	    else
+		# this colon is to work around a 386BSD /bin/sh bug
+		:
+		dst=$1
+	    fi
+	    shift
+	    continue;;
+    esac
+done
+
+if [ x"$src" = x ]
+then
+	echo "install:	no input file specified"
+	exit 1
+else
+	true
+fi
+
+if [ x"$dir_arg" != x ]; then
+	dst=$src
+	src=""
+	
+	if [ -d $dst ]; then
+		instcmd=:
+		chmodcmd=""
+	else
+		instcmd=mkdir
+	fi
+else
+
+# Waiting for this to be detected by the "$instcmd $src $dsttmp" command
+# might cause directories to be created, which would be especially bad 
+# if $src (and thus $dsttmp) contains '*'.
+
+	if [ -f $src -o -d $src ]
+	then
+		true
+	else
+		echo "install:  $src does not exist"
+		exit 1
+	fi
+	
+	if [ x"$dst" = x ]
+	then
+		echo "install:	no destination specified"
+		exit 1
+	else
+		true
+	fi
+
+# If destination is a directory, append the input filename; if your system
+# does not like double slashes in filenames, you may need to add some logic
+
+	if [ -d $dst ]
+	then
+		dst="$dst"/`basename $src`
+	else
+		true
+	fi
+fi
+
+## this sed command emulates the dirname command
+dstdir=`echo $dst | sed -e 's,[^/]*$,,;s,/$,,;s,^$,.,'`
+
+# Make sure that the destination directory exists.
+#  this part is taken from Noah Friedman's mkinstalldirs script
+
+# Skip lots of stat calls in the usual case.
+if [ ! -d "$dstdir" ]; then
+defaultIFS='	
+'
+IFS="${IFS-${defaultIFS}}"
+
+oIFS="${IFS}"
+# Some sh's can't handle IFS=/ for some reason.
+IFS='%'
+set - `echo ${dstdir} | sed -e 's@/@%@g' -e 's@^%@/@'`
+IFS="${oIFS}"
+
+pathcomp=''
+
+while [ $# -ne 0 ] ; do
+	pathcomp="${pathcomp}${1}"
+	shift
+
+	if [ ! -d "${pathcomp}" ] ;
+        then
+		$mkdirprog "${pathcomp}"
+	else
+		true
+	fi
+
+	pathcomp="${pathcomp}/"
+done
+fi
+
+if [ x"$dir_arg" != x ]
+then
+	$doit $instcmd $dst &&
+
+	if [ x"$chowncmd" != x ]; then $doit $chowncmd $dst; else true ; fi &&
+	if [ x"$chgrpcmd" != x ]; then $doit $chgrpcmd $dst; else true ; fi &&
+	if [ x"$stripcmd" != x ]; then $doit $stripcmd $dst; else true ; fi &&
+	if [ x"$chmodcmd" != x ]; then $doit $chmodcmd $dst; else true ; fi
+else
+
+# If we're going to rename the final executable, determine the name now.
+
+	if [ x"$transformarg" = x ] 
+	then
+		dstfile=`basename $dst`
+	else
+		dstfile=`basename $dst $transformbasename | 
+			sed $transformarg`$transformbasename
+	fi
+
+# don't allow the sed command to completely eliminate the filename
+
+	if [ x"$dstfile" = x ] 
+	then
+		dstfile=`basename $dst`
+	else
+		true
+	fi
+
+# Make a temp file name in the proper directory.
+
+	dsttmp=$dstdir/#inst.$$#
+
+# Move or copy the file name to the temp name
+
+	$doit $instcmd $src $dsttmp &&
+
+	trap "rm -f ${dsttmp}" 0 &&
+
+# and set any options; do chmod last to preserve setuid bits
+
+# If any of these fail, we abort the whole thing.  If we want to
+# ignore errors from any of these, just make sure not to ignore
+# errors from the above "$doit $instcmd $src $dsttmp" command.
+
+	if [ x"$chowncmd" != x ]; then $doit $chowncmd $dsttmp; else true;fi &&
+	if [ x"$chgrpcmd" != x ]; then $doit $chgrpcmd $dsttmp; else true;fi &&
+	if [ x"$stripcmd" != x ]; then $doit $stripcmd $dsttmp; else true;fi &&
+	if [ x"$chmodcmd" != x ]; then $doit $chmodcmd $dsttmp; else true;fi &&
+
+# Now rename the file to the real destination.
+
+	$doit $rmcmd -f $dstdir/$dstfile &&
+	$doit $mvcmd $dsttmp $dstdir/$dstfile 
+
+fi &&
+
+
+exit 0
diff -ruN WinQuake/math.S sdlquake-1.0.9/math.S
--- WinQuake/math.S	Wed Dec 31 16:00:00 1969
+++ sdlquake-1.0.9/math.S	Sat Dec 25 03:38:02 1999
@@ -0,0 +1,418 @@
+/*
+Copyright (C) 1996-1997 Id Software, Inc.
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation; either version 2
+of the License, or (at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
+
+See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+//
+// math.s
+// x86 assembly-language math routines.
+
+#define GLQUAKE	1	// don't include unneeded defs
+#include "asm_i386.h"
+#include "quakeasm.h"
+
+
+#if	id386
+
+	.data
+
+	.align	4
+Ljmptab:	.long	Lcase0, Lcase1, Lcase2, Lcase3
+			.long	Lcase4, Lcase5, Lcase6, Lcase7
+
+	.text
+
+// TODO: rounding needed?
+// stack parameter offset
+#define	val	4
+
+.globl C(Invert24To16)
+C(Invert24To16):
+
+	movl	val(%esp),%ecx
+	movl	$0x100,%edx		// 0x10000000000 as dividend
+	cmpl	%edx,%ecx
+	jle		LOutOfRange
+
+	subl	%eax,%eax
+	divl	%ecx
+
+	ret
+
+LOutOfRange:
+	movl	$0xFFFFFFFF,%eax
+	ret
+
+#define	in	4
+#define out	8
+
+	.align 2
+.globl C(TransformVector)
+C(TransformVector):
+	movl	in(%esp),%eax
+	movl	out(%esp),%edx
+
+	flds	(%eax)		// in[0]
+	fmuls	C(vright)		// in[0]*vright[0]
+	flds	(%eax)		// in[0] | in[0]*vright[0]
+	fmuls	C(vup)		// in[0]*vup[0] | in[0]*vright[0]
+	flds	(%eax)		// in[0] | in[0]*vup[0] | in[0]*vright[0]
+	fmuls	C(vpn)		// in[0]*vpn[0] | in[0]*vup[0] | in[0]*vright[0]
+
+	flds	4(%eax)		// in[1] | ...
+	fmuls	C(vright)+4	// in[1]*vright[1] | ...
+	flds	4(%eax)		// in[1] | in[1]*vright[1] | ...
+	fmuls	C(vup)+4		// in[1]*vup[1] | in[1]*vright[1] | ...
+	flds	4(%eax)		// in[1] | in[1]*vup[1] | in[1]*vright[1] | ...
+	fmuls	C(vpn)+4		// in[1]*vpn[1] | in[1]*vup[1] | in[1]*vright[1] | ...
+	fxch	%st(2)		// in[1]*vright[1] | in[1]*vup[1] | in[1]*vpn[1] | ...
+
+	faddp	%st(0),%st(5)	// in[1]*vup[1] | in[1]*vpn[1] | ...
+	faddp	%st(0),%st(3)	// in[1]*vpn[1] | ...
+	faddp	%st(0),%st(1)	// vpn_accum | vup_accum | vright_accum
+
+	flds	8(%eax)		// in[2] | ...
+	fmuls	C(vright)+8	// in[2]*vright[2] | ...
+	flds	8(%eax)		// in[2] | in[2]*vright[2] | ...
+	fmuls	C(vup)+8		// in[2]*vup[2] | in[2]*vright[2] | ...
+	flds	8(%eax)		// in[2] | in[2]*vup[2] | in[2]*vright[2] | ...
+	fmuls	C(vpn)+8		// in[2]*vpn[2] | in[2]*vup[2] | in[2]*vright[2] | ...
+	fxch	%st(2)		// in[2]*vright[2] | in[2]*vup[2] | in[2]*vpn[2] | ...
+
+	faddp	%st(0),%st(5)	// in[2]*vup[2] | in[2]*vpn[2] | ...
+	faddp	%st(0),%st(3)	// in[2]*vpn[2] | ...
+	faddp	%st(0),%st(1)	// vpn_accum | vup_accum | vright_accum
+
+	fstps	8(%edx)		// out[2]
+	fstps	4(%edx)		// out[1]
+	fstps	(%edx)		// out[0]
+
+	ret
+
+
+#define EMINS	4+4
+#define EMAXS	4+8
+#define P		4+12
+
+	.align 2
+.globl C(BoxOnPlaneSide)
+C(BoxOnPlaneSide):
+	pushl	%ebx
+
+	movl	P(%esp),%edx
+	movl	EMINS(%esp),%ecx
+	xorl	%eax,%eax
+	movl	EMAXS(%esp),%ebx
+	movb	pl_signbits(%edx),%al
+	cmpb	$8,%al
+	jge		Lerror
+	flds	pl_normal(%edx)		// p->normal[0]
+	fld		%st(0)				// p->normal[0] | p->normal[0]
+	jmp		Ljmptab(,%eax,4)
+
+
+//dist1= p->normal[0]*emaxs[0] + p->normal[1]*emaxs[1] + p->normal[2]*emaxs[2];
+//dist2= p->normal[0]*emins[0] + p->normal[1]*emins[1] + p->normal[2]*emins[2];
+Lcase0:
+	fmuls	(%ebx)				// p->normal[0]*emaxs[0] | p->normal[0]
+	flds	pl_normal+4(%edx)	// p->normal[1] | p->normal[0]*emaxs[0] |
+								//  p->normal[0]
+	fxch	%st(2)				// p->normal[0] | p->normal[0]*emaxs[0] |
+								//  p->normal[1]
+	fmuls	(%ecx)				// p->normal[0]*emins[0] |
+								//  p->normal[0]*emaxs[0] | p->normal[1]
+	fxch	%st(2)				// p->normal[1] | p->normal[0]*emaxs[0] |
+								//  p->normal[0]*emins[0]
+	fld		%st(0)				// p->normal[1] | p->normal[1] |
+								//  p->normal[0]*emaxs[0] |
+								//  p->normal[0]*emins[0]
+	fmuls	4(%ebx)				// p->normal[1]*emaxs[1] | p->normal[1] |
+								//  p->normal[0]*emaxs[0] |
+								//  p->normal[0]*emins[0]
+	flds	pl_normal+8(%edx)	// p->normal[2] | p->normal[1]*emaxs[1] |
+								//  p->normal[1] | p->normal[0]*emaxs[0] |
+								//  p->normal[0]*emins[0]
+	fxch	%st(2)				// p->normal[1] | p->normal[1]*emaxs[1] |
+								//  p->normal[2] | p->normal[0]*emaxs[0] |
+								//  p->normal[0]*emins[0]
+	fmuls	4(%ecx)				// p->normal[1]*emins[1] |
+								//  p->normal[1]*emaxs[1] |
+								//  p->normal[2] | p->normal[0]*emaxs[0] |
+								//  p->normal[0]*emins[0]
+	fxch	%st(2)				// p->normal[2] | p->normal[1]*emaxs[1] |
+								//  p->normal[1]*emins[1] |
+								//  p->normal[0]*emaxs[0] |
+								//  p->normal[0]*emins[0]
+	fld		%st(0)				// p->normal[2] | p->normal[2] |
+								//  p->normal[1]*emaxs[1] |
+								//  p->normal[1]*emins[1] |
+								//  p->normal[0]*emaxs[0] |
+								//  p->normal[0]*emins[0]
+	fmuls	8(%ebx)				// p->normal[2]*emaxs[2] |
+								//  p->normal[2] |
+								//  p->normal[1]*emaxs[1] |
+								//  p->normal[1]*emins[1] |
+								//  p->normal[0]*emaxs[0] |
+								//  p->normal[0]*emins[0]
+	fxch	%st(5)				// p->normal[0]*emins[0] |
+								//  p->normal[2] |
+								//  p->normal[1]*emaxs[1] |
+								//  p->normal[1]*emins[1] |
+								//  p->normal[0]*emaxs[0] |
+								//  p->normal[2]*emaxs[2]
+	faddp	%st(0),%st(3)		//p->normal[2] |
+								// p->normal[1]*emaxs[1] |
+								// p->normal[1]*emins[1]+p->normal[0]*emins[0]|
+								// p->normal[0]*emaxs[0] |
+								// p->normal[2]*emaxs[2]
+	fmuls	8(%ecx)				//p->normal[2]*emins[2] |
+								// p->normal[1]*emaxs[1] |
+								// p->normal[1]*emins[1]+p->normal[0]*emins[0]|
+								// p->normal[0]*emaxs[0] |
+								// p->normal[2]*emaxs[2]
+	fxch	%st(1)				//p->normal[1]*emaxs[1] |
+								// p->normal[2]*emins[2] |
+								// p->normal[1]*emins[1]+p->normal[0]*emins[0]|
+								// p->normal[0]*emaxs[0] |
+								// p->normal[2]*emaxs[2]
+	faddp	%st(0),%st(3)		//p->normal[2]*emins[2] |
+								// p->normal[1]*emins[1]+p->normal[0]*emins[0]|
+								// p->normal[0]*emaxs[0]+p->normal[1]*emaxs[1]|
+								// p->normal[2]*emaxs[2]
+	fxch	%st(3)				//p->normal[2]*emaxs[2] +
+								// p->normal[1]*emins[1]+p->normal[0]*emins[0]|
+								// p->normal[0]*emaxs[0]+p->normal[1]*emaxs[1]|
+								// p->normal[2]*emins[2]
+	faddp	%st(0),%st(2)		//p->normal[1]*emins[1]+p->normal[0]*emins[0]|
+								// dist1 | p->normal[2]*emins[2]
+
+	jmp		LSetSides
+
+//dist1= p->normal[0]*emins[0] + p->normal[1]*emaxs[1] + p->normal[2]*emaxs[2];
+//dist2= p->normal[0]*emaxs[0] + p->normal[1]*emins[1] + p->normal[2]*emins[2];
+Lcase1:
+	fmuls	(%ecx)				// emins[0]
+	flds	pl_normal+4(%edx)
+	fxch	%st(2)
+	fmuls	(%ebx)				// emaxs[0]
+	fxch	%st(2)
+	fld		%st(0)
+	fmuls	4(%ebx)				// emaxs[1]
+	flds	pl_normal+8(%edx)
+	fxch	%st(2)
+	fmuls	4(%ecx)				// emins[1]
+	fxch	%st(2)
+	fld		%st(0)
+	fmuls	8(%ebx)				// emaxs[2]
+	fxch	%st(5)
+	faddp	%st(0),%st(3)
+	fmuls	8(%ecx)				// emins[2]
+	fxch	%st(1)
+	faddp	%st(0),%st(3)
+	fxch	%st(3)
+	faddp	%st(0),%st(2)
+
+	jmp		LSetSides
+
+//dist1= p->normal[0]*emaxs[0] + p->normal[1]*emins[1] + p->normal[2]*emaxs[2];
+//dist2= p->normal[0]*emins[0] + p->normal[1]*emaxs[1] + p->normal[2]*emins[2];
+Lcase2:
+	fmuls	(%ebx)				// emaxs[0]
+	flds	pl_normal+4(%edx)
+	fxch	%st(2)
+	fmuls	(%ecx)				// emins[0]
+	fxch	%st(2)
+	fld		%st(0)
+	fmuls	4(%ecx)				// emins[1]
+	flds	pl_normal+8(%edx)
+	fxch	%st(2)
+	fmuls	4(%ebx)				// emaxs[1]
+	fxch	%st(2)
+	fld		%st(0)
+	fmuls	8(%ebx)				// emaxs[2]
+	fxch	%st(5)
+	faddp	%st(0),%st(3)
+	fmuls	8(%ecx)				// emins[2]
+	fxch	%st(1)
+	faddp	%st(0),%st(3)
+	fxch	%st(3)
+	faddp	%st(0),%st(2)
+
+	jmp		LSetSides
+
+//dist1= p->normal[0]*emins[0] + p->normal[1]*emins[1] + p->normal[2]*emaxs[2];
+//dist2= p->normal[0]*emaxs[0] + p->normal[1]*emaxs[1] + p->normal[2]*emins[2];
+Lcase3:
+	fmuls	(%ecx)				// emins[0]
+	flds	pl_normal+4(%edx)
+	fxch	%st(2)
+	fmuls	(%ebx)				// emaxs[0]
+	fxch	%st(2)
+	fld		%st(0)
+	fmuls	4(%ecx)				// emins[1]
+	flds	pl_normal+8(%edx)
+	fxch	%st(2)
+	fmuls	4(%ebx)				// emaxs[1]
+	fxch	%st(2)
+	fld		%st(0)
+	fmuls	8(%ebx)				// emaxs[2]
+	fxch	%st(5)
+	faddp	%st(0),%st(3)
+	fmuls	8(%ecx)				// emins[2]
+	fxch	%st(1)
+	faddp	%st(0),%st(3)
+	fxch	%st(3)
+	faddp	%st(0),%st(2)
+
+	jmp		LSetSides
+
+//dist1= p->normal[0]*emaxs[0] + p->normal[1]*emaxs[1] + p->normal[2]*emins[2];
+//dist2= p->normal[0]*emins[0] + p->normal[1]*emins[1] + p->normal[2]*emaxs[2];
+Lcase4:
+	fmuls	(%ebx)				// emaxs[0]
+	flds	pl_normal+4(%edx)
+	fxch	%st(2)
+	fmuls	(%ecx)				// emins[0]
+	fxch	%st(2)
+	fld		%st(0)
+	fmuls	4(%ebx)				// emaxs[1]
+	flds	pl_normal+8(%edx)
+	fxch	%st(2)
+	fmuls	4(%ecx)				// emins[1]
+	fxch	%st(2)
+	fld		%st(0)
+	fmuls	8(%ecx)				// emins[2]
+	fxch	%st(5)
+	faddp	%st(0),%st(3)
+	fmuls	8(%ebx)				// emaxs[2]
+	fxch	%st(1)
+	faddp	%st(0),%st(3)
+	fxch	%st(3)
+	faddp	%st(0),%st(2)
+
+	jmp		LSetSides
+
+//dist1= p->normal[0]*emins[0] + p->normal[1]*emaxs[1] + p->normal[2]*emins[2];
+//dist2= p->normal[0]*emaxs[0] + p->normal[1]*emins[1] + p->normal[2]*emaxs[2];
+Lcase5:
+	fmuls	(%ecx)				// emins[0]
+	flds	pl_normal+4(%edx)
+	fxch	%st(2)
+	fmuls	(%ebx)				// emaxs[0]
+	fxch	%st(2)
+	fld		%st(0)
+	fmuls	4(%ebx)				// emaxs[1]
+	flds	pl_normal+8(%edx)
+	fxch	%st(2)
+	fmuls	4(%ecx)				// emins[1]
+	fxch	%st(2)
+	fld		%st(0)
+	fmuls	8(%ecx)				// emins[2]
+	fxch	%st(5)
+	faddp	%st(0),%st(3)
+	fmuls	8(%ebx)				// emaxs[2]
+	fxch	%st(1)
+	faddp	%st(0),%st(3)
+	fxch	%st(3)
+	faddp	%st(0),%st(2)
+
+	jmp		LSetSides
+
+//dist1= p->normal[0]*emaxs[0] + p->normal[1]*emins[1] + p->normal[2]*emins[2];
+//dist2= p->normal[0]*emins[0] + p->normal[1]*emaxs[1] + p->normal[2]*emaxs[2];
+Lcase6:
+	fmuls	(%ebx)				// emaxs[0]
+	flds	pl_normal+4(%edx)
+	fxch	%st(2)
+	fmuls	(%ecx)				// emins[0]
+	fxch	%st(2)
+	fld		%st(0)
+	fmuls	4(%ecx)				// emins[1]
+	flds	pl_normal+8(%edx)
+	fxch	%st(2)
+	fmuls	4(%ebx)				// emaxs[1]
+	fxch	%st(2)
+	fld		%st(0)
+	fmuls	8(%ecx)				// emins[2]
+	fxch	%st(5)
+	faddp	%st(0),%st(3)
+	fmuls	8(%ebx)				// emaxs[2]
+	fxch	%st(1)
+	faddp	%st(0),%st(3)
+	fxch	%st(3)
+	faddp	%st(0),%st(2)
+
+	jmp		LSetSides
+
+//dist1= p->normal[0]*emins[0] + p->normal[1]*emins[1] + p->normal[2]*emins[2];
+//dist2= p->normal[0]*emaxs[0] + p->normal[1]*emaxs[1] + p->normal[2]*emaxs[2];
+Lcase7:
+	fmuls	(%ecx)				// emins[0]
+	flds	pl_normal+4(%edx)
+	fxch	%st(2)
+	fmuls	(%ebx)				// emaxs[0]
+	fxch	%st(2)
+	fld		%st(0)
+	fmuls	4(%ecx)				// emins[1]
+	flds	pl_normal+8(%edx)
+	fxch	%st(2)
+	fmuls	4(%ebx)				// emaxs[1]
+	fxch	%st(2)
+	fld		%st(0)
+	fmuls	8(%ecx)				// emins[2]
+	fxch	%st(5)
+	faddp	%st(0),%st(3)
+	fmuls	8(%ebx)				// emaxs[2]
+	fxch	%st(1)
+	faddp	%st(0),%st(3)
+	fxch	%st(3)
+	faddp	%st(0),%st(2)
+
+LSetSides:
+
+//	sides = 0;
+//	if (dist1 >= p->dist)
+//		sides = 1;
+//	if (dist2 < p->dist)
+//		sides |= 2;
+
+	faddp	%st(0),%st(2)		// dist1 | dist2
+	fcomps	pl_dist(%edx)
+	xorl	%ecx,%ecx
+	fnstsw	%ax
+	fcomps	pl_dist(%edx)
+	andb	$1,%ah
+	xorb	$1,%ah
+	addb	%ah,%cl
+
+	fnstsw	%ax
+	andb	$1,%ah
+	addb	%ah,%ah
+	addb	%ah,%cl
+
+//	return sides;
+
+	popl	%ebx
+	movl	%ecx,%eax	// return status
+
+	ret
+
+
+Lerror:
+	call	C(BOPS_Error)
+
+#endif	// id386
diff -ruN WinQuake/math.s sdlquake-1.0.9/math.s
--- WinQuake/math.s	Tue Dec 21 15:53:24 1999
+++ sdlquake-1.0.9/math.s	Wed Dec 31 16:00:00 1969
@@ -1,418 +0,0 @@
-/*
-Copyright (C) 1996-1997 Id Software, Inc.
-
-This program is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License
-as published by the Free Software Foundation; either version 2
-of the License, or (at your option) any later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
-
-See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-*/
-//
-// math.s
-// x86 assembly-language math routines.
-
-#define GLQUAKE	1	// don't include unneeded defs
-#include "asm_i386.h"
-#include "quakeasm.h"
-
-
-#if	id386
-
-	.data
-
-	.align	4
-Ljmptab:	.long	Lcase0, Lcase1, Lcase2, Lcase3
-			.long	Lcase4, Lcase5, Lcase6, Lcase7
-
-	.text
-
-// TODO: rounding needed?
-// stack parameter offset
-#define	val	4
-
-.globl C(Invert24To16)
-C(Invert24To16):
-
-	movl	val(%esp),%ecx
-	movl	$0x100,%edx		// 0x10000000000 as dividend
-	cmpl	%edx,%ecx
-	jle		LOutOfRange
-
-	subl	%eax,%eax
-	divl	%ecx
-
-	ret
-
-LOutOfRange:
-	movl	$0xFFFFFFFF,%eax
-	ret
-
-#define	in	4
-#define out	8
-
-	.align 2
-.globl C(TransformVector)
-C(TransformVector):
-	movl	in(%esp),%eax
-	movl	out(%esp),%edx
-
-	flds	(%eax)		// in[0]
-	fmuls	C(vright)		// in[0]*vright[0]
-	flds	(%eax)		// in[0] | in[0]*vright[0]
-	fmuls	C(vup)		// in[0]*vup[0] | in[0]*vright[0]
-	flds	(%eax)		// in[0] | in[0]*vup[0] | in[0]*vright[0]
-	fmuls	C(vpn)		// in[0]*vpn[0] | in[0]*vup[0] | in[0]*vright[0]
-
-	flds	4(%eax)		// in[1] | ...
-	fmuls	C(vright)+4	// in[1]*vright[1] | ...
-	flds	4(%eax)		// in[1] | in[1]*vright[1] | ...
-	fmuls	C(vup)+4		// in[1]*vup[1] | in[1]*vright[1] | ...
-	flds	4(%eax)		// in[1] | in[1]*vup[1] | in[1]*vright[1] | ...
-	fmuls	C(vpn)+4		// in[1]*vpn[1] | in[1]*vup[1] | in[1]*vright[1] | ...
-	fxch	%st(2)		// in[1]*vright[1] | in[1]*vup[1] | in[1]*vpn[1] | ...
-
-	faddp	%st(0),%st(5)	// in[1]*vup[1] | in[1]*vpn[1] | ...
-	faddp	%st(0),%st(3)	// in[1]*vpn[1] | ...
-	faddp	%st(0),%st(1)	// vpn_accum | vup_accum | vright_accum
-
-	flds	8(%eax)		// in[2] | ...
-	fmuls	C(vright)+8	// in[2]*vright[2] | ...
-	flds	8(%eax)		// in[2] | in[2]*vright[2] | ...
-	fmuls	C(vup)+8		// in[2]*vup[2] | in[2]*vright[2] | ...
-	flds	8(%eax)		// in[2] | in[2]*vup[2] | in[2]*vright[2] | ...
-	fmuls	C(vpn)+8		// in[2]*vpn[2] | in[2]*vup[2] | in[2]*vright[2] | ...
-	fxch	%st(2)		// in[2]*vright[2] | in[2]*vup[2] | in[2]*vpn[2] | ...
-
-	faddp	%st(0),%st(5)	// in[2]*vup[2] | in[2]*vpn[2] | ...
-	faddp	%st(0),%st(3)	// in[2]*vpn[2] | ...
-	faddp	%st(0),%st(1)	// vpn_accum | vup_accum | vright_accum
-
-	fstps	8(%edx)		// out[2]
-	fstps	4(%edx)		// out[1]
-	fstps	(%edx)		// out[0]
-
-	ret
-
-
-#define EMINS	4+4
-#define EMAXS	4+8
-#define P		4+12
-
-	.align 2
-.globl C(BoxOnPlaneSide)
-C(BoxOnPlaneSide):
-	pushl	%ebx
-
-	movl	P(%esp),%edx
-	movl	EMINS(%esp),%ecx
-	xorl	%eax,%eax
-	movl	EMAXS(%esp),%ebx
-	movb	pl_signbits(%edx),%al
-	cmpb	$8,%al
-	jge		Lerror
-	flds	pl_normal(%edx)		// p->normal[0]
-	fld		%st(0)				// p->normal[0] | p->normal[0]
-	jmp		Ljmptab(,%eax,4)
-
-
-//dist1= p->normal[0]*emaxs[0] + p->normal[1]*emaxs[1] + p->normal[2]*emaxs[2];
-//dist2= p->normal[0]*emins[0] + p->normal[1]*emins[1] + p->normal[2]*emins[2];
-Lcase0:
-	fmuls	(%ebx)				// p->normal[0]*emaxs[0] | p->normal[0]
-	flds	pl_normal+4(%edx)	// p->normal[1] | p->normal[0]*emaxs[0] |
-								//  p->normal[0]
-	fxch	%st(2)				// p->normal[0] | p->normal[0]*emaxs[0] |
-								//  p->normal[1]
-	fmuls	(%ecx)				// p->normal[0]*emins[0] |
-								//  p->normal[0]*emaxs[0] | p->normal[1]
-	fxch	%st(2)				// p->normal[1] | p->normal[0]*emaxs[0] |
-								//  p->normal[0]*emins[0]
-	fld		%st(0)				// p->normal[1] | p->normal[1] |
-								//  p->normal[0]*emaxs[0] |
-								//  p->normal[0]*emins[0]
-	fmuls	4(%ebx)				// p->normal[1]*emaxs[1] | p->normal[1] |
-								//  p->normal[0]*emaxs[0] |
-								//  p->normal[0]*emins[0]
-	flds	pl_normal+8(%edx)	// p->normal[2] | p->normal[1]*emaxs[1] |
-								//  p->normal[1] | p->normal[0]*emaxs[0] |
-								//  p->normal[0]*emins[0]
-	fxch	%st(2)				// p->normal[1] | p->normal[1]*emaxs[1] |
-								//  p->normal[2] | p->normal[0]*emaxs[0] |
-								//  p->normal[0]*emins[0]
-	fmuls	4(%ecx)				// p->normal[1]*emins[1] |
-								//  p->normal[1]*emaxs[1] |
-								//  p->normal[2] | p->normal[0]*emaxs[0] |
-								//  p->normal[0]*emins[0]
-	fxch	%st(2)				// p->normal[2] | p->normal[1]*emaxs[1] |
-								//  p->normal[1]*emins[1] |
-								//  p->normal[0]*emaxs[0] |
-								//  p->normal[0]*emins[0]
-	fld		%st(0)				// p->normal[2] | p->normal[2] |
-								//  p->normal[1]*emaxs[1] |
-								//  p->normal[1]*emins[1] |
-								//  p->normal[0]*emaxs[0] |
-								//  p->normal[0]*emins[0]
-	fmuls	8(%ebx)				// p->normal[2]*emaxs[2] |
-								//  p->normal[2] |
-								//  p->normal[1]*emaxs[1] |
-								//  p->normal[1]*emins[1] |
-								//  p->normal[0]*emaxs[0] |
-								//  p->normal[0]*emins[0]
-	fxch	%st(5)				// p->normal[0]*emins[0] |
-								//  p->normal[2] |
-								//  p->normal[1]*emaxs[1] |
-								//  p->normal[1]*emins[1] |
-								//  p->normal[0]*emaxs[0] |
-								//  p->normal[2]*emaxs[2]
-	faddp	%st(0),%st(3)		//p->normal[2] |
-								// p->normal[1]*emaxs[1] |
-								// p->normal[1]*emins[1]+p->normal[0]*emins[0]|
-								// p->normal[0]*emaxs[0] |
-								// p->normal[2]*emaxs[2]
-	fmuls	8(%ecx)				//p->normal[2]*emins[2] |
-								// p->normal[1]*emaxs[1] |
-								// p->normal[1]*emins[1]+p->normal[0]*emins[0]|
-								// p->normal[0]*emaxs[0] |
-								// p->normal[2]*emaxs[2]
-	fxch	%st(1)				//p->normal[1]*emaxs[1] |
-								// p->normal[2]*emins[2] |
-								// p->normal[1]*emins[1]+p->normal[0]*emins[0]|
-								// p->normal[0]*emaxs[0] |
-								// p->normal[2]*emaxs[2]
-	faddp	%st(0),%st(3)		//p->normal[2]*emins[2] |
-								// p->normal[1]*emins[1]+p->normal[0]*emins[0]|
-								// p->normal[0]*emaxs[0]+p->normal[1]*emaxs[1]|
-								// p->normal[2]*emaxs[2]
-	fxch	%st(3)				//p->normal[2]*emaxs[2] +
-								// p->normal[1]*emins[1]+p->normal[0]*emins[0]|
-								// p->normal[0]*emaxs[0]+p->normal[1]*emaxs[1]|
-								// p->normal[2]*emins[2]
-	faddp	%st(0),%st(2)		//p->normal[1]*emins[1]+p->normal[0]*emins[0]|
-								// dist1 | p->normal[2]*emins[2]
-
-	jmp		LSetSides
-
-//dist1= p->normal[0]*emins[0] + p->normal[1]*emaxs[1] + p->normal[2]*emaxs[2];
-//dist2= p->normal[0]*emaxs[0] + p->normal[1]*emins[1] + p->normal[2]*emins[2];
-Lcase1:
-	fmuls	(%ecx)				// emins[0]
-	flds	pl_normal+4(%edx)
-	fxch	%st(2)
-	fmuls	(%ebx)				// emaxs[0]
-	fxch	%st(2)
-	fld		%st(0)
-	fmuls	4(%ebx)				// emaxs[1]
-	flds	pl_normal+8(%edx)
-	fxch	%st(2)
-	fmuls	4(%ecx)				// emins[1]
-	fxch	%st(2)
-	fld		%st(0)
-	fmuls	8(%ebx)				// emaxs[2]
-	fxch	%st(5)
-	faddp	%st(0),%st(3)
-	fmuls	8(%ecx)				// emins[2]
-	fxch	%st(1)
-	faddp	%st(0),%st(3)
-	fxch	%st(3)
-	faddp	%st(0),%st(2)
-
-	jmp		LSetSides
-
-//dist1= p->normal[0]*emaxs[0] + p->normal[1]*emins[1] + p->normal[2]*emaxs[2];
-//dist2= p->normal[0]*emins[0] + p->normal[1]*emaxs[1] + p->normal[2]*emins[2];
-Lcase2:
-	fmuls	(%ebx)				// emaxs[0]
-	flds	pl_normal+4(%edx)
-	fxch	%st(2)
-	fmuls	(%ecx)				// emins[0]
-	fxch	%st(2)
-	fld		%st(0)
-	fmuls	4(%ecx)				// emins[1]
-	flds	pl_normal+8(%edx)
-	fxch	%st(2)
-	fmuls	4(%ebx)				// emaxs[1]
-	fxch	%st(2)
-	fld		%st(0)
-	fmuls	8(%ebx)				// emaxs[2]
-	fxch	%st(5)
-	faddp	%st(0),%st(3)
-	fmuls	8(%ecx)				// emins[2]
-	fxch	%st(1)
-	faddp	%st(0),%st(3)
-	fxch	%st(3)
-	faddp	%st(0),%st(2)
-
-	jmp		LSetSides
-
-//dist1= p->normal[0]*emins[0] + p->normal[1]*emins[1] + p->normal[2]*emaxs[2];
-//dist2= p->normal[0]*emaxs[0] + p->normal[1]*emaxs[1] + p->normal[2]*emins[2];
-Lcase3:
-	fmuls	(%ecx)				// emins[0]
-	flds	pl_normal+4(%edx)
-	fxch	%st(2)
-	fmuls	(%ebx)				// emaxs[0]
-	fxch	%st(2)
-	fld		%st(0)
-	fmuls	4(%ecx)				// emins[1]
-	flds	pl_normal+8(%edx)
-	fxch	%st(2)
-	fmuls	4(%ebx)				// emaxs[1]
-	fxch	%st(2)
-	fld		%st(0)
-	fmuls	8(%ebx)				// emaxs[2]
-	fxch	%st(5)
-	faddp	%st(0),%st(3)
-	fmuls	8(%ecx)				// emins[2]
-	fxch	%st(1)
-	faddp	%st(0),%st(3)
-	fxch	%st(3)
-	faddp	%st(0),%st(2)
-
-	jmp		LSetSides
-
-//dist1= p->normal[0]*emaxs[0] + p->normal[1]*emaxs[1] + p->normal[2]*emins[2];
-//dist2= p->normal[0]*emins[0] + p->normal[1]*emins[1] + p->normal[2]*emaxs[2];
-Lcase4:
-	fmuls	(%ebx)				// emaxs[0]
-	flds	pl_normal+4(%edx)
-	fxch	%st(2)
-	fmuls	(%ecx)				// emins[0]
-	fxch	%st(2)
-	fld		%st(0)
-	fmuls	4(%ebx)				// emaxs[1]
-	flds	pl_normal+8(%edx)
-	fxch	%st(2)
-	fmuls	4(%ecx)				// emins[1]
-	fxch	%st(2)
-	fld		%st(0)
-	fmuls	8(%ecx)				// emins[2]
-	fxch	%st(5)
-	faddp	%st(0),%st(3)
-	fmuls	8(%ebx)				// emaxs[2]
-	fxch	%st(1)
-	faddp	%st(0),%st(3)
-	fxch	%st(3)
-	faddp	%st(0),%st(2)
-
-	jmp		LSetSides
-
-//dist1= p->normal[0]*emins[0] + p->normal[1]*emaxs[1] + p->normal[2]*emins[2];
-//dist2= p->normal[0]*emaxs[0] + p->normal[1]*emins[1] + p->normal[2]*emaxs[2];
-Lcase5:
-	fmuls	(%ecx)				// emins[0]
-	flds	pl_normal+4(%edx)
-	fxch	%st(2)
-	fmuls	(%ebx)				// emaxs[0]
-	fxch	%st(2)
-	fld		%st(0)
-	fmuls	4(%ebx)				// emaxs[1]
-	flds	pl_normal+8(%edx)
-	fxch	%st(2)
-	fmuls	4(%ecx)				// emins[1]
-	fxch	%st(2)
-	fld		%st(0)
-	fmuls	8(%ecx)				// emins[2]
-	fxch	%st(5)
-	faddp	%st(0),%st(3)
-	fmuls	8(%ebx)				// emaxs[2]
-	fxch	%st(1)
-	faddp	%st(0),%st(3)
-	fxch	%st(3)
-	faddp	%st(0),%st(2)
-
-	jmp		LSetSides
-
-//dist1= p->normal[0]*emaxs[0] + p->normal[1]*emins[1] + p->normal[2]*emins[2];
-//dist2= p->normal[0]*emins[0] + p->normal[1]*emaxs[1] + p->normal[2]*emaxs[2];
-Lcase6:
-	fmuls	(%ebx)				// emaxs[0]
-	flds	pl_normal+4(%edx)
-	fxch	%st(2)
-	fmuls	(%ecx)				// emins[0]
-	fxch	%st(2)
-	fld		%st(0)
-	fmuls	4(%ecx)				// emins[1]
-	flds	pl_normal+8(%edx)
-	fxch	%st(2)
-	fmuls	4(%ebx)				// emaxs[1]
-	fxch	%st(2)
-	fld		%st(0)
-	fmuls	8(%ecx)				// emins[2]
-	fxch	%st(5)
-	faddp	%st(0),%st(3)
-	fmuls	8(%ebx)				// emaxs[2]
-	fxch	%st(1)
-	faddp	%st(0),%st(3)
-	fxch	%st(3)
-	faddp	%st(0),%st(2)
-
-	jmp		LSetSides
-
-//dist1= p->normal[0]*emins[0] + p->normal[1]*emins[1] + p->normal[2]*emins[2];
-//dist2= p->normal[0]*emaxs[0] + p->normal[1]*emaxs[1] + p->normal[2]*emaxs[2];
-Lcase7:
-	fmuls	(%ecx)				// emins[0]
-	flds	pl_normal+4(%edx)
-	fxch	%st(2)
-	fmuls	(%ebx)				// emaxs[0]
-	fxch	%st(2)
-	fld		%st(0)
-	fmuls	4(%ecx)				// emins[1]
-	flds	pl_normal+8(%edx)
-	fxch	%st(2)
-	fmuls	4(%ebx)				// emaxs[1]
-	fxch	%st(2)
-	fld		%st(0)
-	fmuls	8(%ecx)				// emins[2]
-	fxch	%st(5)
-	faddp	%st(0),%st(3)
-	fmuls	8(%ebx)				// emaxs[2]
-	fxch	%st(1)
-	faddp	%st(0),%st(3)
-	fxch	%st(3)
-	faddp	%st(0),%st(2)
-
-LSetSides:
-
-//	sides = 0;
-//	if (dist1 >= p->dist)
-//		sides = 1;
-//	if (dist2 < p->dist)
-//		sides |= 2;
-
-	faddp	%st(0),%st(2)		// dist1 | dist2
-	fcomps	pl_dist(%edx)
-	xorl	%ecx,%ecx
-	fnstsw	%ax
-	fcomps	pl_dist(%edx)
-	andb	$1,%ah
-	xorb	$1,%ah
-	addb	%ah,%cl
-
-	fnstsw	%ax
-	andb	$1,%ah
-	addb	%ah,%ah
-	addb	%ah,%cl
-
-//	return sides;
-
-	popl	%ebx
-	movl	%ecx,%eax	// return status
-
-	ret
-
-
-Lerror:
-	call	C(BOPS_Error)
-
-#endif	// id386
diff -ruN WinQuake/missing sdlquake-1.0.9/missing
--- WinQuake/missing	Wed Dec 31 16:00:00 1969
+++ sdlquake-1.0.9/missing	Sat Dec 25 03:38:02 1999
@@ -0,0 +1,190 @@
+#! /bin/sh
+# Common stub for a few missing GNU programs while installing.
+# Copyright (C) 1996, 1997 Free Software Foundation, Inc.
+# Franc,ois Pinard <pinard@iro.umontreal.ca>, 1996.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+# 02111-1307, USA.
+
+if test $# -eq 0; then
+  echo 1>&2 "Try \`$0 --help' for more information"
+  exit 1
+fi
+
+case "$1" in
+
+  -h|--h|--he|--hel|--help)
+    echo "\
+$0 [OPTION]... PROGRAM [ARGUMENT]...
+
+Handle \`PROGRAM [ARGUMENT]...' for when PROGRAM is missing, or return an
+error status if there is no known handling for PROGRAM.
+
+Options:
+  -h, --help      display this help and exit
+  -v, --version   output version information and exit
+
+Supported PROGRAM values:
+  aclocal      touch file \`aclocal.m4'
+  autoconf     touch file \`configure'
+  autoheader   touch file \`config.h.in'
+  automake     touch all \`Makefile.in' files
+  bison        create \`y.tab.[ch]', if possible, from existing .[ch]
+  flex         create \`lex.yy.c', if possible, from existing .c
+  lex          create \`lex.yy.c', if possible, from existing .c
+  makeinfo     touch the output file
+  yacc         create \`y.tab.[ch]', if possible, from existing .[ch]"
+    ;;
+
+  -v|--v|--ve|--ver|--vers|--versi|--versio|--version)
+    echo "missing - GNU libit 0.0"
+    ;;
+
+  -*)
+    echo 1>&2 "$0: Unknown \`$1' option"
+    echo 1>&2 "Try \`$0 --help' for more information"
+    exit 1
+    ;;
+
+  aclocal)
+    echo 1>&2 "\
+WARNING: \`$1' is missing on your system.  You should only need it if
+         you modified \`acinclude.m4' or \`configure.in'.  You might want
+         to install the \`Automake' and \`Perl' packages.  Grab them from
+         any GNU archive site."
+    touch aclocal.m4
+    ;;
+
+  autoconf)
+    echo 1>&2 "\
+WARNING: \`$1' is missing on your system.  You should only need it if
+         you modified \`configure.in'.  You might want to install the
+         \`Autoconf' and \`GNU m4' packages.  Grab them from any GNU
+         archive site."
+    touch configure
+    ;;
+
+  autoheader)
+    echo 1>&2 "\
+WARNING: \`$1' is missing on your system.  You should only need it if
+         you modified \`acconfig.h' or \`configure.in'.  You might want
+         to install the \`Autoconf' and \`GNU m4' packages.  Grab them
+         from any GNU archive site."
+    files=`sed -n 's/^[ ]*A[CM]_CONFIG_HEADER(\([^)]*\)).*/\1/p' configure.in`
+    test -z "$files" && files="config.h"
+    touch_files=
+    for f in $files; do
+      case "$f" in
+      *:*) touch_files="$touch_files "`echo "$f" |
+				       sed -e 's/^[^:]*://' -e 's/:.*//'`;;
+      *) touch_files="$touch_files $f.in";;
+      esac
+    done
+    touch $touch_files
+    ;;
+
+  automake)
+    echo 1>&2 "\
+WARNING: \`$1' is missing on your system.  You should only need it if
+         you modified \`Makefile.am', \`acinclude.m4' or \`configure.in'.
+         You might want to install the \`Automake' and \`Perl' packages.
+         Grab them from any GNU archive site."
+    find . -type f -name Makefile.am -print |
+	   sed 's/\.am$/.in/' |
+	   while read f; do touch "$f"; done
+    ;;
+
+  bison|yacc)
+    echo 1>&2 "\
+WARNING: \`$1' is missing on your system.  You should only need it if
+         you modified a \`.y' file.  You may need the \`Bison' package
+         in order for those modifications to take effect.  You can get
+         \`Bison' from any GNU archive site."
+    rm -f y.tab.c y.tab.h
+    if [ $# -ne 1 ]; then
+        eval LASTARG="\${$#}"
+	case "$LASTARG" in
+	*.y)
+	    SRCFILE=`echo "$LASTARG" | sed 's/y$/c/'`
+	    if [ -f "$SRCFILE" ]; then
+	         cp "$SRCFILE" y.tab.c
+	    fi
+	    SRCFILE=`echo "$LASTARG" | sed 's/y$/h/'`
+	    if [ -f "$SRCFILE" ]; then
+	         cp "$SRCFILE" y.tab.h
+	    fi
+	  ;;
+	esac
+    fi
+    if [ ! -f y.tab.h ]; then
+	echo >y.tab.h
+    fi
+    if [ ! -f y.tab.c ]; then
+	echo 'main() { return 0; }' >y.tab.c
+    fi
+    ;;
+
+  lex|flex)
+    echo 1>&2 "\
+WARNING: \`$1' is missing on your system.  You should only need it if
+         you modified a \`.l' file.  You may need the \`Flex' package
+         in order for those modifications to take effect.  You can get
+         \`Flex' from any GNU archive site."
+    rm -f lex.yy.c
+    if [ $# -ne 1 ]; then
+        eval LASTARG="\${$#}"
+	case "$LASTARG" in
+	*.l)
+	    SRCFILE=`echo "$LASTARG" | sed 's/l$/c/'`
+	    if [ -f "$SRCFILE" ]; then
+	         cp "$SRCFILE" lex.yy.c
+	    fi
+	  ;;
+	esac
+    fi
+    if [ ! -f lex.yy.c ]; then
+	echo 'main() { return 0; }' >lex.yy.c
+    fi
+    ;;
+
+  makeinfo)
+    echo 1>&2 "\
+WARNING: \`$1' is missing on your system.  You should only need it if
+         you modified a \`.texi' or \`.texinfo' file, or any other file
+         indirectly affecting the aspect of the manual.  The spurious
+         call might also be the consequence of using a buggy \`make' (AIX,
+         DU, IRIX).  You might want to install the \`Texinfo' package or
+         the \`GNU make' package.  Grab either from any GNU archive site."
+    file=`echo "$*" | sed -n 's/.*-o \([^ ]*\).*/\1/p'`
+    if test -z "$file"; then
+      file=`echo "$*" | sed 's/.* \([^ ]*\) *$/\1/'`
+      file=`sed -n '/^@setfilename/ { s/.* \([^ ]*\) *$/\1/; p; q; }' $file`
+    fi
+    touch $file
+    ;;
+
+  *)
+    echo 1>&2 "\
+WARNING: \`$1' is needed, and you do not seem to have it handy on your
+         system.  You might have modified some files without having the
+         proper tools for further handling them.  Check the \`README' file,
+         it often tells you about the needed prerequirements for installing
+         this package.  You may also peek at any GNU archive site, in case
+         some other package would contain this missing \`$1' program."
+    exit 1
+    ;;
+esac
+
+exit 0
diff -ruN WinQuake/mkinstalldirs sdlquake-1.0.9/mkinstalldirs
--- WinQuake/mkinstalldirs	Wed Dec 31 16:00:00 1969
+++ sdlquake-1.0.9/mkinstalldirs	Sat Dec 25 03:38:03 1999
@@ -0,0 +1,40 @@
+#! /bin/sh
+# mkinstalldirs --- make directory hierarchy
+# Author: Noah Friedman <friedman@prep.ai.mit.edu>
+# Created: 1993-05-16
+# Public domain
+
+# $Id: mkinstalldirs,v 1.13 1999/01/05 03:18:55 bje Exp $
+
+errstatus=0
+
+for file
+do
+   set fnord `echo ":$file" | sed -ne 's/^:\//#/;s/^://;s/\// /g;s/^#/\//;p'`
+   shift
+
+   pathcomp=
+   for d
+   do
+     pathcomp="$pathcomp$d"
+     case "$pathcomp" in
+       -* ) pathcomp=./$pathcomp ;;
+     esac
+
+     if test ! -d "$pathcomp"; then
+        echo "mkdir $pathcomp"
+
+        mkdir "$pathcomp" || lasterr=$?
+
+        if test ! -d "$pathcomp"; then
+  	  errstatus=$lasterr
+        fi
+     fi
+
+     pathcomp="$pathcomp/"
+   done
+done
+
+exit $errstatus
+
+# mkinstalldirs ends here
diff -ruN WinQuake/net_udp.c sdlquake-1.0.9/net_udp.c
--- WinQuake/net_udp.c	Tue Dec 21 18:40:46 1999
+++ sdlquake-1.0.9/net_udp.c	Sat Dec 25 03:38:03 1999
@@ -134,9 +134,10 @@
 	if ((newsocket = socket (PF_INET, SOCK_DGRAM, IPPROTO_UDP)) == -1)
 		return -1;
 
+#if 0
 	if (ioctl (newsocket, FIONBIO, (char *)&_true) == -1)
 		goto ErrorReturn;
-
+#endif
 	address.sin_family = AF_INET;
 	address.sin_addr.s_addr = INADDR_ANY;
 	address.sin_port = htons(port);
diff -ruN WinQuake/quakeasm.h sdlquake-1.0.9/quakeasm.h
--- WinQuake/quakeasm.h	Tue Dec 21 18:42:28 1999
+++ sdlquake-1.0.9/quakeasm.h	Tue Dec 28 10:44:04 1999
@@ -31,7 +31,7 @@
 
 #endif
 
-#ifdef __i386__
+#if defined(__i386__) && defined(USE_ASM)
 #define id386	1
 #else
 #define id386	0
diff -ruN WinQuake/quakedef.h sdlquake-1.0.9/quakedef.h
--- WinQuake/quakedef.h	Tue Dec 21 15:54:20 1999
+++ sdlquake-1.0.9/quakedef.h	Tue Dec 28 11:02:27 1999
@@ -23,6 +23,7 @@
 
 #define	QUAKE_GAME			// as opposed to utilities
 
+#undef VERSION
 #define	VERSION				1.09
 #define	GLQUAKE_VERSION		1.00
 #define	D3DQUAKE_VERSION	0.01
@@ -61,7 +62,7 @@
 
 #endif
 
-#if defined __i386__ // && !defined __sun__
+#if defined(__i386__) && defined(USE_ASM)
 #define id386	1
 #else
 #define id386	0
diff -ruN WinQuake/r_aclipa.S sdlquake-1.0.9/r_aclipa.S
--- WinQuake/r_aclipa.S	Wed Dec 31 16:00:00 1969
+++ sdlquake-1.0.9/r_aclipa.S	Sat Dec 25 03:38:03 1999
@@ -0,0 +1,216 @@
+/*
+Copyright (C) 1996-1997 Id Software, Inc.
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation; either version 2
+of the License, or (at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
+
+See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+//
+// r_aliasa.s
+// x86 assembly-language Alias model transform and project code.
+//
+
+#include "asm_i386.h"
+#include "quakeasm.h"
+#include "asm_draw.h"
+#include "d_ifacea.h"
+
+#if id386
+
+	.data
+Ltemp0:	.long	0
+Ltemp1:	.long	0
+
+	.text
+
+#define pfv0		8+4
+#define pfv1		8+8
+#define out			8+12
+
+.globl C(R_Alias_clip_bottom)
+C(R_Alias_clip_bottom):
+	pushl	%esi
+	pushl	%edi
+
+	movl	pfv0(%esp),%esi
+	movl	pfv1(%esp),%edi
+
+	movl	C(r_refdef)+rd_aliasvrectbottom,%eax
+
+LDoForwardOrBackward:
+
+	movl	fv_v+4(%esi),%edx
+	movl	fv_v+4(%edi),%ecx
+
+	cmpl	%ecx,%edx
+	jl		LDoForward
+
+	movl	fv_v+4(%esi),%ecx
+	movl	fv_v+4(%edi),%edx
+	movl	pfv0(%esp),%edi
+	movl	pfv1(%esp),%esi
+
+LDoForward:
+
+	subl	%edx,%ecx
+	subl	%edx,%eax
+	movl	%ecx,Ltemp1
+	movl	%eax,Ltemp0
+	fildl	Ltemp1
+	fildl	Ltemp0
+	movl	out(%esp),%edx
+	movl	$2,%eax
+
+	fdivp	%st(0),%st(1)					// scale
+
+LDo3Forward:
+	fildl	fv_v+0(%esi)	// fv0v0 | scale
+	fildl	fv_v+0(%edi)	// fv1v0 | fv0v0 | scale
+	fildl	fv_v+4(%esi)	// fv0v1 | fv1v0 | fv0v0 | scale
+	fildl	fv_v+4(%edi)	// fv1v1 | fv0v1 | fv1v0 | fv0v0 | scale
+	fildl	fv_v+8(%esi)	// fv0v2 | fv1v1 | fv0v1 | fv1v0 | fv0v0 | scale
+	fildl	fv_v+8(%edi)	// fv1v2 | fv0v2 | fv1v1 | fv0v1 | fv1v0 | fv0v0 |
+							//  scale
+	fxch	%st(5)			// fv0v0 | fv0v2 | fv1v1 | fv0v1 | fv1v0 | fv1v2 |
+							//  scale
+	fsubr	%st(0),%st(4)	// fv0v0 | fv0v2 | fv1v1 | fv0v1 | fv1v0-fv0v0 |
+							//  fv1v2 | scale
+	fxch	%st(3)			// fv0v1 | fv0v2 | fv1v1 | fv0v0 | fv1v0-fv0v0 |
+							//  fv1v2 | scale
+	fsubr	%st(0),%st(2)	// fv0v1 | fv0v2 | fv1v1-fv0v1 | fv0v0 |
+							//  fv1v0-fv0v0 | fv1v2 | scale
+	fxch	%st(1)			// fv0v2 | fv0v1 | fv1v1-fv0v1 | fv0v0 |
+							//  fv1v0-fv0v0 | fv1v2 | scale
+	fsubr	%st(0),%st(5)	// fv0v2 | fv0v1 | fv1v1-fv0v1 | fv0v0 |
+							//  fv1v0-fv0v0 | fv1v2-fv0v2 | scale
+	fxch	%st(6)			// scale | fv0v1 | fv1v1-fv0v1 | fv0v0 |
+							//  fv1v0-fv0v0 | fv1v2-fv0v2 | fv0v2
+	fmul	%st(0),%st(4)	// scale | fv0v1 | fv1v1-fv0v1 | fv0v0 |
+							//  (fv1v0-fv0v0)*scale | fv1v2-fv0v2 | fv0v2
+	addl	$12,%edi
+	fmul	%st(0),%st(2)	// scale | fv0v1 | (fv1v1-fv0v1)*scale | fv0v0 |
+							//  (fv1v0-fv0v0)*scale | fv1v2-fv0v2 | fv0v2
+	addl	$12,%esi
+	addl	$12,%edx
+	fmul	%st(0),%st(5)	// scale | fv0v1 | (fv1v1-fv0v1)*scale | fv0v0 |
+							//  (fv1v0-fv0v0)*scale | (fv1v2-fv0v2)*scale |
+							//  fv0v2
+	fxch	%st(3)			// fv0v0 | fv0v1 | (fv1v1-fv0v1)*scale | scale |
+							//  (fv1v0-fv0v0)*scale | (fv1v2-fv0v2)*scale |
+							//  fv0v2
+	faddp	%st(0),%st(4)	// fv0v1 | (fv1v1-fv0v1)*scale | scale |
+							//  fv0v0+(fv1v0-fv0v0)*scale |
+							//  (fv1v2-fv0v2)*scale | fv0v2
+	faddp	%st(0),%st(1)	// fv0v1+(fv1v1-fv0v1)*scale | scale |
+							//  fv0v0+(fv1v0-fv0v0)*scale |
+							//  (fv1v2-fv0v2)*scale | fv0v2
+	fxch	%st(4)			// fv0v2 | scale | fv0v0+(fv1v0-fv0v0)*scale |
+							//  (fv1v2-fv0v2)*scale | fv0v1+(fv1v1-fv0v1)*scale
+	faddp	%st(0),%st(3)	// scale | fv0v0+(fv1v0-fv0v0)*scale |
+							//  fv0v2+(fv1v2-fv0v2)*scale |
+							//  fv0v1+(fv1v1-fv0v1)*scale
+	fxch	%st(1)			// fv0v0+(fv1v0-fv0v0)*scale | scale | 
+							//  fv0v2+(fv1v2-fv0v2)*scale |
+							//  fv0v1+(fv1v1-fv0v1)*scale
+	fadds	float_point5
+	fxch	%st(3)			// fv0v1+(fv1v1-fv0v1)*scale | scale | 
+							//  fv0v2+(fv1v2-fv0v2)*scale |
+							//  fv0v0+(fv1v0-fv0v0)*scale
+	fadds	float_point5
+	fxch	%st(2)			// fv0v2+(fv1v2-fv0v2)*scale | scale | 
+							//  fv0v1+(fv1v1-fv0v1)*scale |
+							//  fv0v0+(fv1v0-fv0v0)*scale
+	fadds	float_point5
+	fxch	%st(3)			// fv0v0+(fv1v0-fv0v0)*scale | scale | 
+							//  fv0v1+(fv1v1-fv0v1)*scale |
+							//  fv0v2+(fv1v2-fv0v2)*scale
+	fistpl	fv_v+0-12(%edx)	// scale | fv0v1+(fv1v1-fv0v1)*scale |
+							//  fv0v2+(fv1v2-fv0v2)*scale
+	fxch	%st(1)			// fv0v1+(fv1v1-fv0v1)*scale | scale |
+							//  fv0v2+(fv1v2-fv0v2)*scale | scale
+	fistpl	fv_v+4-12(%edx)	// scale | fv0v2+(fv1v2-fv0v2)*scale
+	fxch	%st(1)			// fv0v2+(fv1v2-fv0v2)*sc | scale
+	fistpl	fv_v+8-12(%edx)	// scale
+
+	decl	%eax
+	jnz		LDo3Forward
+
+	fstp	%st(0)
+
+	popl	%edi
+	popl	%esi
+
+	ret
+
+
+.globl C(R_Alias_clip_top)
+C(R_Alias_clip_top):
+	pushl	%esi
+	pushl	%edi
+
+	movl	pfv0(%esp),%esi
+	movl	pfv1(%esp),%edi
+
+	movl	C(r_refdef)+rd_aliasvrect+4,%eax
+	jmp		LDoForwardOrBackward
+
+
+
+.globl C(R_Alias_clip_right)
+C(R_Alias_clip_right):
+	pushl	%esi
+	pushl	%edi
+
+	movl	pfv0(%esp),%esi
+	movl	pfv1(%esp),%edi
+
+	movl	C(r_refdef)+rd_aliasvrectright,%eax
+
+LRightLeftEntry:
+
+
+	movl	fv_v+4(%esi),%edx
+	movl	fv_v+4(%edi),%ecx
+
+	cmpl	%ecx,%edx
+	movl	fv_v+0(%esi),%edx
+
+	movl	fv_v+0(%edi),%ecx
+	jl		LDoForward2
+
+	movl	fv_v+0(%esi),%ecx
+	movl	fv_v+0(%edi),%edx
+	movl	pfv0(%esp),%edi
+	movl	pfv1(%esp),%esi
+
+LDoForward2:
+
+	jmp		LDoForward
+
+
+.globl C(R_Alias_clip_left)
+C(R_Alias_clip_left):
+	pushl	%esi
+	pushl	%edi
+
+	movl	pfv0(%esp),%esi
+	movl	pfv1(%esp),%edi
+
+	movl	C(r_refdef)+rd_aliasvrect+0,%eax
+	jmp		LRightLeftEntry
+
+
+#endif	// id386
+
diff -ruN WinQuake/r_aclipa.s sdlquake-1.0.9/r_aclipa.s
--- WinQuake/r_aclipa.s	Tue Dec 21 15:53:26 1999
+++ sdlquake-1.0.9/r_aclipa.s	Wed Dec 31 16:00:00 1969
@@ -1,216 +0,0 @@
-/*
-Copyright (C) 1996-1997 Id Software, Inc.
-
-This program is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License
-as published by the Free Software Foundation; either version 2
-of the License, or (at your option) any later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
-
-See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-*/
-//
-// r_aliasa.s
-// x86 assembly-language Alias model transform and project code.
-//
-
-#include "asm_i386.h"
-#include "quakeasm.h"
-#include "asm_draw.h"
-#include "d_ifacea.h"
-
-#if id386
-
-	.data
-Ltemp0:	.long	0
-Ltemp1:	.long	0
-
-	.text
-
-#define pfv0		8+4
-#define pfv1		8+8
-#define out			8+12
-
-.globl C(R_Alias_clip_bottom)
-C(R_Alias_clip_bottom):
-	pushl	%esi
-	pushl	%edi
-
-	movl	pfv0(%esp),%esi
-	movl	pfv1(%esp),%edi
-
-	movl	C(r_refdef)+rd_aliasvrectbottom,%eax
-
-LDoForwardOrBackward:
-
-	movl	fv_v+4(%esi),%edx
-	movl	fv_v+4(%edi),%ecx
-
-	cmpl	%ecx,%edx
-	jl		LDoForward
-
-	movl	fv_v+4(%esi),%ecx
-	movl	fv_v+4(%edi),%edx
-	movl	pfv0(%esp),%edi
-	movl	pfv1(%esp),%esi
-
-LDoForward:
-
-	subl	%edx,%ecx
-	subl	%edx,%eax
-	movl	%ecx,Ltemp1
-	movl	%eax,Ltemp0
-	fildl	Ltemp1
-	fildl	Ltemp0
-	movl	out(%esp),%edx
-	movl	$2,%eax
-
-	fdivp	%st(0),%st(1)					// scale
-
-LDo3Forward:
-	fildl	fv_v+0(%esi)	// fv0v0 | scale
-	fildl	fv_v+0(%edi)	// fv1v0 | fv0v0 | scale
-	fildl	fv_v+4(%esi)	// fv0v1 | fv1v0 | fv0v0 | scale
-	fildl	fv_v+4(%edi)	// fv1v1 | fv0v1 | fv1v0 | fv0v0 | scale
-	fildl	fv_v+8(%esi)	// fv0v2 | fv1v1 | fv0v1 | fv1v0 | fv0v0 | scale
-	fildl	fv_v+8(%edi)	// fv1v2 | fv0v2 | fv1v1 | fv0v1 | fv1v0 | fv0v0 |
-							//  scale
-	fxch	%st(5)			// fv0v0 | fv0v2 | fv1v1 | fv0v1 | fv1v0 | fv1v2 |
-							//  scale
-	fsubr	%st(0),%st(4)	// fv0v0 | fv0v2 | fv1v1 | fv0v1 | fv1v0-fv0v0 |
-							//  fv1v2 | scale
-	fxch	%st(3)			// fv0v1 | fv0v2 | fv1v1 | fv0v0 | fv1v0-fv0v0 |
-							//  fv1v2 | scale
-	fsubr	%st(0),%st(2)	// fv0v1 | fv0v2 | fv1v1-fv0v1 | fv0v0 |
-							//  fv1v0-fv0v0 | fv1v2 | scale
-	fxch	%st(1)			// fv0v2 | fv0v1 | fv1v1-fv0v1 | fv0v0 |
-							//  fv1v0-fv0v0 | fv1v2 | scale
-	fsubr	%st(0),%st(5)	// fv0v2 | fv0v1 | fv1v1-fv0v1 | fv0v0 |
-							//  fv1v0-fv0v0 | fv1v2-fv0v2 | scale
-	fxch	%st(6)			// scale | fv0v1 | fv1v1-fv0v1 | fv0v0 |
-							//  fv1v0-fv0v0 | fv1v2-fv0v2 | fv0v2
-	fmul	%st(0),%st(4)	// scale | fv0v1 | fv1v1-fv0v1 | fv0v0 |
-							//  (fv1v0-fv0v0)*scale | fv1v2-fv0v2 | fv0v2
-	addl	$12,%edi
-	fmul	%st(0),%st(2)	// scale | fv0v1 | (fv1v1-fv0v1)*scale | fv0v0 |
-							//  (fv1v0-fv0v0)*scale | fv1v2-fv0v2 | fv0v2
-	addl	$12,%esi
-	addl	$12,%edx
-	fmul	%st(0),%st(5)	// scale | fv0v1 | (fv1v1-fv0v1)*scale | fv0v0 |
-							//  (fv1v0-fv0v0)*scale | (fv1v2-fv0v2)*scale |
-							//  fv0v2
-	fxch	%st(3)			// fv0v0 | fv0v1 | (fv1v1-fv0v1)*scale | scale |
-							//  (fv1v0-fv0v0)*scale | (fv1v2-fv0v2)*scale |
-							//  fv0v2
-	faddp	%st(0),%st(4)	// fv0v1 | (fv1v1-fv0v1)*scale | scale |
-							//  fv0v0+(fv1v0-fv0v0)*scale |
-							//  (fv1v2-fv0v2)*scale | fv0v2
-	faddp	%st(0),%st(1)	// fv0v1+(fv1v1-fv0v1)*scale | scale |
-							//  fv0v0+(fv1v0-fv0v0)*scale |
-							//  (fv1v2-fv0v2)*scale | fv0v2
-	fxch	%st(4)			// fv0v2 | scale | fv0v0+(fv1v0-fv0v0)*scale |
-							//  (fv1v2-fv0v2)*scale | fv0v1+(fv1v1-fv0v1)*scale
-	faddp	%st(0),%st(3)	// scale | fv0v0+(fv1v0-fv0v0)*scale |
-							//  fv0v2+(fv1v2-fv0v2)*scale |
-							//  fv0v1+(fv1v1-fv0v1)*scale
-	fxch	%st(1)			// fv0v0+(fv1v0-fv0v0)*scale | scale | 
-							//  fv0v2+(fv1v2-fv0v2)*scale |
-							//  fv0v1+(fv1v1-fv0v1)*scale
-	fadds	float_point5
-	fxch	%st(3)			// fv0v1+(fv1v1-fv0v1)*scale | scale | 
-							//  fv0v2+(fv1v2-fv0v2)*scale |
-							//  fv0v0+(fv1v0-fv0v0)*scale
-	fadds	float_point5
-	fxch	%st(2)			// fv0v2+(fv1v2-fv0v2)*scale | scale | 
-							//  fv0v1+(fv1v1-fv0v1)*scale |
-							//  fv0v0+(fv1v0-fv0v0)*scale
-	fadds	float_point5
-	fxch	%st(3)			// fv0v0+(fv1v0-fv0v0)*scale | scale | 
-							//  fv0v1+(fv1v1-fv0v1)*scale |
-							//  fv0v2+(fv1v2-fv0v2)*scale
-	fistpl	fv_v+0-12(%edx)	// scale | fv0v1+(fv1v1-fv0v1)*scale |
-							//  fv0v2+(fv1v2-fv0v2)*scale
-	fxch	%st(1)			// fv0v1+(fv1v1-fv0v1)*scale | scale |
-							//  fv0v2+(fv1v2-fv0v2)*scale | scale
-	fistpl	fv_v+4-12(%edx)	// scale | fv0v2+(fv1v2-fv0v2)*scale
-	fxch	%st(1)			// fv0v2+(fv1v2-fv0v2)*sc | scale
-	fistpl	fv_v+8-12(%edx)	// scale
-
-	decl	%eax
-	jnz		LDo3Forward
-
-	fstp	%st(0)
-
-	popl	%edi
-	popl	%esi
-
-	ret
-
-
-.globl C(R_Alias_clip_top)
-C(R_Alias_clip_top):
-	pushl	%esi
-	pushl	%edi
-
-	movl	pfv0(%esp),%esi
-	movl	pfv1(%esp),%edi
-
-	movl	C(r_refdef)+rd_aliasvrect+4,%eax
-	jmp		LDoForwardOrBackward
-
-
-
-.globl C(R_Alias_clip_right)
-C(R_Alias_clip_right):
-	pushl	%esi
-	pushl	%edi
-
-	movl	pfv0(%esp),%esi
-	movl	pfv1(%esp),%edi
-
-	movl	C(r_refdef)+rd_aliasvrectright,%eax
-
-LRightLeftEntry:
-
-
-	movl	fv_v+4(%esi),%edx
-	movl	fv_v+4(%edi),%ecx
-
-	cmpl	%ecx,%edx
-	movl	fv_v+0(%esi),%edx
-
-	movl	fv_v+0(%edi),%ecx
-	jl		LDoForward2
-
-	movl	fv_v+0(%esi),%ecx
-	movl	fv_v+0(%edi),%edx
-	movl	pfv0(%esp),%edi
-	movl	pfv1(%esp),%esi
-
-LDoForward2:
-
-	jmp		LDoForward
-
-
-.globl C(R_Alias_clip_left)
-C(R_Alias_clip_left):
-	pushl	%esi
-	pushl	%edi
-
-	movl	pfv0(%esp),%esi
-	movl	pfv1(%esp),%edi
-
-	movl	C(r_refdef)+rd_aliasvrect+0,%eax
-	jmp		LRightLeftEntry
-
-
-#endif	// id386
-
diff -ruN WinQuake/r_aliasa.S sdlquake-1.0.9/r_aliasa.S
--- WinQuake/r_aliasa.S	Wed Dec 31 16:00:00 1969
+++ sdlquake-1.0.9/r_aliasa.S	Sat Dec 25 03:38:03 1999
@@ -0,0 +1,237 @@
+/*
+Copyright (C) 1996-1997 Id Software, Inc.
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation; either version 2
+of the License, or (at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
+
+See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+//
+// r_aliasa.s
+// x86 assembly-language Alias model transform and project code.
+//
+
+#include "asm_i386.h"
+#include "quakeasm.h"
+#include "asm_draw.h"
+#include "d_ifacea.h"
+
+#if id386
+
+	.data
+
+Lfloat_1:	.single	1.0
+Ltemp:		.long	0
+Lcoords:	.long	0, 0, 0
+
+	.text
+
+#define fv			12+4
+#define pstverts	12+8
+
+.globl C(R_AliasTransformAndProjectFinalVerts)
+C(R_AliasTransformAndProjectFinalVerts):
+	pushl	%ebp				// preserve caller's stack frame
+	pushl	%edi
+	pushl	%esi				// preserve register variables
+
+//	int			i, temp;
+//	float		lightcos, *plightnormal, zi;
+//	trivertx_t	*pverts;
+
+//	pverts = r_apverts;
+	movl	C(r_apverts),%esi
+
+//	for (i=0 ; i<r_anumverts ; i++, fv++, pverts++, pstverts++)
+//	{
+	movl	pstverts(%esp),%ebp
+	movl	fv(%esp),%edi
+	movl	C(r_anumverts),%ecx
+	subl	%edx,%edx
+
+Lloop:
+
+//	// transform and project
+//		zi = 1.0 / (DotProduct(pverts->v, aliastransform[2]) +
+//				aliastransform[2][3]);
+	movb	(%esi),%dl
+	movb	%dl,Lcoords
+	fildl	Lcoords				// v[0]
+	movb	1(%esi),%dl
+	movb	%dl,Lcoords+4
+	fildl	Lcoords+4			// v[1] | v[0]
+	movb	2(%esi),%dl	
+	movb	%dl,Lcoords+8
+	fildl	Lcoords+8			// v[2] | v[1] | v[0]
+
+	fld		%st(2)				// v[0] | v[2] | v[1] | v[0]
+	fmuls	C(aliastransform)+32 // accum | v[2] | v[1] | v[0]
+	fld		%st(2)				// v[1] | accum | v[2] | v[1] | v[0]
+	fmuls	C(aliastransform)+36 // accum2 | accum | v[2] | v[1] | v[0]
+	fxch	%st(1)				// accum | accum2 | v[2] | v[1] | v[0]
+	fadds	C(aliastransform)+44 // accum | accum2 | v[2] | v[1] | v[0]
+	fld		%st(2)				// v[2] | accum | accum2 | v[2] | v[1] | v[0]
+	fmuls	C(aliastransform)+40 // accum3 | accum | accum2 | v[2] | v[1] |
+								 //  v[0]
+	fxch	%st(1)				// accum | accum3 | accum2 | v[2] | v[1] | v[0]
+	faddp	%st(0),%st(2)		// accum3 | accum | v[2] | v[1] | v[0]
+	movb	tv_lightnormalindex(%esi),%dl
+	movl	stv_s(%ebp),%eax
+	movl	%eax,fv_v+8(%edi)
+	faddp	%st(0),%st(1)		// z | v[2] | v[1] | v[0]
+
+	movl	stv_t(%ebp),%eax
+	movl	%eax,fv_v+12(%edi)
+
+//	// lighting
+//		plightnormal = r_avertexnormals[pverts->lightnormalindex];
+
+	fdivrs	Lfloat_1			// zi | v[2] | v[1] | v[0]
+
+//		fv->v[2] = pstverts->s;
+//		fv->v[3] = pstverts->t;
+//		fv->flags = pstverts->onseam;
+	movl	stv_onseam(%ebp),%eax
+	movl	%eax,fv_flags(%edi)
+
+	movl	fv_size(%edi),%eax
+	movl	stv_size(%ebp),%eax
+	movl	4(%esi),%eax
+
+	leal	(%edx,%edx,2),%eax	// index*3
+
+	fxch	%st(3)				// v[0] | v[2] | v[1] | zi
+
+//		lightcos = DotProduct (plightnormal, r_plightvec);
+	flds	C(r_avertexnormals)(,%eax,4)
+	fmuls	C(r_plightvec)
+	flds	C(r_avertexnormals)+4(,%eax,4)
+	fmuls	C(r_plightvec)+4
+	flds	C(r_avertexnormals)+8(,%eax,4)
+	fmuls	C(r_plightvec)+8
+	fxch	%st(1)
+	faddp	%st(0),%st(2)
+	fld		%st(2)				 // v[0] | laccum | laccum2 | v[0] | v[2] |
+								 //  v[1] | zi
+	fmuls	C(aliastransform)+0  // xaccum | laccum | laccum2 | v[0] | v[2] |
+								 //  v[1] | zi
+	fxch	%st(2)				 // laccum2 | laccum | xaccum | v[0] | v[2] |
+								 //  v[1] | zi
+	faddp	%st(0),%st(1)		 // laccum | xaccum | v[0] | v[2] | v[1] | zi
+
+//		temp = r_ambientlight;
+//		if (lightcos < 0)
+//		{
+	fsts	Ltemp
+	movl	C(r_ambientlight),%eax
+	movb	Ltemp+3,%dl
+	testb	$0x80,%dl
+	jz		Lsavelight	// no need to clamp if only ambient lit, because
+						//  r_ambientlight is preclamped
+
+//			temp += (int)(r_shadelight * lightcos);
+	fmuls	C(r_shadelight)
+// FIXME: fast float->int conversion?
+	fistpl	Ltemp
+	addl	Ltemp,%eax
+
+//		// clamp; because we limited the minimum ambient and shading light, we
+//		// don't have to clamp low light, just bright
+//			if (temp < 0)
+//				temp = 0;
+	jns		Lp1
+	subl	%eax,%eax
+
+//		}
+
+Lp1:
+
+//		fv->v[4] = temp;
+//
+//	// x, y, and z are scaled down by 1/2**31 in the transform, so 1/z is
+//	// scaled up by 1/2**31, and the scaling cancels out for x and y in the
+//	// projection
+//		fv->v[0] = ((DotProduct(pverts->v, aliastransform[0]) +
+//				aliastransform[0][3]) * zi) + aliasxcenter;
+//		fv->v[1] = ((DotProduct(pverts->v, aliastransform[1]) +
+//				aliastransform[1][3]) * zi) + aliasycenter;
+//		fv->v[5] = zi;
+	fxch	%st(1)				 // v[0] | xaccum | v[2] | v[1] | zi
+	fmuls	C(aliastransform)+16 // yaccum | xaccum | v[2] | v[1] | zi
+	fxch	%st(3)				 // v[1] | xaccum | v[2] | yaccum | zi
+	fld		%st(0)				 // v[1] | v[1] | xaccum | v[2] | yaccum | zi
+	fmuls	C(aliastransform)+4	 // xaccum2 | v[1] | xaccum | v[2] | yaccum |zi
+	fxch	%st(1)				 // v[1] | xaccum2 | xaccum | v[2] | yaccum |zi
+	movl	%eax,fv_v+16(%edi)
+	fmuls	C(aliastransform)+20 // yaccum2 | xaccum2 | xaccum | v[2] | yaccum|
+								 //  zi
+	fxch	%st(2)				 // xaccum | xaccum2 | yaccum2 | v[2] | yaccum|
+								 //  zi
+	fadds	C(aliastransform)+12 // xaccum | xaccum2 | yaccum2 | v[2] | yaccum|
+								 //  zi
+	fxch	%st(4)				 // yaccum | xaccum2 | yaccum2 | v[2] | xaccum|
+								 //  zi
+	fadds	C(aliastransform)+28 // yaccum | xaccum2 | yaccum2 | v[2] | xaccum|
+								 //  zi
+	fxch	%st(3)				 // v[2] | xaccum2 | yaccum2 | yaccum | xaccum|
+								 //  zi
+	fld		%st(0)				 // v[2] | v[2] | xaccum2 | yaccum2 | yaccum |
+								 //  xaccum | zi
+	fmuls	C(aliastransform)+8	 // xaccum3 | v[2] | xaccum2 | yaccum2 |yaccum|
+								 //  xaccum | zi
+	fxch	%st(1)				 // v[2] | xaccum3 | xaccum2 | yaccum2 |yaccum|
+								 //  xaccum | zi
+	fmuls	C(aliastransform)+24 // yaccum3 | xaccum3 | xaccum2 | yaccum2 |
+								 // yaccum | xaccum | zi
+	fxch	%st(5)				 // xaccum | xaccum3 | xaccum2 | yaccum2 |
+								 // yaccum | yaccum3 | zi
+	faddp	%st(0),%st(2)		 // xaccum3 | xaccum | yaccum2 | yaccum |
+								 //  yaccum3 | zi
+	fxch	%st(3)				 // yaccum | xaccum | yaccum2 | xaccum3 |
+								 //  yaccum3 | zi
+	faddp	%st(0),%st(2)		 // xaccum | yaccum | xaccum3 | yaccum3 | zi
+	addl	$(tv_size),%esi
+	faddp	%st(0),%st(2)		 // yaccum | x | yaccum3 | zi
+	faddp	%st(0),%st(2)		 // x | y | zi
+	addl	$(stv_size),%ebp
+	fmul	%st(2),%st(0)		 // x/z | y | zi
+	fxch	%st(1)				 // y | x/z | zi
+	fmul	%st(2),%st(0)		 // y/z | x/z | zi
+	fxch	%st(1)				 // x/z | y/z | zi
+	fadds	C(aliasxcenter)		 // u | y/z | zi
+	fxch	%st(1)				 // y/z | u | zi
+	fadds	C(aliasycenter)		 // v | u | zi
+	fxch	%st(2)				 // zi | u | v
+// FIXME: fast float->int conversion?
+	fistpl	fv_v+20(%edi)		 // u | v
+	fistpl	fv_v+0(%edi)		 // v
+	fistpl	fv_v+4(%edi)
+
+//	}
+
+	addl	$(fv_size),%edi
+	decl	%ecx
+	jnz		Lloop
+
+	popl	%esi				// restore register variables
+	popl	%edi
+	popl	%ebp				// restore the caller's stack frame
+	ret
+
+Lsavelight:
+	fstp	%st(0)
+	jmp		Lp1
+
+#endif	// id386
+
diff -ruN WinQuake/r_aliasa.s sdlquake-1.0.9/r_aliasa.s
--- WinQuake/r_aliasa.s	Tue Dec 21 15:53:26 1999
+++ sdlquake-1.0.9/r_aliasa.s	Wed Dec 31 16:00:00 1969
@@ -1,237 +0,0 @@
-/*
-Copyright (C) 1996-1997 Id Software, Inc.
-
-This program is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License
-as published by the Free Software Foundation; either version 2
-of the License, or (at your option) any later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
-
-See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-*/
-//
-// r_aliasa.s
-// x86 assembly-language Alias model transform and project code.
-//
-
-#include "asm_i386.h"
-#include "quakeasm.h"
-#include "asm_draw.h"
-#include "d_ifacea.h"
-
-#if id386
-
-	.data
-
-Lfloat_1:	.single	1.0
-Ltemp:		.long	0
-Lcoords:	.long	0, 0, 0
-
-	.text
-
-#define fv			12+4
-#define pstverts	12+8
-
-.globl C(R_AliasTransformAndProjectFinalVerts)
-C(R_AliasTransformAndProjectFinalVerts):
-	pushl	%ebp				// preserve caller's stack frame
-	pushl	%edi
-	pushl	%esi				// preserve register variables
-
-//	int			i, temp;
-//	float		lightcos, *plightnormal, zi;
-//	trivertx_t	*pverts;
-
-//	pverts = r_apverts;
-	movl	C(r_apverts),%esi
-
-//	for (i=0 ; i<r_anumverts ; i++, fv++, pverts++, pstverts++)
-//	{
-	movl	pstverts(%esp),%ebp
-	movl	fv(%esp),%edi
-	movl	C(r_anumverts),%ecx
-	subl	%edx,%edx
-
-Lloop:
-
-//	// transform and project
-//		zi = 1.0 / (DotProduct(pverts->v, aliastransform[2]) +
-//				aliastransform[2][3]);
-	movb	(%esi),%dl
-	movb	%dl,Lcoords
-	fildl	Lcoords				// v[0]
-	movb	1(%esi),%dl
-	movb	%dl,Lcoords+4
-	fildl	Lcoords+4			// v[1] | v[0]
-	movb	2(%esi),%dl	
-	movb	%dl,Lcoords+8
-	fildl	Lcoords+8			// v[2] | v[1] | v[0]
-
-	fld		%st(2)				// v[0] | v[2] | v[1] | v[0]
-	fmuls	C(aliastransform)+32 // accum | v[2] | v[1] | v[0]
-	fld		%st(2)				// v[1] | accum | v[2] | v[1] | v[0]
-	fmuls	C(aliastransform)+36 // accum2 | accum | v[2] | v[1] | v[0]
-	fxch	%st(1)				// accum | accum2 | v[2] | v[1] | v[0]
-	fadds	C(aliastransform)+44 // accum | accum2 | v[2] | v[1] | v[0]
-	fld		%st(2)				// v[2] | accum | accum2 | v[2] | v[1] | v[0]
-	fmuls	C(aliastransform)+40 // accum3 | accum | accum2 | v[2] | v[1] |
-								 //  v[0]
-	fxch	%st(1)				// accum | accum3 | accum2 | v[2] | v[1] | v[0]
-	faddp	%st(0),%st(2)		// accum3 | accum | v[2] | v[1] | v[0]
-	movb	tv_lightnormalindex(%esi),%dl
-	movl	stv_s(%ebp),%eax
-	movl	%eax,fv_v+8(%edi)
-	faddp	%st(0),%st(1)		// z | v[2] | v[1] | v[0]
-
-	movl	stv_t(%ebp),%eax
-	movl	%eax,fv_v+12(%edi)
-
-//	// lighting
-//		plightnormal = r_avertexnormals[pverts->lightnormalindex];
-
-	fdivrs	Lfloat_1			// zi | v[2] | v[1] | v[0]
-
-//		fv->v[2] = pstverts->s;
-//		fv->v[3] = pstverts->t;
-//		fv->flags = pstverts->onseam;
-	movl	stv_onseam(%ebp),%eax
-	movl	%eax,fv_flags(%edi)
-
-	movl	fv_size(%edi),%eax
-	movl	stv_size(%ebp),%eax
-	movl	4(%esi),%eax
-
-	leal	(%edx,%edx,2),%eax	// index*3
-
-	fxch	%st(3)				// v[0] | v[2] | v[1] | zi
-
-//		lightcos = DotProduct (plightnormal, r_plightvec);
-	flds	C(r_avertexnormals)(,%eax,4)
-	fmuls	C(r_plightvec)
-	flds	C(r_avertexnormals)+4(,%eax,4)
-	fmuls	C(r_plightvec)+4
-	flds	C(r_avertexnormals)+8(,%eax,4)
-	fmuls	C(r_plightvec)+8
-	fxch	%st(1)
-	faddp	%st(0),%st(2)
-	fld		%st(2)				 // v[0] | laccum | laccum2 | v[0] | v[2] |
-								 //  v[1] | zi
-	fmuls	C(aliastransform)+0  // xaccum | laccum | laccum2 | v[0] | v[2] |
-								 //  v[1] | zi
-	fxch	%st(2)				 // laccum2 | laccum | xaccum | v[0] | v[2] |
-								 //  v[1] | zi
-	faddp	%st(0),%st(1)		 // laccum | xaccum | v[0] | v[2] | v[1] | zi
-
-//		temp = r_ambientlight;
-//		if (lightcos < 0)
-//		{
-	fsts	Ltemp
-	movl	C(r_ambientlight),%eax
-	movb	Ltemp+3,%dl
-	testb	$0x80,%dl
-	jz		Lsavelight	// no need to clamp if only ambient lit, because
-						//  r_ambientlight is preclamped
-
-//			temp += (int)(r_shadelight * lightcos);
-	fmuls	C(r_shadelight)
-// FIXME: fast float->int conversion?
-	fistpl	Ltemp
-	addl	Ltemp,%eax
-
-//		// clamp; because we limited the minimum ambient and shading light, we
-//		// don't have to clamp low light, just bright
-//			if (temp < 0)
-//				temp = 0;
-	jns		Lp1
-	subl	%eax,%eax
-
-//		}
-
-Lp1:
-
-//		fv->v[4] = temp;
-//
-//	// x, y, and z are scaled down by 1/2**31 in the transform, so 1/z is
-//	// scaled up by 1/2**31, and the scaling cancels out for x and y in the
-//	// projection
-//		fv->v[0] = ((DotProduct(pverts->v, aliastransform[0]) +
-//				aliastransform[0][3]) * zi) + aliasxcenter;
-//		fv->v[1] = ((DotProduct(pverts->v, aliastransform[1]) +
-//				aliastransform[1][3]) * zi) + aliasycenter;
-//		fv->v[5] = zi;
-	fxch	%st(1)				 // v[0] | xaccum | v[2] | v[1] | zi
-	fmuls	C(aliastransform)+16 // yaccum | xaccum | v[2] | v[1] | zi
-	fxch	%st(3)				 // v[1] | xaccum | v[2] | yaccum | zi
-	fld		%st(0)				 // v[1] | v[1] | xaccum | v[2] | yaccum | zi
-	fmuls	C(aliastransform)+4	 // xaccum2 | v[1] | xaccum | v[2] | yaccum |zi
-	fxch	%st(1)				 // v[1] | xaccum2 | xaccum | v[2] | yaccum |zi
-	movl	%eax,fv_v+16(%edi)
-	fmuls	C(aliastransform)+20 // yaccum2 | xaccum2 | xaccum | v[2] | yaccum|
-								 //  zi
-	fxch	%st(2)				 // xaccum | xaccum2 | yaccum2 | v[2] | yaccum|
-								 //  zi
-	fadds	C(aliastransform)+12 // xaccum | xaccum2 | yaccum2 | v[2] | yaccum|
-								 //  zi
-	fxch	%st(4)				 // yaccum | xaccum2 | yaccum2 | v[2] | xaccum|
-								 //  zi
-	fadds	C(aliastransform)+28 // yaccum | xaccum2 | yaccum2 | v[2] | xaccum|
-								 //  zi
-	fxch	%st(3)				 // v[2] | xaccum2 | yaccum2 | yaccum | xaccum|
-								 //  zi
-	fld		%st(0)				 // v[2] | v[2] | xaccum2 | yaccum2 | yaccum |
-								 //  xaccum | zi
-	fmuls	C(aliastransform)+8	 // xaccum3 | v[2] | xaccum2 | yaccum2 |yaccum|
-								 //  xaccum | zi
-	fxch	%st(1)				 // v[2] | xaccum3 | xaccum2 | yaccum2 |yaccum|
-								 //  xaccum | zi
-	fmuls	C(aliastransform)+24 // yaccum3 | xaccum3 | xaccum2 | yaccum2 |
-								 // yaccum | xaccum | zi
-	fxch	%st(5)				 // xaccum | xaccum3 | xaccum2 | yaccum2 |
-								 // yaccum | yaccum3 | zi
-	faddp	%st(0),%st(2)		 // xaccum3 | xaccum | yaccum2 | yaccum |
-								 //  yaccum3 | zi
-	fxch	%st(3)				 // yaccum | xaccum | yaccum2 | xaccum3 |
-								 //  yaccum3 | zi
-	faddp	%st(0),%st(2)		 // xaccum | yaccum | xaccum3 | yaccum3 | zi
-	addl	$(tv_size),%esi
-	faddp	%st(0),%st(2)		 // yaccum | x | yaccum3 | zi
-	faddp	%st(0),%st(2)		 // x | y | zi
-	addl	$(stv_size),%ebp
-	fmul	%st(2),%st(0)		 // x/z | y | zi
-	fxch	%st(1)				 // y | x/z | zi
-	fmul	%st(2),%st(0)		 // y/z | x/z | zi
-	fxch	%st(1)				 // x/z | y/z | zi
-	fadds	C(aliasxcenter)		 // u | y/z | zi
-	fxch	%st(1)				 // y/z | u | zi
-	fadds	C(aliasycenter)		 // v | u | zi
-	fxch	%st(2)				 // zi | u | v
-// FIXME: fast float->int conversion?
-	fistpl	fv_v+20(%edi)		 // u | v
-	fistpl	fv_v+0(%edi)		 // v
-	fistpl	fv_v+4(%edi)
-
-//	}
-
-	addl	$(fv_size),%edi
-	decl	%ecx
-	jnz		Lloop
-
-	popl	%esi				// restore register variables
-	popl	%edi
-	popl	%ebp				// restore the caller's stack frame
-	ret
-
-Lsavelight:
-	fstp	%st(0)
-	jmp		Lp1
-
-#endif	// id386
-
diff -ruN WinQuake/r_drawa.S sdlquake-1.0.9/r_drawa.S
--- WinQuake/r_drawa.S	Wed Dec 31 16:00:00 1969
+++ sdlquake-1.0.9/r_drawa.S	Sat Dec 25 03:38:03 1999
@@ -0,0 +1,838 @@
+/*
+Copyright (C) 1996-1997 Id Software, Inc.
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation; either version 2
+of the License, or (at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
+
+See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+//
+// r_drawa.s
+// x86 assembly-language edge clipping and emission code
+//
+
+#include "asm_i386.h"
+#include "quakeasm.h"
+#include "asm_draw.h"
+#include "d_ifacea.h"
+
+#if	id386
+
+// !!! if these are changed, they must be changed in r_draw.c too !!!
+#define FULLY_CLIPPED_CACHED	0x80000000
+#define FRAMECOUNT_MASK			0x7FFFFFFF
+
+	.data
+
+Ld0:			.single		0.0
+Ld1:			.single		0.0
+Lstack:			.long		0
+Lfp_near_clip:	.single		NEAR_CLIP
+Lceilv0:		.long		0
+Lv:				.long		0
+Lu0:			.long		0
+Lv0:			.long		0
+Lzi0:			.long		0
+
+	.text
+
+//----------------------------------------------------------------------
+// edge clipping code
+//----------------------------------------------------------------------
+
+#define pv0		4+12
+#define pv1		8+12
+#define clip	12+12
+
+	.align 4
+.globl C(R_ClipEdge)
+C(R_ClipEdge):
+	pushl	%esi				// preserve register variables
+	pushl	%edi
+	pushl	%ebx
+	movl	%esp,Lstack			// for clearing the stack later
+
+//	float		d0, d1, f;
+//	mvertex_t	clipvert;
+
+	movl	clip(%esp),%ebx
+	movl	pv0(%esp),%esi
+	movl	pv1(%esp),%edx
+
+//	if (clip)
+//	{
+	testl	%ebx,%ebx
+	jz		Lemit
+
+//		do
+//		{
+
+Lcliploop:
+
+//			d0 = DotProduct (pv0->position, clip->normal) - clip->dist;
+//			d1 = DotProduct (pv1->position, clip->normal) - clip->dist;
+	flds	mv_position+0(%esi)
+	fmuls	cp_normal+0(%ebx)
+	flds	mv_position+4(%esi)
+	fmuls	cp_normal+4(%ebx)
+	flds	mv_position+8(%esi)
+	fmuls	cp_normal+8(%ebx)
+	fxch	%st(1)
+	faddp	%st(0),%st(2)		// d0mul2 | d0add0
+
+	flds	mv_position+0(%edx)
+	fmuls	cp_normal+0(%ebx)
+	flds	mv_position+4(%edx)
+	fmuls	cp_normal+4(%ebx)
+	flds	mv_position+8(%edx)
+	fmuls	cp_normal+8(%ebx)
+	fxch	%st(1)
+	faddp	%st(0),%st(2)		// d1mul2 | d1add0 | d0mul2 | d0add0
+	fxch	%st(3)				// d0add0 | d1add0 | d0mul2 | d1mul2
+
+	faddp	%st(0),%st(2)		// d1add0 | dot0 | d1mul2 
+	faddp	%st(0),%st(2)		// dot0 | dot1
+
+	fsubs	cp_dist(%ebx)		// d0 | dot1
+	fxch	%st(1)				// dot1 | d0
+	fsubs	cp_dist(%ebx)		// d1 | d0
+	fxch	%st(1)
+	fstps	Ld0
+	fstps	Ld1
+
+//			if (d0 >= 0)
+//			{
+	movl	Ld0,%eax
+	movl	Ld1,%ecx
+	orl		%eax,%ecx
+	js		Lp2
+
+// both points are unclipped
+
+Lcontinue:
+
+//
+//				R_ClipEdge (&clipvert, pv1, clip->next);
+//				return;
+//			}
+//		} while ((clip = clip->next) != NULL);
+	movl	cp_next(%ebx),%ebx
+	testl	%ebx,%ebx
+	jnz		Lcliploop
+
+//	}
+
+//// add the edge
+//	R_EmitEdge (pv0, pv1);
+Lemit:
+
+//
+// set integer rounding to ceil mode, set to single precision
+//
+// FIXME: do away with by manually extracting integers from floats?
+// FIXME: set less often
+	fldcw	ceil_cw
+
+//	edge_t	*edge, *pcheck;
+//	int		u_check;
+//	float	u, u_step;
+//	vec3_t	local, transformed;
+//	float	*world;
+//	int		v, v2, ceilv0;
+//	float	scale, lzi0, u0, v0;
+//	int		side;
+
+//	if (r_lastvertvalid)
+//	{
+	cmpl	$0,C(r_lastvertvalid)
+	jz		LCalcFirst
+
+//		u0 = r_u1;
+//		v0 = r_v1;
+//		lzi0 = r_lzi1;
+//		ceilv0 = r_ceilv1;
+	movl	C(r_lzi1),%eax
+	movl	C(r_u1),%ecx
+	movl	%eax,Lzi0
+	movl	%ecx,Lu0
+	movl	C(r_v1),%ecx
+	movl	C(r_ceilv1),%eax
+	movl	%ecx,Lv0
+	movl	%eax,Lceilv0
+	jmp		LCalcSecond
+
+//	}
+
+LCalcFirst:
+
+//	else
+//	{
+//		world = &pv0->position[0];
+
+	call	LTransformAndProject	// v0 | lzi0 | u0
+
+	fsts	Lv0
+	fxch	%st(2)					// u0 | lzi0 | v0
+	fstps	Lu0						// lzi0 | v0
+	fstps	Lzi0					// v0
+
+//		ceilv0 = (int)(v0 - 2000) + 2000; // ceil(v0);
+	fistpl	Lceilv0
+
+//	}
+
+LCalcSecond:
+
+//	world = &pv1->position[0];
+	movl	%edx,%esi
+
+	call	LTransformAndProject	// v1 | lzi1 | u1
+
+	flds	Lu0						// u0 | v1 | lzi1 | u1
+	fxch	%st(3)					// u1 | v1 | lzi1 | u0
+	flds	Lzi0					// lzi0 | u1 | v1 | lzi1 | u0
+	fxch	%st(3)					// lzi1 | u1 | v1 | lzi0 | u0
+	flds	Lv0						// v0 | lzi1 | u1 | v1 | lzi0 | u0
+	fxch	%st(3)					// v1 | lzi1 | u1 | v0 | lzi0 | u0
+
+//	r_ceilv1 = (int)(r_v1 - 2000) + 2000; // ceil(r_v1);
+	fistl	C(r_ceilv1)
+
+	fldcw	single_cw				// put back normal floating-point state
+
+	fsts	C(r_v1)
+	fxch	%st(4)					// lzi0 | lzi1 | u1 | v0 | v1 | u0
+
+//	if (r_lzi1 > lzi0)
+//		lzi0 = r_lzi1;
+	fcom	%st(1)
+	fnstsw	%ax
+	testb	$1,%ah
+	jz		LP0
+	fstp	%st(0)
+	fld		%st(0)
+LP0:
+
+	fxch	%st(1)					// lzi1 | lzi0 | u1 | v0 | v1 | u0
+	fstps	C(r_lzi1)				// lzi0 | u1 | v0 | v1 | u0
+	fxch	%st(1)
+	fsts	C(r_u1)
+	fxch	%st(1)
+
+//	if (lzi0 > r_nearzi)	// for mipmap finding
+//		r_nearzi = lzi0;
+	fcoms	C(r_nearzi)
+	fnstsw	%ax
+	testb	$0x45,%ah
+	jnz		LP1
+	fsts	C(r_nearzi)
+LP1:
+
+// // for right edges, all we want is the effect on 1/z
+//	if (r_nearzionly)
+//		return;
+	movl	C(r_nearzionly),%eax
+	testl	%eax,%eax
+	jz		LP2
+LPop5AndDone:
+	movl	C(cacheoffset),%eax
+	movl	C(r_framecount),%edx
+	cmpl	$0x7FFFFFFF,%eax
+	jz		LDoPop
+	andl	$(FRAMECOUNT_MASK),%edx
+	orl		$(FULLY_CLIPPED_CACHED),%edx
+	movl	%edx,C(cacheoffset)
+
+LDoPop:
+	fstp	%st(0)			// u1 | v0 | v1 | u0
+	fstp	%st(0)			// v0 | v1 | u0
+	fstp	%st(0)			// v1 | u0
+	fstp	%st(0)			// u0
+	fstp	%st(0)
+	jmp		Ldone
+
+LP2:
+
+// // create the edge
+//	if (ceilv0 == r_ceilv1)
+//		return;		// horizontal edge
+	movl	Lceilv0,%ebx
+	movl	C(edge_p),%edi
+	movl	C(r_ceilv1),%ecx
+	movl	%edi,%edx
+	movl	C(r_pedge),%esi
+	addl	$(et_size),%edx
+	cmpl	%ecx,%ebx
+	jz		LPop5AndDone
+
+	movl	C(r_pedge),%eax
+	movl	%eax,et_owner(%edi)
+
+//	side = ceilv0 > r_ceilv1;
+//
+//	edge->nearzi = lzi0;
+	fstps	et_nearzi(%edi)		// u1 | v0 | v1 | u0
+
+//	if (side == 1)
+//	{
+	jc		LSide0
+
+LSide1:
+
+//	// leading edge (go from p2 to p1)
+
+//		u_step = ((u0 - r_u1) / (v0 - r_v1));
+	fsubrp	%st(0),%st(3)		// v0 | v1 | u0-u1
+	fsub	%st(1),%st(0)		// v0-v1 | v1 | u0-u1
+	fdivrp	%st(0),%st(2)		// v1 | ustep
+
+//	r_emitted = 1;
+	movl	$1,C(r_emitted)
+
+//	edge = edge_p++;
+	movl	%edx,C(edge_p)
+
+// pretouch next edge
+	movl	(%edx),%eax
+
+//		v2 = ceilv0 - 1;
+//		v = r_ceilv1;
+	movl	%ecx,%eax
+	leal	-1(%ebx),%ecx
+	movl	%eax,%ebx
+
+//		edge->surfs[0] = 0;
+//		edge->surfs[1] = surface_p - surfaces;
+	movl	C(surface_p),%eax
+	movl	C(surfaces),%esi
+	subl	%edx,%edx
+	subl	%esi,%eax
+	shrl	$(SURF_T_SHIFT),%eax
+	movl	%edx,et_surfs(%edi)
+	movl	%eax,et_surfs+2(%edi)
+
+	subl	%esi,%esi
+
+//		u = r_u1 + ((float)v - r_v1) * u_step;
+	movl	%ebx,Lv
+	fildl	Lv					// v | v1 | ustep
+	fsubp	%st(0),%st(1)		// v-v1 | ustep
+	fmul	%st(1),%st(0)		// (v-v1)*ustep | ustep
+	fadds	C(r_u1)				// u | ustep
+
+	jmp		LSideDone
+
+//	}
+
+LSide0:
+
+//	else
+//	{
+//	// trailing edge (go from p1 to p2)
+
+//		u_step = ((r_u1 - u0) / (r_v1 - v0));
+	fsub	%st(3),%st(0)		// u1-u0 | v0 | v1 | u0
+	fxch	%st(2)				// v1 | v0 | u1-u0 | u0
+	fsub	%st(1),%st(0)		// v1-v0 | v0 | u1-u0 | u0
+	fdivrp	%st(0),%st(2)		// v0 | ustep | u0
+
+//	r_emitted = 1;
+	movl	$1,C(r_emitted)
+
+//	edge = edge_p++;
+	movl	%edx,C(edge_p)
+
+// pretouch next edge
+	movl	(%edx),%eax
+
+//		v = ceilv0;
+//		v2 = r_ceilv1 - 1;
+	decl	%ecx
+
+//		edge->surfs[0] = surface_p - surfaces;
+//		edge->surfs[1] = 0;
+	movl	C(surface_p),%eax
+	movl	C(surfaces),%esi
+	subl	%edx,%edx
+	subl	%esi,%eax
+	shrl	$(SURF_T_SHIFT),%eax
+	movl	%edx,et_surfs+2(%edi)
+	movl	%eax,et_surfs(%edi)
+
+	movl	$1,%esi
+
+//		u = u0 + ((float)v - v0) * u_step;
+	movl	%ebx,Lv
+	fildl	Lv					// v | v0 | ustep | u0
+	fsubp	%st(0),%st(1)		// v-v0 | ustep | u0
+	fmul	%st(1),%st(0)		// (v-v0)*ustep | ustep | u0
+	faddp	%st(0),%st(2)		// ustep | u
+	fxch	%st(1)				// u | ustep
+
+//	}
+
+LSideDone:
+
+//	edge->u_step = u_step*0x100000;
+//	edge->u = u*0x100000 + 0xFFFFF;
+
+	fmuls	fp_1m				// u*0x100000 | ustep
+	fxch	%st(1)				// ustep | u*0x100000
+	fmuls	fp_1m				// ustep*0x100000 | u*0x100000
+	fxch	%st(1)				// u*0x100000 | ustep*0x100000
+	fadds	fp_1m_minus_1		// u*0x100000 + 0xFFFFF | ustep*0x100000
+	fxch	%st(1)				// ustep*0x100000 | u*0x100000 + 0xFFFFF
+	fistpl	et_u_step(%edi)		// u*0x100000 + 0xFFFFF
+	fistpl	et_u(%edi)
+
+// // we need to do this to avoid stepping off the edges if a very nearly
+// // horizontal edge is less than epsilon above a scan, and numeric error
+// // causes it to incorrectly extend to the scan, and the extension of the
+// // line goes off the edge of the screen
+// // FIXME: is this actually needed?
+//	if (edge->u < r_refdef.vrect_x_adj_shift20)
+//		edge->u = r_refdef.vrect_x_adj_shift20;
+//	if (edge->u > r_refdef.vrectright_adj_shift20)
+//		edge->u = r_refdef.vrectright_adj_shift20;
+	movl	et_u(%edi),%eax
+	movl	C(r_refdef)+rd_vrect_x_adj_shift20,%edx
+	cmpl	%edx,%eax
+	jl		LP4
+	movl	C(r_refdef)+rd_vrectright_adj_shift20,%edx
+	cmpl	%edx,%eax
+	jng		LP5
+LP4:
+	movl	%edx,et_u(%edi)
+	movl	%edx,%eax
+LP5:
+
+// // sort the edge in normally
+//	u_check = edge->u;
+//
+//	if (edge->surfs[0])
+//		u_check++;	// sort trailers after leaders
+	addl	%esi,%eax
+
+//	if (!newedges[v] || newedges[v]->u >= u_check)
+//	{
+	movl	C(newedges)(,%ebx,4),%esi
+	testl	%esi,%esi
+	jz		LDoFirst
+	cmpl	%eax,et_u(%esi)
+	jl		LNotFirst
+LDoFirst:
+
+//		edge->next = newedges[v];
+//		newedges[v] = edge;
+	movl	%esi,et_next(%edi)
+	movl	%edi,C(newedges)(,%ebx,4)
+
+	jmp		LSetRemove
+
+//	}
+
+LNotFirst:
+
+//	else
+//	{
+//		pcheck = newedges[v];
+//
+//		while (pcheck->next && pcheck->next->u < u_check)
+//			pcheck = pcheck->next;
+LFindInsertLoop:
+	movl	%esi,%edx
+	movl	et_next(%esi),%esi
+	testl	%esi,%esi
+	jz		LInsertFound
+	cmpl	%eax,et_u(%esi)
+	jl		LFindInsertLoop
+
+LInsertFound:
+
+//		edge->next = pcheck->next;
+//		pcheck->next = edge;
+	movl	%esi,et_next(%edi)
+	movl	%edi,et_next(%edx)
+
+//	}
+
+LSetRemove:
+
+//	edge->nextremove = removeedges[v2];
+//	removeedges[v2] = edge;
+	movl	C(removeedges)(,%ecx,4),%eax
+	movl	%edi,C(removeedges)(,%ecx,4)
+	movl	%eax,et_nextremove(%edi)
+
+Ldone:
+	movl	Lstack,%esp			// clear temporary variables from stack
+
+	popl	%ebx				// restore register variables
+	popl	%edi
+	popl	%esi
+	ret
+
+// at least one point is clipped
+
+Lp2:
+	testl	%eax,%eax
+	jns		Lp1
+
+//			else
+//			{
+//			// point 0 is clipped
+
+//				if (d1 < 0)
+//				{
+	movl	Ld1,%eax
+	testl	%eax,%eax
+	jns		Lp3
+
+//				// both points are clipped
+//				// we do cache fully clipped edges
+//					if (!leftclipped)
+	movl	C(r_leftclipped),%eax
+	movl	C(r_pedge),%ecx
+	testl	%eax,%eax
+	jnz		Ldone
+
+//						r_pedge->framecount = r_framecount;
+	movl	C(r_framecount),%eax
+	andl	$(FRAMECOUNT_MASK),%eax
+	orl		$(FULLY_CLIPPED_CACHED),%eax
+	movl	%eax,C(cacheoffset)
+
+//					return;
+	jmp		Ldone
+
+//				}
+
+Lp1:
+
+//			// point 0 is unclipped
+//				if (d1 >= 0)
+//				{
+//				// both points are unclipped
+//					continue;
+
+//			// only point 1 is clipped
+
+//				f = d0 / (d0 - d1);
+	flds	Ld0
+	flds	Ld1
+	fsubr	%st(1),%st(0)
+
+//			// we don't cache partially clipped edges
+	movl	$0x7FFFFFFF,C(cacheoffset)
+
+	fdivrp	%st(0),%st(1)
+
+	subl	$(mv_size),%esp			// allocate space for clipvert
+
+//				clipvert.position[0] = pv0->position[0] +
+//						f * (pv1->position[0] - pv0->position[0]);
+//				clipvert.position[1] = pv0->position[1] +
+//						f * (pv1->position[1] - pv0->position[1]);
+//				clipvert.position[2] = pv0->position[2] +
+//						f * (pv1->position[2] - pv0->position[2]);
+	flds	mv_position+8(%edx)
+	fsubs	mv_position+8(%esi)
+	flds	mv_position+4(%edx)
+	fsubs	mv_position+4(%esi)
+	flds	mv_position+0(%edx)
+	fsubs	mv_position+0(%esi)		// 0 | 1 | 2
+
+// replace pv1 with the clip point
+	movl	%esp,%edx
+	movl	cp_leftedge(%ebx),%eax
+	testb	%al,%al
+
+	fmul	%st(3),%st(0)
+	fxch	%st(1)					// 1 | 0 | 2
+	fmul	%st(3),%st(0)
+	fxch	%st(2)					// 2 | 0 | 1
+	fmulp	%st(0),%st(3)			// 0 | 1 | 2
+	fadds	mv_position+0(%esi)
+	fxch	%st(1)					// 1 | 0 | 2
+	fadds	mv_position+4(%esi)
+	fxch	%st(2)					// 2 | 0 | 1
+	fadds	mv_position+8(%esi)
+	fxch	%st(1)					// 0 | 2 | 1
+	fstps	mv_position+0(%esp)		// 2 | 1
+	fstps	mv_position+8(%esp)		// 1
+	fstps	mv_position+4(%esp)
+
+//				if (clip->leftedge)
+//				{
+	jz		Ltestright
+
+//					r_leftclipped = true;
+//					r_leftexit = clipvert;
+	movl	$1,C(r_leftclipped)
+	movl	mv_position+0(%esp),%eax
+	movl	%eax,C(r_leftexit)+mv_position+0
+	movl	mv_position+4(%esp),%eax
+	movl	%eax,C(r_leftexit)+mv_position+4
+	movl	mv_position+8(%esp),%eax
+	movl	%eax,C(r_leftexit)+mv_position+8
+
+	jmp		Lcontinue
+
+//				}
+
+Ltestright:
+//				else if (clip->rightedge)
+//				{
+	testb	%ah,%ah
+	jz		Lcontinue
+
+//					r_rightclipped = true;
+//					r_rightexit = clipvert;
+	movl	$1,C(r_rightclipped)
+	movl	mv_position+0(%esp),%eax
+	movl	%eax,C(r_rightexit)+mv_position+0
+	movl	mv_position+4(%esp),%eax
+	movl	%eax,C(r_rightexit)+mv_position+4
+	movl	mv_position+8(%esp),%eax
+	movl	%eax,C(r_rightexit)+mv_position+8
+
+//				}
+//
+//				R_ClipEdge (pv0, &clipvert, clip->next);
+//				return;
+//			}
+	jmp		Lcontinue
+
+//			}
+
+Lp3:
+
+//			// only point 0 is clipped
+//				r_lastvertvalid = false;
+
+	movl	$0,C(r_lastvertvalid)
+
+//				f = d0 / (d0 - d1);
+	flds	Ld0
+	flds	Ld1
+	fsubr	%st(1),%st(0)
+
+//			// we don't cache partially clipped edges
+	movl	$0x7FFFFFFF,C(cacheoffset)
+
+	fdivrp	%st(0),%st(1)
+
+	subl	$(mv_size),%esp			// allocate space for clipvert
+
+//				clipvert.position[0] = pv0->position[0] +
+//						f * (pv1->position[0] - pv0->position[0]);
+//				clipvert.position[1] = pv0->position[1] +
+//						f * (pv1->position[1] - pv0->position[1]);
+//				clipvert.position[2] = pv0->position[2] +
+//						f * (pv1->position[2] - pv0->position[2]);
+	flds	mv_position+8(%edx)
+	fsubs	mv_position+8(%esi)
+	flds	mv_position+4(%edx)
+	fsubs	mv_position+4(%esi)
+	flds	mv_position+0(%edx)
+	fsubs	mv_position+0(%esi)		// 0 | 1 | 2
+
+	movl	cp_leftedge(%ebx),%eax
+	testb	%al,%al
+
+	fmul	%st(3),%st(0)
+	fxch	%st(1)					// 1 | 0 | 2
+	fmul	%st(3),%st(0)
+	fxch	%st(2)					// 2 | 0 | 1
+	fmulp	%st(0),%st(3)			// 0 | 1 | 2
+	fadds	mv_position+0(%esi)
+	fxch	%st(1)					// 1 | 0 | 2
+	fadds	mv_position+4(%esi)
+	fxch	%st(2)					// 2 | 0 | 1
+	fadds	mv_position+8(%esi)
+	fxch	%st(1)					// 0 | 2 | 1
+	fstps	mv_position+0(%esp)		// 2 | 1
+	fstps	mv_position+8(%esp)		// 1
+	fstps	mv_position+4(%esp)
+
+// replace pv0 with the clip point
+	movl	%esp,%esi
+
+//				if (clip->leftedge)
+//				{
+	jz		Ltestright2
+
+//					r_leftclipped = true;
+//					r_leftenter = clipvert;
+	movl	$1,C(r_leftclipped)
+	movl	mv_position+0(%esp),%eax
+	movl	%eax,C(r_leftenter)+mv_position+0
+	movl	mv_position+4(%esp),%eax
+	movl	%eax,C(r_leftenter)+mv_position+4
+	movl	mv_position+8(%esp),%eax
+	movl	%eax,C(r_leftenter)+mv_position+8
+
+	jmp		Lcontinue
+
+//				}
+
+Ltestright2:
+//				else if (clip->rightedge)
+//				{
+	testb	%ah,%ah
+	jz		Lcontinue
+
+//					r_rightclipped = true;
+//					r_rightenter = clipvert;
+	movl	$1,C(r_rightclipped)
+	movl	mv_position+0(%esp),%eax
+	movl	%eax,C(r_rightenter)+mv_position+0
+	movl	mv_position+4(%esp),%eax
+	movl	%eax,C(r_rightenter)+mv_position+4
+	movl	mv_position+8(%esp),%eax
+	movl	%eax,C(r_rightenter)+mv_position+8
+
+//				}
+	jmp		Lcontinue
+
+// %esi = vec3_t point to transform and project
+// %edx preserved
+LTransformAndProject:
+
+//	// transform and project
+//		VectorSubtract (world, modelorg, local);
+	flds	mv_position+0(%esi)
+	fsubs	C(modelorg)+0
+	flds	mv_position+4(%esi)
+	fsubs	C(modelorg)+4
+	flds	mv_position+8(%esi)	
+	fsubs	C(modelorg)+8
+	fxch	%st(2)				// local[0] | local[1] | local[2]
+
+//		TransformVector (local, transformed);
+//	
+//		if (transformed[2] < NEAR_CLIP)
+//			transformed[2] = NEAR_CLIP;
+//	
+//		lzi0 = 1.0 / transformed[2];
+	fld		%st(0)				// local[0] | local[0] | local[1] | local[2]
+	fmuls	C(vpn)+0			// zm0 | local[0] | local[1] | local[2]
+	fld		%st(1)				// local[0] | zm0 | local[0] | local[1] |
+								//  local[2]
+	fmuls	C(vright)+0			// xm0 | zm0 | local[0] | local[1] | local[2]
+	fxch	%st(2)				// local[0] | zm0 | xm0 | local[1] | local[2]
+	fmuls	C(vup)+0			// ym0 |  zm0 | xm0 | local[1] | local[2]
+	fld		%st(3)				// local[1] | ym0 |  zm0 | xm0 | local[1] |
+								//  local[2]
+	fmuls	C(vpn)+4			// zm1 | ym0 | zm0 | xm0 | local[1] |
+								//  local[2]
+	fld		%st(4)				// local[1] | zm1 | ym0 | zm0 | xm0 |
+								//  local[1] | local[2]
+	fmuls	C(vright)+4			// xm1 | zm1 | ym0 |  zm0 | xm0 |
+								//  local[1] | local[2]
+	fxch	%st(5)				// local[1] | zm1 | ym0 | zm0 | xm0 |
+								//  xm1 | local[2]
+	fmuls	C(vup)+4			// ym1 | zm1 | ym0 | zm0 | xm0 |
+								//  xm1 | local[2]
+	fxch	%st(1)				// zm1 | ym1 | ym0 | zm0 | xm0 |
+								//  xm1 | local[2]
+	faddp	%st(0),%st(3)		// ym1 | ym0 | zm2 | xm0 | xm1 | local[2]
+	fxch	%st(3)				// xm0 | ym0 | zm2 | ym1 | xm1 | local[2]
+	faddp	%st(0),%st(4)		// ym0 | zm2 | ym1 | xm2 | local[2]
+	faddp	%st(0),%st(2)		// zm2 | ym2 | xm2 | local[2]
+	fld		%st(3)				// local[2] | zm2 | ym2 | xm2 | local[2]
+	fmuls	C(vpn)+8			// zm3 | zm2 | ym2 | xm2 | local[2]
+	fld		%st(4)				// local[2] | zm3 | zm2 | ym2 | xm2 | local[2]
+	fmuls	C(vright)+8			// xm3 | zm3 | zm2 | ym2 | xm2 | local[2]
+	fxch	%st(5)				// local[2] | zm3 | zm2 | ym2 | xm2 | xm3
+	fmuls	C(vup)+8			// ym3 | zm3 | zm2 | ym2 | xm2 | xm3
+	fxch	%st(1)				// zm3 | ym3 | zm2 | ym2 | xm2 | xm3
+	faddp	%st(0),%st(2)		// ym3 | zm4 | ym2 | xm2 | xm3
+	fxch	%st(4)				// xm3 | zm4 | ym2 | xm2 | ym3
+	faddp	%st(0),%st(3)		// zm4 | ym2 | xm4 | ym3
+	fxch	%st(1)				// ym2 | zm4 | xm4 | ym3
+	faddp	%st(0),%st(3)		// zm4 | xm4 | ym4
+
+	fcoms	Lfp_near_clip
+	fnstsw	%ax
+	testb	$1,%ah
+	jz		LNoClip
+	fstp	%st(0)
+	flds	Lfp_near_clip
+
+LNoClip:
+
+	fdivrs	float_1				// lzi0 | x | y
+	fxch	%st(1)				// x | lzi0 | y
+
+//	// FIXME: build x/yscale into transform?
+//		scale = xscale * lzi0;
+//		u0 = (xcenter + scale*transformed[0]);
+	flds	C(xscale)			// xscale | x | lzi0 | y
+	fmul	%st(2),%st(0)		// scale | x | lzi0 | y
+	fmulp	%st(0),%st(1)		// scale*x | lzi0 | y
+	fadds	C(xcenter)			// u0 | lzi0 | y
+
+//		if (u0 < r_refdef.fvrectx_adj)
+//			u0 = r_refdef.fvrectx_adj;
+//		if (u0 > r_refdef.fvrectright_adj)
+//			u0 = r_refdef.fvrectright_adj;
+// FIXME: use integer compares of floats?
+	fcoms	C(r_refdef)+rd_fvrectx_adj
+	fnstsw	%ax
+	testb	$1,%ah
+	jz		LClampP0
+	fstp	%st(0)
+	flds	C(r_refdef)+rd_fvrectx_adj
+LClampP0:
+	fcoms	C(r_refdef)+rd_fvrectright_adj
+	fnstsw	%ax
+	testb	$0x45,%ah
+	jnz		LClampP1
+	fstp	%st(0)
+	flds	C(r_refdef)+rd_fvrectright_adj
+LClampP1:
+
+	fld		%st(1)				// lzi0 | u0 | lzi0 | y
+
+//		scale = yscale * lzi0;
+//		v0 = (ycenter - scale*transformed[1]);
+	fmuls	C(yscale)			// scale | u0 | lzi0 | y
+	fmulp	%st(0),%st(3)		// u0 | lzi0 | scale*y
+	fxch	%st(2)				// scale*y | lzi0 | u0
+	fsubrs	C(ycenter)			// v0 | lzi0 | u0
+
+//		if (v0 < r_refdef.fvrecty_adj)
+//			v0 = r_refdef.fvrecty_adj;
+//		if (v0 > r_refdef.fvrectbottom_adj)
+//			v0 = r_refdef.fvrectbottom_adj;
+// FIXME: use integer compares of floats?
+	fcoms	C(r_refdef)+rd_fvrecty_adj
+	fnstsw	%ax
+	testb	$1,%ah
+	jz		LClampP2
+	fstp	%st(0)
+	flds	C(r_refdef)+rd_fvrecty_adj
+LClampP2:
+	fcoms	C(r_refdef)+rd_fvrectbottom_adj
+	fnstsw	%ax
+	testb	$0x45,%ah
+	jnz		LClampP3
+	fstp	%st(0)
+	flds	C(r_refdef)+rd_fvrectbottom_adj
+LClampP3:
+	ret
+
+#endif	// id386
+
diff -ruN WinQuake/r_drawa.s sdlquake-1.0.9/r_drawa.s
--- WinQuake/r_drawa.s	Tue Dec 21 15:53:26 1999
+++ sdlquake-1.0.9/r_drawa.s	Wed Dec 31 16:00:00 1969
@@ -1,838 +0,0 @@
-/*
-Copyright (C) 1996-1997 Id Software, Inc.
-
-This program is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License
-as published by the Free Software Foundation; either version 2
-of the License, or (at your option) any later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
-
-See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-*/
-//
-// r_drawa.s
-// x86 assembly-language edge clipping and emission code
-//
-
-#include "asm_i386.h"
-#include "quakeasm.h"
-#include "asm_draw.h"
-#include "d_ifacea.h"
-
-#if	id386
-
-// !!! if these are changed, they must be changed in r_draw.c too !!!
-#define FULLY_CLIPPED_CACHED	0x80000000
-#define FRAMECOUNT_MASK			0x7FFFFFFF
-
-	.data
-
-Ld0:			.single		0.0
-Ld1:			.single		0.0
-Lstack:			.long		0
-Lfp_near_clip:	.single		NEAR_CLIP
-Lceilv0:		.long		0
-Lv:				.long		0
-Lu0:			.long		0
-Lv0:			.long		0
-Lzi0:			.long		0
-
-	.text
-
-//----------------------------------------------------------------------
-// edge clipping code
-//----------------------------------------------------------------------
-
-#define pv0		4+12
-#define pv1		8+12
-#define clip	12+12
-
-	.align 4
-.globl C(R_ClipEdge)
-C(R_ClipEdge):
-	pushl	%esi				// preserve register variables
-	pushl	%edi
-	pushl	%ebx
-	movl	%esp,Lstack			// for clearing the stack later
-
-//	float		d0, d1, f;
-//	mvertex_t	clipvert;
-
-	movl	clip(%esp),%ebx
-	movl	pv0(%esp),%esi
-	movl	pv1(%esp),%edx
-
-//	if (clip)
-//	{
-	testl	%ebx,%ebx
-	jz		Lemit
-
-//		do
-//		{
-
-Lcliploop:
-
-//			d0 = DotProduct (pv0->position, clip->normal) - clip->dist;
-//			d1 = DotProduct (pv1->position, clip->normal) - clip->dist;
-	flds	mv_position+0(%esi)
-	fmuls	cp_normal+0(%ebx)
-	flds	mv_position+4(%esi)
-	fmuls	cp_normal+4(%ebx)
-	flds	mv_position+8(%esi)
-	fmuls	cp_normal+8(%ebx)
-	fxch	%st(1)
-	faddp	%st(0),%st(2)		// d0mul2 | d0add0
-
-	flds	mv_position+0(%edx)
-	fmuls	cp_normal+0(%ebx)
-	flds	mv_position+4(%edx)
-	fmuls	cp_normal+4(%ebx)
-	flds	mv_position+8(%edx)
-	fmuls	cp_normal+8(%ebx)
-	fxch	%st(1)
-	faddp	%st(0),%st(2)		// d1mul2 | d1add0 | d0mul2 | d0add0
-	fxch	%st(3)				// d0add0 | d1add0 | d0mul2 | d1mul2
-
-	faddp	%st(0),%st(2)		// d1add0 | dot0 | d1mul2 
-	faddp	%st(0),%st(2)		// dot0 | dot1
-
-	fsubs	cp_dist(%ebx)		// d0 | dot1
-	fxch	%st(1)				// dot1 | d0
-	fsubs	cp_dist(%ebx)		// d1 | d0
-	fxch	%st(1)
-	fstps	Ld0
-	fstps	Ld1
-
-//			if (d0 >= 0)
-//			{
-	movl	Ld0,%eax
-	movl	Ld1,%ecx
-	orl		%eax,%ecx
-	js		Lp2
-
-// both points are unclipped
-
-Lcontinue:
-
-//
-//				R_ClipEdge (&clipvert, pv1, clip->next);
-//				return;
-//			}
-//		} while ((clip = clip->next) != NULL);
-	movl	cp_next(%ebx),%ebx
-	testl	%ebx,%ebx
-	jnz		Lcliploop
-
-//	}
-
-//// add the edge
-//	R_EmitEdge (pv0, pv1);
-Lemit:
-
-//
-// set integer rounding to ceil mode, set to single precision
-//
-// FIXME: do away with by manually extracting integers from floats?
-// FIXME: set less often
-	fldcw	ceil_cw
-
-//	edge_t	*edge, *pcheck;
-//	int		u_check;
-//	float	u, u_step;
-//	vec3_t	local, transformed;
-//	float	*world;
-//	int		v, v2, ceilv0;
-//	float	scale, lzi0, u0, v0;
-//	int		side;
-
-//	if (r_lastvertvalid)
-//	{
-	cmpl	$0,C(r_lastvertvalid)
-	jz		LCalcFirst
-
-//		u0 = r_u1;
-//		v0 = r_v1;
-//		lzi0 = r_lzi1;
-//		ceilv0 = r_ceilv1;
-	movl	C(r_lzi1),%eax
-	movl	C(r_u1),%ecx
-	movl	%eax,Lzi0
-	movl	%ecx,Lu0
-	movl	C(r_v1),%ecx
-	movl	C(r_ceilv1),%eax
-	movl	%ecx,Lv0
-	movl	%eax,Lceilv0
-	jmp		LCalcSecond
-
-//	}
-
-LCalcFirst:
-
-//	else
-//	{
-//		world = &pv0->position[0];
-
-	call	LTransformAndProject	// v0 | lzi0 | u0
-
-	fsts	Lv0
-	fxch	%st(2)					// u0 | lzi0 | v0
-	fstps	Lu0						// lzi0 | v0
-	fstps	Lzi0					// v0
-
-//		ceilv0 = (int)(v0 - 2000) + 2000; // ceil(v0);
-	fistpl	Lceilv0
-
-//	}
-
-LCalcSecond:
-
-//	world = &pv1->position[0];
-	movl	%edx,%esi
-
-	call	LTransformAndProject	// v1 | lzi1 | u1
-
-	flds	Lu0						// u0 | v1 | lzi1 | u1
-	fxch	%st(3)					// u1 | v1 | lzi1 | u0
-	flds	Lzi0					// lzi0 | u1 | v1 | lzi1 | u0
-	fxch	%st(3)					// lzi1 | u1 | v1 | lzi0 | u0
-	flds	Lv0						// v0 | lzi1 | u1 | v1 | lzi0 | u0
-	fxch	%st(3)					// v1 | lzi1 | u1 | v0 | lzi0 | u0
-
-//	r_ceilv1 = (int)(r_v1 - 2000) + 2000; // ceil(r_v1);
-	fistl	C(r_ceilv1)
-
-	fldcw	single_cw				// put back normal floating-point state
-
-	fsts	C(r_v1)
-	fxch	%st(4)					// lzi0 | lzi1 | u1 | v0 | v1 | u0
-
-//	if (r_lzi1 > lzi0)
-//		lzi0 = r_lzi1;
-	fcom	%st(1)
-	fnstsw	%ax
-	testb	$1,%ah
-	jz		LP0
-	fstp	%st(0)
-	fld		%st(0)
-LP0:
-
-	fxch	%st(1)					// lzi1 | lzi0 | u1 | v0 | v1 | u0
-	fstps	C(r_lzi1)				// lzi0 | u1 | v0 | v1 | u0
-	fxch	%st(1)
-	fsts	C(r_u1)
-	fxch	%st(1)
-
-//	if (lzi0 > r_nearzi)	// for mipmap finding
-//		r_nearzi = lzi0;
-	fcoms	C(r_nearzi)
-	fnstsw	%ax
-	testb	$0x45,%ah
-	jnz		LP1
-	fsts	C(r_nearzi)
-LP1:
-
-// // for right edges, all we want is the effect on 1/z
-//	if (r_nearzionly)
-//		return;
-	movl	C(r_nearzionly),%eax
-	testl	%eax,%eax
-	jz		LP2
-LPop5AndDone:
-	movl	C(cacheoffset),%eax
-	movl	C(r_framecount),%edx
-	cmpl	$0x7FFFFFFF,%eax
-	jz		LDoPop
-	andl	$(FRAMECOUNT_MASK),%edx
-	orl		$(FULLY_CLIPPED_CACHED),%edx
-	movl	%edx,C(cacheoffset)
-
-LDoPop:
-	fstp	%st(0)			// u1 | v0 | v1 | u0
-	fstp	%st(0)			// v0 | v1 | u0
-	fstp	%st(0)			// v1 | u0
-	fstp	%st(0)			// u0
-	fstp	%st(0)
-	jmp		Ldone
-
-LP2:
-
-// // create the edge
-//	if (ceilv0 == r_ceilv1)
-//		return;		// horizontal edge
-	movl	Lceilv0,%ebx
-	movl	C(edge_p),%edi
-	movl	C(r_ceilv1),%ecx
-	movl	%edi,%edx
-	movl	C(r_pedge),%esi
-	addl	$(et_size),%edx
-	cmpl	%ecx,%ebx
-	jz		LPop5AndDone
-
-	movl	C(r_pedge),%eax
-	movl	%eax,et_owner(%edi)
-
-//	side = ceilv0 > r_ceilv1;
-//
-//	edge->nearzi = lzi0;
-	fstps	et_nearzi(%edi)		// u1 | v0 | v1 | u0
-
-//	if (side == 1)
-//	{
-	jc		LSide0
-
-LSide1:
-
-//	// leading edge (go from p2 to p1)
-
-//		u_step = ((u0 - r_u1) / (v0 - r_v1));
-	fsubrp	%st(0),%st(3)		// v0 | v1 | u0-u1
-	fsub	%st(1),%st(0)		// v0-v1 | v1 | u0-u1
-	fdivrp	%st(0),%st(2)		// v1 | ustep
-
-//	r_emitted = 1;
-	movl	$1,C(r_emitted)
-
-//	edge = edge_p++;
-	movl	%edx,C(edge_p)
-
-// pretouch next edge
-	movl	(%edx),%eax
-
-//		v2 = ceilv0 - 1;
-//		v = r_ceilv1;
-	movl	%ecx,%eax
-	leal	-1(%ebx),%ecx
-	movl	%eax,%ebx
-
-//		edge->surfs[0] = 0;
-//		edge->surfs[1] = surface_p - surfaces;
-	movl	C(surface_p),%eax
-	movl	C(surfaces),%esi
-	subl	%edx,%edx
-	subl	%esi,%eax
-	shrl	$(SURF_T_SHIFT),%eax
-	movl	%edx,et_surfs(%edi)
-	movl	%eax,et_surfs+2(%edi)
-
-	subl	%esi,%esi
-
-//		u = r_u1 + ((float)v - r_v1) * u_step;
-	movl	%ebx,Lv
-	fildl	Lv					// v | v1 | ustep
-	fsubp	%st(0),%st(1)		// v-v1 | ustep
-	fmul	%st(1),%st(0)		// (v-v1)*ustep | ustep
-	fadds	C(r_u1)				// u | ustep
-
-	jmp		LSideDone
-
-//	}
-
-LSide0:
-
-//	else
-//	{
-//	// trailing edge (go from p1 to p2)
-
-//		u_step = ((r_u1 - u0) / (r_v1 - v0));
-	fsub	%st(3),%st(0)		// u1-u0 | v0 | v1 | u0
-	fxch	%st(2)				// v1 | v0 | u1-u0 | u0
-	fsub	%st(1),%st(0)		// v1-v0 | v0 | u1-u0 | u0
-	fdivrp	%st(0),%st(2)		// v0 | ustep | u0
-
-//	r_emitted = 1;
-	movl	$1,C(r_emitted)
-
-//	edge = edge_p++;
-	movl	%edx,C(edge_p)
-
-// pretouch next edge
-	movl	(%edx),%eax
-
-//		v = ceilv0;
-//		v2 = r_ceilv1 - 1;
-	decl	%ecx
-
-//		edge->surfs[0] = surface_p - surfaces;
-//		edge->surfs[1] = 0;
-	movl	C(surface_p),%eax
-	movl	C(surfaces),%esi
-	subl	%edx,%edx
-	subl	%esi,%eax
-	shrl	$(SURF_T_SHIFT),%eax
-	movl	%edx,et_surfs+2(%edi)
-	movl	%eax,et_surfs(%edi)
-
-	movl	$1,%esi
-
-//		u = u0 + ((float)v - v0) * u_step;
-	movl	%ebx,Lv
-	fildl	Lv					// v | v0 | ustep | u0
-	fsubp	%st(0),%st(1)		// v-v0 | ustep | u0
-	fmul	%st(1),%st(0)		// (v-v0)*ustep | ustep | u0
-	faddp	%st(0),%st(2)		// ustep | u
-	fxch	%st(1)				// u | ustep
-
-//	}
-
-LSideDone:
-
-//	edge->u_step = u_step*0x100000;
-//	edge->u = u*0x100000 + 0xFFFFF;
-
-	fmuls	fp_1m				// u*0x100000 | ustep
-	fxch	%st(1)				// ustep | u*0x100000
-	fmuls	fp_1m				// ustep*0x100000 | u*0x100000
-	fxch	%st(1)				// u*0x100000 | ustep*0x100000
-	fadds	fp_1m_minus_1		// u*0x100000 + 0xFFFFF | ustep*0x100000
-	fxch	%st(1)				// ustep*0x100000 | u*0x100000 + 0xFFFFF
-	fistpl	et_u_step(%edi)		// u*0x100000 + 0xFFFFF
-	fistpl	et_u(%edi)
-
-// // we need to do this to avoid stepping off the edges if a very nearly
-// // horizontal edge is less than epsilon above a scan, and numeric error
-// // causes it to incorrectly extend to the scan, and the extension of the
-// // line goes off the edge of the screen
-// // FIXME: is this actually needed?
-//	if (edge->u < r_refdef.vrect_x_adj_shift20)
-//		edge->u = r_refdef.vrect_x_adj_shift20;
-//	if (edge->u > r_refdef.vrectright_adj_shift20)
-//		edge->u = r_refdef.vrectright_adj_shift20;
-	movl	et_u(%edi),%eax
-	movl	C(r_refdef)+rd_vrect_x_adj_shift20,%edx
-	cmpl	%edx,%eax
-	jl		LP4
-	movl	C(r_refdef)+rd_vrectright_adj_shift20,%edx
-	cmpl	%edx,%eax
-	jng		LP5
-LP4:
-	movl	%edx,et_u(%edi)
-	movl	%edx,%eax
-LP5:
-
-// // sort the edge in normally
-//	u_check = edge->u;
-//
-//	if (edge->surfs[0])
-//		u_check++;	// sort trailers after leaders
-	addl	%esi,%eax
-
-//	if (!newedges[v] || newedges[v]->u >= u_check)
-//	{
-	movl	C(newedges)(,%ebx,4),%esi
-	testl	%esi,%esi
-	jz		LDoFirst
-	cmpl	%eax,et_u(%esi)
-	jl		LNotFirst
-LDoFirst:
-
-//		edge->next = newedges[v];
-//		newedges[v] = edge;
-	movl	%esi,et_next(%edi)
-	movl	%edi,C(newedges)(,%ebx,4)
-
-	jmp		LSetRemove
-
-//	}
-
-LNotFirst:
-
-//	else
-//	{
-//		pcheck = newedges[v];
-//
-//		while (pcheck->next && pcheck->next->u < u_check)
-//			pcheck = pcheck->next;
-LFindInsertLoop:
-	movl	%esi,%edx
-	movl	et_next(%esi),%esi
-	testl	%esi,%esi
-	jz		LInsertFound
-	cmpl	%eax,et_u(%esi)
-	jl		LFindInsertLoop
-
-LInsertFound:
-
-//		edge->next = pcheck->next;
-//		pcheck->next = edge;
-	movl	%esi,et_next(%edi)
-	movl	%edi,et_next(%edx)
-
-//	}
-
-LSetRemove:
-
-//	edge->nextremove = removeedges[v2];
-//	removeedges[v2] = edge;
-	movl	C(removeedges)(,%ecx,4),%eax
-	movl	%edi,C(removeedges)(,%ecx,4)
-	movl	%eax,et_nextremove(%edi)
-
-Ldone:
-	movl	Lstack,%esp			// clear temporary variables from stack
-
-	popl	%ebx				// restore register variables
-	popl	%edi
-	popl	%esi
-	ret
-
-// at least one point is clipped
-
-Lp2:
-	testl	%eax,%eax
-	jns		Lp1
-
-//			else
-//			{
-//			// point 0 is clipped
-
-//				if (d1 < 0)
-//				{
-	movl	Ld1,%eax
-	testl	%eax,%eax
-	jns		Lp3
-
-//				// both points are clipped
-//				// we do cache fully clipped edges
-//					if (!leftclipped)
-	movl	C(r_leftclipped),%eax
-	movl	C(r_pedge),%ecx
-	testl	%eax,%eax
-	jnz		Ldone
-
-//						r_pedge->framecount = r_framecount;
-	movl	C(r_framecount),%eax
-	andl	$(FRAMECOUNT_MASK),%eax
-	orl		$(FULLY_CLIPPED_CACHED),%eax
-	movl	%eax,C(cacheoffset)
-
-//					return;
-	jmp		Ldone
-
-//				}
-
-Lp1:
-
-//			// point 0 is unclipped
-//				if (d1 >= 0)
-//				{
-//				// both points are unclipped
-//					continue;
-
-//			// only point 1 is clipped
-
-//				f = d0 / (d0 - d1);
-	flds	Ld0
-	flds	Ld1
-	fsubr	%st(1),%st(0)
-
-//			// we don't cache partially clipped edges
-	movl	$0x7FFFFFFF,C(cacheoffset)
-
-	fdivrp	%st(0),%st(1)
-
-	subl	$(mv_size),%esp			// allocate space for clipvert
-
-//				clipvert.position[0] = pv0->position[0] +
-//						f * (pv1->position[0] - pv0->position[0]);
-//				clipvert.position[1] = pv0->position[1] +
-//						f * (pv1->position[1] - pv0->position[1]);
-//				clipvert.position[2] = pv0->position[2] +
-//						f * (pv1->position[2] - pv0->position[2]);
-	flds	mv_position+8(%edx)
-	fsubs	mv_position+8(%esi)
-	flds	mv_position+4(%edx)
-	fsubs	mv_position+4(%esi)
-	flds	mv_position+0(%edx)
-	fsubs	mv_position+0(%esi)		// 0 | 1 | 2
-
-// replace pv1 with the clip point
-	movl	%esp,%edx
-	movl	cp_leftedge(%ebx),%eax
-	testb	%al,%al
-
-	fmul	%st(3),%st(0)
-	fxch	%st(1)					// 1 | 0 | 2
-	fmul	%st(3),%st(0)
-	fxch	%st(2)					// 2 | 0 | 1
-	fmulp	%st(0),%st(3)			// 0 | 1 | 2
-	fadds	mv_position+0(%esi)
-	fxch	%st(1)					// 1 | 0 | 2
-	fadds	mv_position+4(%esi)
-	fxch	%st(2)					// 2 | 0 | 1
-	fadds	mv_position+8(%esi)
-	fxch	%st(1)					// 0 | 2 | 1
-	fstps	mv_position+0(%esp)		// 2 | 1
-	fstps	mv_position+8(%esp)		// 1
-	fstps	mv_position+4(%esp)
-
-//				if (clip->leftedge)
-//				{
-	jz		Ltestright
-
-//					r_leftclipped = true;
-//					r_leftexit = clipvert;
-	movl	$1,C(r_leftclipped)
-	movl	mv_position+0(%esp),%eax
-	movl	%eax,C(r_leftexit)+mv_position+0
-	movl	mv_position+4(%esp),%eax
-	movl	%eax,C(r_leftexit)+mv_position+4
-	movl	mv_position+8(%esp),%eax
-	movl	%eax,C(r_leftexit)+mv_position+8
-
-	jmp		Lcontinue
-
-//				}
-
-Ltestright:
-//				else if (clip->rightedge)
-//				{
-	testb	%ah,%ah
-	jz		Lcontinue
-
-//					r_rightclipped = true;
-//					r_rightexit = clipvert;
-	movl	$1,C(r_rightclipped)
-	movl	mv_position+0(%esp),%eax
-	movl	%eax,C(r_rightexit)+mv_position+0
-	movl	mv_position+4(%esp),%eax
-	movl	%eax,C(r_rightexit)+mv_position+4
-	movl	mv_position+8(%esp),%eax
-	movl	%eax,C(r_rightexit)+mv_position+8
-
-//				}
-//
-//				R_ClipEdge (pv0, &clipvert, clip->next);
-//				return;
-//			}
-	jmp		Lcontinue
-
-//			}
-
-Lp3:
-
-//			// only point 0 is clipped
-//				r_lastvertvalid = false;
-
-	movl	$0,C(r_lastvertvalid)
-
-//				f = d0 / (d0 - d1);
-	flds	Ld0
-	flds	Ld1
-	fsubr	%st(1),%st(0)
-
-//			// we don't cache partially clipped edges
-	movl	$0x7FFFFFFF,C(cacheoffset)
-
-	fdivrp	%st(0),%st(1)
-
-	subl	$(mv_size),%esp			// allocate space for clipvert
-
-//				clipvert.position[0] = pv0->position[0] +
-//						f * (pv1->position[0] - pv0->position[0]);
-//				clipvert.position[1] = pv0->position[1] +
-//						f * (pv1->position[1] - pv0->position[1]);
-//				clipvert.position[2] = pv0->position[2] +
-//						f * (pv1->position[2] - pv0->position[2]);
-	flds	mv_position+8(%edx)
-	fsubs	mv_position+8(%esi)
-	flds	mv_position+4(%edx)
-	fsubs	mv_position+4(%esi)
-	flds	mv_position+0(%edx)
-	fsubs	mv_position+0(%esi)		// 0 | 1 | 2
-
-	movl	cp_leftedge(%ebx),%eax
-	testb	%al,%al
-
-	fmul	%st(3),%st(0)
-	fxch	%st(1)					// 1 | 0 | 2
-	fmul	%st(3),%st(0)
-	fxch	%st(2)					// 2 | 0 | 1
-	fmulp	%st(0),%st(3)			// 0 | 1 | 2
-	fadds	mv_position+0(%esi)
-	fxch	%st(1)					// 1 | 0 | 2
-	fadds	mv_position+4(%esi)
-	fxch	%st(2)					// 2 | 0 | 1
-	fadds	mv_position+8(%esi)
-	fxch	%st(1)					// 0 | 2 | 1
-	fstps	mv_position+0(%esp)		// 2 | 1
-	fstps	mv_position+8(%esp)		// 1
-	fstps	mv_position+4(%esp)
-
-// replace pv0 with the clip point
-	movl	%esp,%esi
-
-//				if (clip->leftedge)
-//				{
-	jz		Ltestright2
-
-//					r_leftclipped = true;
-//					r_leftenter = clipvert;
-	movl	$1,C(r_leftclipped)
-	movl	mv_position+0(%esp),%eax
-	movl	%eax,C(r_leftenter)+mv_position+0
-	movl	mv_position+4(%esp),%eax
-	movl	%eax,C(r_leftenter)+mv_position+4
-	movl	mv_position+8(%esp),%eax
-	movl	%eax,C(r_leftenter)+mv_position+8
-
-	jmp		Lcontinue
-
-//				}
-
-Ltestright2:
-//				else if (clip->rightedge)
-//				{
-	testb	%ah,%ah
-	jz		Lcontinue
-
-//					r_rightclipped = true;
-//					r_rightenter = clipvert;
-	movl	$1,C(r_rightclipped)
-	movl	mv_position+0(%esp),%eax
-	movl	%eax,C(r_rightenter)+mv_position+0
-	movl	mv_position+4(%esp),%eax
-	movl	%eax,C(r_rightenter)+mv_position+4
-	movl	mv_position+8(%esp),%eax
-	movl	%eax,C(r_rightenter)+mv_position+8
-
-//				}
-	jmp		Lcontinue
-
-// %esi = vec3_t point to transform and project
-// %edx preserved
-LTransformAndProject:
-
-//	// transform and project
-//		VectorSubtract (world, modelorg, local);
-	flds	mv_position+0(%esi)
-	fsubs	C(modelorg)+0
-	flds	mv_position+4(%esi)
-	fsubs	C(modelorg)+4
-	flds	mv_position+8(%esi)	
-	fsubs	C(modelorg)+8
-	fxch	%st(2)				// local[0] | local[1] | local[2]
-
-//		TransformVector (local, transformed);
-//	
-//		if (transformed[2] < NEAR_CLIP)
-//			transformed[2] = NEAR_CLIP;
-//	
-//		lzi0 = 1.0 / transformed[2];
-	fld		%st(0)				// local[0] | local[0] | local[1] | local[2]
-	fmuls	C(vpn)+0			// zm0 | local[0] | local[1] | local[2]
-	fld		%st(1)				// local[0] | zm0 | local[0] | local[1] |
-								//  local[2]
-	fmuls	C(vright)+0			// xm0 | zm0 | local[0] | local[1] | local[2]
-	fxch	%st(2)				// local[0] | zm0 | xm0 | local[1] | local[2]
-	fmuls	C(vup)+0			// ym0 |  zm0 | xm0 | local[1] | local[2]
-	fld		%st(3)				// local[1] | ym0 |  zm0 | xm0 | local[1] |
-								//  local[2]
-	fmuls	C(vpn)+4			// zm1 | ym0 | zm0 | xm0 | local[1] |
-								//  local[2]
-	fld		%st(4)				// local[1] | zm1 | ym0 | zm0 | xm0 |
-								//  local[1] | local[2]
-	fmuls	C(vright)+4			// xm1 | zm1 | ym0 |  zm0 | xm0 |
-								//  local[1] | local[2]
-	fxch	%st(5)				// local[1] | zm1 | ym0 | zm0 | xm0 |
-								//  xm1 | local[2]
-	fmuls	C(vup)+4			// ym1 | zm1 | ym0 | zm0 | xm0 |
-								//  xm1 | local[2]
-	fxch	%st(1)				// zm1 | ym1 | ym0 | zm0 | xm0 |
-								//  xm1 | local[2]
-	faddp	%st(0),%st(3)		// ym1 | ym0 | zm2 | xm0 | xm1 | local[2]
-	fxch	%st(3)				// xm0 | ym0 | zm2 | ym1 | xm1 | local[2]
-	faddp	%st(0),%st(4)		// ym0 | zm2 | ym1 | xm2 | local[2]
-	faddp	%st(0),%st(2)		// zm2 | ym2 | xm2 | local[2]
-	fld		%st(3)				// local[2] | zm2 | ym2 | xm2 | local[2]
-	fmuls	C(vpn)+8			// zm3 | zm2 | ym2 | xm2 | local[2]
-	fld		%st(4)				// local[2] | zm3 | zm2 | ym2 | xm2 | local[2]
-	fmuls	C(vright)+8			// xm3 | zm3 | zm2 | ym2 | xm2 | local[2]
-	fxch	%st(5)				// local[2] | zm3 | zm2 | ym2 | xm2 | xm3
-	fmuls	C(vup)+8			// ym3 | zm3 | zm2 | ym2 | xm2 | xm3
-	fxch	%st(1)				// zm3 | ym3 | zm2 | ym2 | xm2 | xm3
-	faddp	%st(0),%st(2)		// ym3 | zm4 | ym2 | xm2 | xm3
-	fxch	%st(4)				// xm3 | zm4 | ym2 | xm2 | ym3
-	faddp	%st(0),%st(3)		// zm4 | ym2 | xm4 | ym3
-	fxch	%st(1)				// ym2 | zm4 | xm4 | ym3
-	faddp	%st(0),%st(3)		// zm4 | xm4 | ym4
-
-	fcoms	Lfp_near_clip
-	fnstsw	%ax
-	testb	$1,%ah
-	jz		LNoClip
-	fstp	%st(0)
-	flds	Lfp_near_clip
-
-LNoClip:
-
-	fdivrs	float_1				// lzi0 | x | y
-	fxch	%st(1)				// x | lzi0 | y
-
-//	// FIXME: build x/yscale into transform?
-//		scale = xscale * lzi0;
-//		u0 = (xcenter + scale*transformed[0]);
-	flds	C(xscale)			// xscale | x | lzi0 | y
-	fmul	%st(2),%st(0)		// scale | x | lzi0 | y
-	fmulp	%st(0),%st(1)		// scale*x | lzi0 | y
-	fadds	C(xcenter)			// u0 | lzi0 | y
-
-//		if (u0 < r_refdef.fvrectx_adj)
-//			u0 = r_refdef.fvrectx_adj;
-//		if (u0 > r_refdef.fvrectright_adj)
-//			u0 = r_refdef.fvrectright_adj;
-// FIXME: use integer compares of floats?
-	fcoms	C(r_refdef)+rd_fvrectx_adj
-	fnstsw	%ax
-	testb	$1,%ah
-	jz		LClampP0
-	fstp	%st(0)
-	flds	C(r_refdef)+rd_fvrectx_adj
-LClampP0:
-	fcoms	C(r_refdef)+rd_fvrectright_adj
-	fnstsw	%ax
-	testb	$0x45,%ah
-	jnz		LClampP1
-	fstp	%st(0)
-	flds	C(r_refdef)+rd_fvrectright_adj
-LClampP1:
-
-	fld		%st(1)				// lzi0 | u0 | lzi0 | y
-
-//		scale = yscale * lzi0;
-//		v0 = (ycenter - scale*transformed[1]);
-	fmuls	C(yscale)			// scale | u0 | lzi0 | y
-	fmulp	%st(0),%st(3)		// u0 | lzi0 | scale*y
-	fxch	%st(2)				// scale*y | lzi0 | u0
-	fsubrs	C(ycenter)			// v0 | lzi0 | u0
-
-//		if (v0 < r_refdef.fvrecty_adj)
-//			v0 = r_refdef.fvrecty_adj;
-//		if (v0 > r_refdef.fvrectbottom_adj)
-//			v0 = r_refdef.fvrectbottom_adj;
-// FIXME: use integer compares of floats?
-	fcoms	C(r_refdef)+rd_fvrecty_adj
-	fnstsw	%ax
-	testb	$1,%ah
-	jz		LClampP2
-	fstp	%st(0)
-	flds	C(r_refdef)+rd_fvrecty_adj
-LClampP2:
-	fcoms	C(r_refdef)+rd_fvrectbottom_adj
-	fnstsw	%ax
-	testb	$0x45,%ah
-	jnz		LClampP3
-	fstp	%st(0)
-	flds	C(r_refdef)+rd_fvrectbottom_adj
-LClampP3:
-	ret
-
-#endif	// id386
-
diff -ruN WinQuake/r_edgea.S sdlquake-1.0.9/r_edgea.S
--- WinQuake/r_edgea.S	Wed Dec 31 16:00:00 1969
+++ sdlquake-1.0.9/r_edgea.S	Sat Dec 25 03:38:03 1999
@@ -0,0 +1,750 @@
+/*
+Copyright (C) 1996-1997 Id Software, Inc.
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation; either version 2
+of the License, or (at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
+
+See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+//
+// r_edgea.s
+// x86 assembly-language edge-processing code.
+//
+
+#include "asm_i386.h"
+#include "quakeasm.h"
+#include "asm_draw.h"
+
+#if	id386
+
+	.data
+Ltemp:					.long	0
+float_1_div_0100000h:	.long	0x35800000	// 1.0/(float)0x100000
+float_point_999:		.single	0.999
+float_1_point_001:		.single	1.001
+
+	.text
+
+//--------------------------------------------------------------------
+
+#define edgestoadd	4+8		// note odd stack offsets because of interleaving
+#define edgelist	8+12	// with pushes
+
+.globl C(R_EdgeCodeStart)
+C(R_EdgeCodeStart):
+
+.globl C(R_InsertNewEdges)
+C(R_InsertNewEdges):
+	pushl	%edi
+	pushl	%esi				// preserve register variables
+	movl	edgestoadd(%esp),%edx
+	pushl	%ebx
+	movl	edgelist(%esp),%ecx
+
+LDoNextEdge:
+	movl	et_u(%edx),%eax
+	movl	%edx,%edi
+
+LContinueSearch:
+	movl	et_u(%ecx),%ebx
+	movl	et_next(%ecx),%esi
+	cmpl	%ebx,%eax
+	jle		LAddedge
+	movl	et_u(%esi),%ebx
+	movl	et_next(%esi),%ecx
+	cmpl	%ebx,%eax
+	jle		LAddedge2
+	movl	et_u(%ecx),%ebx
+	movl	et_next(%ecx),%esi
+	cmpl	%ebx,%eax
+	jle		LAddedge
+	movl	et_u(%esi),%ebx
+	movl	et_next(%esi),%ecx
+	cmpl	%ebx,%eax
+	jg		LContinueSearch
+
+LAddedge2:
+	movl	et_next(%edx),%edx
+	movl	et_prev(%esi),%ebx
+	movl	%esi,et_next(%edi)
+	movl	%ebx,et_prev(%edi)
+	movl	%edi,et_next(%ebx)
+	movl	%edi,et_prev(%esi)
+	movl	%esi,%ecx
+
+	cmpl	$0,%edx
+	jnz		LDoNextEdge
+	jmp		LDone
+
+	.align 4
+LAddedge:
+	movl	et_next(%edx),%edx
+	movl	et_prev(%ecx),%ebx
+	movl	%ecx,et_next(%edi)
+	movl	%ebx,et_prev(%edi)
+	movl	%edi,et_next(%ebx)
+	movl	%edi,et_prev(%ecx)
+
+	cmpl	$0,%edx
+	jnz		LDoNextEdge
+
+LDone:
+	popl	%ebx				// restore register variables
+	popl	%esi
+	popl	%edi
+
+	ret
+
+//--------------------------------------------------------------------
+
+#define predge	4+4
+
+.globl C(R_RemoveEdges)
+C(R_RemoveEdges):
+	pushl	%ebx
+	movl	predge(%esp),%eax
+
+Lre_loop:
+	movl	et_next(%eax),%ecx
+	movl	et_nextremove(%eax),%ebx
+	movl	et_prev(%eax),%edx
+	testl	%ebx,%ebx
+	movl	%edx,et_prev(%ecx)
+	jz		Lre_done
+	movl	%ecx,et_next(%edx)
+
+	movl	et_next(%ebx),%ecx
+	movl	et_prev(%ebx),%edx
+	movl	et_nextremove(%ebx),%eax
+	movl	%edx,et_prev(%ecx)
+	testl	%eax,%eax
+	movl	%ecx,et_next(%edx)
+	jnz		Lre_loop
+
+	popl	%ebx
+	ret
+
+Lre_done:
+	movl	%ecx,et_next(%edx)
+	popl	%ebx
+
+	ret
+
+//--------------------------------------------------------------------
+
+#define pedgelist	4+4		// note odd stack offset because of interleaving
+							// with pushes
+
+.globl C(R_StepActiveU)
+C(R_StepActiveU):
+	pushl	%edi
+	movl	pedgelist(%esp),%edx
+	pushl	%esi				// preserve register variables
+	pushl	%ebx
+
+	movl	et_prev(%edx),%esi
+
+LNewEdge:
+	movl	et_u(%esi),%edi
+
+LNextEdge:
+	movl	et_u(%edx),%eax
+	movl	et_u_step(%edx),%ebx
+	addl	%ebx,%eax
+	movl	et_next(%edx),%esi
+	movl	%eax,et_u(%edx)
+	cmpl	%edi,%eax
+	jl		LPushBack
+
+	movl	et_u(%esi),%edi
+	movl	et_u_step(%esi),%ebx
+	addl	%ebx,%edi
+	movl	et_next(%esi),%edx
+	movl	%edi,et_u(%esi)
+	cmpl	%eax,%edi
+	jl		LPushBack2
+
+	movl	et_u(%edx),%eax
+	movl	et_u_step(%edx),%ebx
+	addl	%ebx,%eax
+	movl	et_next(%edx),%esi
+	movl	%eax,et_u(%edx)
+	cmpl	%edi,%eax
+	jl		LPushBack
+
+	movl	et_u(%esi),%edi
+	movl	et_u_step(%esi),%ebx
+	addl	%ebx,%edi
+	movl	et_next(%esi),%edx
+	movl	%edi,et_u(%esi)
+	cmpl	%eax,%edi
+	jnl		LNextEdge
+
+LPushBack2:
+	movl	%edx,%ebx
+	movl	%edi,%eax
+	movl	%esi,%edx
+	movl	%ebx,%esi
+
+LPushBack:
+// push it back to keep it sorted
+	movl	et_prev(%edx),%ecx
+	movl	et_next(%edx),%ebx
+
+// done if the -1 in edge_aftertail triggered this
+	cmpl	$(C(edge_aftertail)),%edx
+	jz		LUDone
+
+// pull the edge out of the edge list
+	movl	et_prev(%ecx),%edi
+	movl	%ecx,et_prev(%esi)
+	movl	%ebx,et_next(%ecx)
+
+// find out where the edge goes in the edge list
+LPushBackLoop:
+	movl	et_prev(%edi),%ecx
+	movl	et_u(%edi),%ebx
+	cmpl	%ebx,%eax
+	jnl		LPushBackFound
+
+	movl	et_prev(%ecx),%edi
+	movl	et_u(%ecx),%ebx
+	cmpl	%ebx,%eax
+	jl		LPushBackLoop
+
+	movl	%ecx,%edi
+
+// put the edge back into the edge list
+LPushBackFound:
+	movl	et_next(%edi),%ebx
+	movl	%edi,et_prev(%edx)
+	movl	%ebx,et_next(%edx)
+	movl	%edx,et_next(%edi)
+	movl	%edx,et_prev(%ebx)
+
+	movl	%esi,%edx
+	movl	et_prev(%esi),%esi
+
+	cmpl	$(C(edge_tail)),%edx
+	jnz		LNewEdge
+
+LUDone:
+	popl	%ebx				// restore register variables
+	popl	%esi
+	popl	%edi
+
+	ret
+
+//--------------------------------------------------------------------
+
+#define surf	4		// note this is loaded before any pushes
+
+	.align 4
+TrailingEdge:
+	movl	st_spanstate(%esi),%eax	// check for edge inversion
+	decl	%eax
+	jnz		LInverted
+
+	movl	%eax,st_spanstate(%esi)
+	movl	st_insubmodel(%esi),%ecx
+	movl	0x12345678,%edx		// surfaces[1].st_next
+LPatch0:
+	movl	C(r_bmodelactive),%eax
+	subl	%ecx,%eax
+	cmpl	%esi,%edx
+	movl	%eax,C(r_bmodelactive)
+	jnz		LNoEmit				// surface isn't on top, just remove
+
+// emit a span (current top going away)
+	movl	et_u(%ebx),%eax
+	shrl	$20,%eax				// iu = integral pixel u
+	movl	st_last_u(%esi),%edx
+	movl	st_next(%esi),%ecx
+	cmpl	%edx,%eax
+	jle		LNoEmit2				// iu <= surf->last_u, so nothing to emit
+
+	movl	%eax,st_last_u(%ecx)	// surf->next->last_u = iu;
+	subl	%edx,%eax
+	movl	%edx,espan_t_u(%ebp)		// span->u = surf->last_u;
+
+	movl	%eax,espan_t_count(%ebp)	// span->count = iu - span->u;
+	movl	C(current_iv),%eax
+	movl	%eax,espan_t_v(%ebp)		// span->v = current_iv;
+	movl	st_spans(%esi),%eax
+	movl	%eax,espan_t_pnext(%ebp)	// span->pnext = surf->spans;
+	movl	%ebp,st_spans(%esi)			// surf->spans = span;
+	addl	$(espan_t_size),%ebp
+
+	movl	st_next(%esi),%edx		// remove the surface from the surface
+	movl	st_prev(%esi),%esi		// stack
+
+	movl	%edx,st_next(%esi)
+	movl	%esi,st_prev(%edx)
+	ret
+
+LNoEmit2:
+	movl	%eax,st_last_u(%ecx)	// surf->next->last_u = iu;
+	movl	st_next(%esi),%edx		// remove the surface from the surface
+	movl	st_prev(%esi),%esi		// stack
+
+	movl	%edx,st_next(%esi)
+	movl	%esi,st_prev(%edx)
+	ret
+
+LNoEmit:
+	movl	st_next(%esi),%edx		// remove the surface from the surface
+	movl	st_prev(%esi),%esi		// stack
+
+	movl	%edx,st_next(%esi)
+	movl	%esi,st_prev(%edx)
+	ret
+
+LInverted:
+	movl	%eax,st_spanstate(%esi)
+	ret
+
+//--------------------------------------------------------------------
+
+// trailing edge only
+Lgs_trailing:
+	pushl	$Lgs_nextedge
+	jmp		TrailingEdge
+
+
+.globl C(R_GenerateSpans)
+C(R_GenerateSpans):
+	pushl	%ebp				// preserve caller's stack frame
+	pushl	%edi
+	pushl	%esi				// preserve register variables
+	pushl	%ebx
+
+// clear active surfaces to just the background surface
+	movl	C(surfaces),%eax
+	movl	C(edge_head_u_shift20),%edx
+	addl	$(st_size),%eax
+// %ebp = span_p throughout
+	movl	C(span_p),%ebp
+
+	movl	$0,C(r_bmodelactive)
+
+	movl	%eax,st_next(%eax)
+	movl	%eax,st_prev(%eax)
+	movl	%edx,st_last_u(%eax)
+	movl	C(edge_head)+et_next,%ebx		// edge=edge_head.next
+
+// generate spans
+	cmpl	$(C(edge_tail)),%ebx		// done if empty list
+	jz		Lgs_lastspan
+
+Lgs_edgeloop:
+
+	movl	et_surfs(%ebx),%edi
+	movl	C(surfaces),%eax
+	movl	%edi,%esi
+	andl	$0xFFFF0000,%edi
+	andl	$0xFFFF,%esi
+	jz		Lgs_leading		// not a trailing edge
+
+// it has a left surface, so a surface is going away for this span
+	shll	$(SURF_T_SHIFT),%esi
+	addl	%eax,%esi
+	testl	%edi,%edi
+	jz		Lgs_trailing
+
+// both leading and trailing
+	call	TrailingEdge
+	movl	C(surfaces),%eax
+
+// ---------------------------------------------------------------
+// handle a leading edge
+// ---------------------------------------------------------------
+
+Lgs_leading:
+	shrl	$16-SURF_T_SHIFT,%edi
+	movl	C(surfaces),%eax
+	addl	%eax,%edi
+	movl	0x12345678,%esi		// surf2 = surfaces[1].next;
+LPatch2:
+	movl	st_spanstate(%edi),%edx
+	movl	st_insubmodel(%edi),%eax
+	testl	%eax,%eax
+	jnz		Lbmodel_leading
+
+// handle a leading non-bmodel edge
+
+// don't start a span if this is an inverted span, with the end edge preceding
+// the start edge (that is, we've already seen the end edge)
+	testl	%edx,%edx
+	jnz		Lxl_done
+
+
+// if (surf->key < surf2->key)
+//		goto newtop;
+	incl	%edx
+	movl	st_key(%edi),%eax
+	movl	%edx,st_spanstate(%edi)
+	movl	st_key(%esi),%ecx
+	cmpl	%ecx,%eax
+	jl		Lnewtop
+
+// main sorting loop to search through surface stack until insertion point
+// found. Always terminates because background surface is sentinel
+// do
+// {
+// 		surf2 = surf2->next;
+// } while (surf->key >= surf2->key);
+Lsortloopnb:
+	movl	st_next(%esi),%esi
+	movl	st_key(%esi),%ecx
+	cmpl	%ecx,%eax
+	jge		Lsortloopnb
+
+	jmp		LInsertAndExit
+
+
+// handle a leading bmodel edge
+	.align	4
+Lbmodel_leading:
+
+// don't start a span if this is an inverted span, with the end edge preceding
+// the start edge (that is, we've already seen the end edge)
+	testl	%edx,%edx
+	jnz		Lxl_done
+
+	movl	C(r_bmodelactive),%ecx
+	incl	%edx
+	incl	%ecx
+	movl	%edx,st_spanstate(%edi)
+	movl	%ecx,C(r_bmodelactive)
+
+// if (surf->key < surf2->key)
+//		goto newtop;
+	movl	st_key(%edi),%eax
+	movl	st_key(%esi),%ecx
+	cmpl	%ecx,%eax
+	jl		Lnewtop
+
+// if ((surf->key == surf2->key) && surf->insubmodel)
+// {
+	jz		Lzcheck_for_newtop
+
+// main sorting loop to search through surface stack until insertion point
+// found. Always terminates because background surface is sentinel
+// do
+// {
+// 		surf2 = surf2->next;
+// } while (surf->key > surf2->key);
+Lsortloop:
+	movl	st_next(%esi),%esi
+	movl	st_key(%esi),%ecx
+	cmpl	%ecx,%eax
+	jg		Lsortloop
+
+	jne		LInsertAndExit
+
+// Do 1/z sorting to see if we've arrived in the right position
+	movl	et_u(%ebx),%eax
+	subl	$0xFFFFF,%eax
+	movl	%eax,Ltemp
+	fildl	Ltemp
+
+	fmuls	float_1_div_0100000h // fu = (float)(edge->u - 0xFFFFF) *
+								//      (1.0 / 0x100000);
+
+	fld		%st(0)				// fu | fu
+	fmuls	st_d_zistepu(%edi)	// fu*surf->d_zistepu | fu
+	flds	C(fv)					// fv | fu*surf->d_zistepu | fu
+	fmuls	st_d_zistepv(%edi)	// fv*surf->d_zistepv | fu*surf->d_zistepu | fu
+	fxch	%st(1)				// fu*surf->d_zistepu | fv*surf->d_zistepv | fu
+	fadds	st_d_ziorigin(%edi)	// fu*surf->d_zistepu + surf->d_ziorigin |
+								//  fv*surf->d_zistepv | fu
+
+	flds	st_d_zistepu(%esi)	// surf2->d_zistepu |
+								//  fu*surf->d_zistepu + surf->d_ziorigin |
+								//  fv*surf->d_zistepv | fu
+	fmul	%st(3),%st(0)		// fu*surf2->d_zistepu |
+								//  fu*surf->d_zistepu + surf->d_ziorigin |
+								//  fv*surf->d_zistepv | fu
+	fxch	%st(1)				// fu*surf->d_zistepu + surf->d_ziorigin |
+								//  fu*surf2->d_zistepu |
+								//  fv*surf->d_zistepv | fu
+	faddp	%st(0),%st(2)		// fu*surf2->d_zistepu | newzi | fu
+
+	flds	C(fv)					// fv | fu*surf2->d_zistepu | newzi | fu
+	fmuls	st_d_zistepv(%esi)	// fv*surf2->d_zistepv |
+								//  fu*surf2->d_zistepu | newzi | fu
+	fld		%st(2)				// newzi | fv*surf2->d_zistepv |
+								//  fu*surf2->d_zistepu | newzi | fu
+	fmuls	float_point_999		// newzibottom | fv*surf2->d_zistepv |
+								//  fu*surf2->d_zistepu | newzi | fu
+
+	fxch	%st(2)				// fu*surf2->d_zistepu | fv*surf2->d_zistepv |
+								//  newzibottom | newzi | fu
+	fadds	st_d_ziorigin(%esi)	// fu*surf2->d_zistepu + surf2->d_ziorigin |
+								//  fv*surf2->d_zistepv | newzibottom | newzi |
+								//  fu
+	faddp	%st(0),%st(1)		// testzi | newzibottom | newzi | fu
+	fxch	%st(1)				// newzibottom | testzi | newzi | fu
+
+// if (newzibottom >= testzi)
+//     goto Lgotposition;
+
+	fcomp	%st(1)				// testzi | newzi | fu
+
+	fxch	%st(1)				// newzi | testzi | fu
+	fmuls	float_1_point_001	// newzitop | testzi | fu
+	fxch	%st(1)				// testzi | newzitop | fu
+
+	fnstsw	%ax
+	testb	$0x01,%ah
+	jz		Lgotposition_fpop3
+
+// if (newzitop >= testzi)
+// {
+
+	fcomp	%st(1)				// newzitop | fu
+	fnstsw	%ax
+	testb	$0x45,%ah
+	jz		Lsortloop_fpop2
+
+// if (surf->d_zistepu >= surf2->d_zistepu)
+//     goto newtop;
+
+	flds	st_d_zistepu(%edi)	// surf->d_zistepu | newzitop| fu
+	fcomps	st_d_zistepu(%esi)	// newzitop | fu
+	fnstsw	%ax
+	testb	$0x01,%ah
+	jz		Lgotposition_fpop2
+
+	fstp	%st(0)				// clear the FPstack
+	fstp	%st(0)
+	movl	st_key(%edi),%eax
+	jmp		Lsortloop
+
+
+Lgotposition_fpop3:
+	fstp	%st(0)
+Lgotposition_fpop2:
+	fstp	%st(0)
+	fstp	%st(0)
+	jmp		LInsertAndExit
+
+
+// emit a span (obscures current top)
+
+Lnewtop_fpop3:
+	fstp	%st(0)
+Lnewtop_fpop2:
+	fstp	%st(0)
+	fstp	%st(0)
+	movl	st_key(%edi),%eax		// reload the sorting key
+
+Lnewtop:
+	movl	et_u(%ebx),%eax
+	movl	st_last_u(%esi),%edx
+	shrl	$20,%eax				// iu = integral pixel u
+	movl	%eax,st_last_u(%edi)	// surf->last_u = iu;
+	cmpl	%edx,%eax
+	jle		LInsertAndExit			// iu <= surf->last_u, so nothing to emit
+
+	subl	%edx,%eax
+	movl	%edx,espan_t_u(%ebp)		// span->u = surf->last_u;
+
+	movl	%eax,espan_t_count(%ebp)	// span->count = iu - span->u;
+	movl	C(current_iv),%eax
+	movl	%eax,espan_t_v(%ebp)		// span->v = current_iv;
+	movl	st_spans(%esi),%eax
+	movl	%eax,espan_t_pnext(%ebp)	// span->pnext = surf->spans;
+	movl	%ebp,st_spans(%esi)			// surf->spans = span;
+	addl	$(espan_t_size),%ebp
+
+LInsertAndExit:
+// insert before surf2
+	movl	%esi,st_next(%edi)		// surf->next = surf2;
+	movl	st_prev(%esi),%eax
+	movl	%eax,st_prev(%edi)		// surf->prev = surf2->prev;
+	movl	%edi,st_prev(%esi)		// surf2->prev = surf;
+	movl	%edi,st_next(%eax)		// surf2->prev->next = surf;
+
+// ---------------------------------------------------------------
+// leading edge done
+// ---------------------------------------------------------------
+
+// ---------------------------------------------------------------
+// see if there are any more edges
+// ---------------------------------------------------------------
+
+Lgs_nextedge:
+	movl	et_next(%ebx),%ebx
+	cmpl	$(C(edge_tail)),%ebx
+	jnz		Lgs_edgeloop
+
+// clean up at the right edge
+Lgs_lastspan:
+
+// now that we've reached the right edge of the screen, we're done with any
+// unfinished surfaces, so emit a span for whatever's on top
+	movl	0x12345678,%esi		// surfaces[1].st_next
+LPatch3:
+	movl	C(edge_tail_u_shift20),%eax
+	xorl	%ecx,%ecx
+	movl	st_last_u(%esi),%edx
+	subl	%edx,%eax
+	jle		Lgs_resetspanstate
+
+	movl	%edx,espan_t_u(%ebp)
+	movl	%eax,espan_t_count(%ebp)
+	movl	C(current_iv),%eax
+	movl	%eax,espan_t_v(%ebp)
+	movl	st_spans(%esi),%eax
+	movl	%eax,espan_t_pnext(%ebp)
+	movl	%ebp,st_spans(%esi)
+	addl	$(espan_t_size),%ebp
+
+// reset spanstate for all surfaces in the surface stack
+Lgs_resetspanstate:
+	movl	%ecx,st_spanstate(%esi)
+	movl	st_next(%esi),%esi
+	cmpl	$0x12345678,%esi		// &surfaces[1]
+LPatch4:
+	jnz		Lgs_resetspanstate
+
+// store the final span_p
+	movl	%ebp,C(span_p)
+
+	popl	%ebx				// restore register variables
+	popl	%esi
+	popl	%edi
+	popl	%ebp				// restore the caller's stack frame
+	ret
+
+
+// ---------------------------------------------------------------
+// 1/z sorting for bmodels in the same leaf
+// ---------------------------------------------------------------
+	.align	4
+Lxl_done:
+	incl	%edx
+	movl	%edx,st_spanstate(%edi)
+
+	jmp		Lgs_nextedge
+
+
+	.align	4
+Lzcheck_for_newtop:
+	movl	et_u(%ebx),%eax
+	subl	$0xFFFFF,%eax
+	movl	%eax,Ltemp
+	fildl	Ltemp
+
+	fmuls	float_1_div_0100000h // fu = (float)(edge->u - 0xFFFFF) *
+								//      (1.0 / 0x100000);
+
+	fld		%st(0)				// fu | fu
+	fmuls	st_d_zistepu(%edi)	// fu*surf->d_zistepu | fu
+	flds	C(fv)				// fv | fu*surf->d_zistepu | fu
+	fmuls	st_d_zistepv(%edi)	// fv*surf->d_zistepv | fu*surf->d_zistepu | fu
+	fxch	%st(1)				// fu*surf->d_zistepu | fv*surf->d_zistepv | fu
+	fadds	st_d_ziorigin(%edi)	// fu*surf->d_zistepu + surf->d_ziorigin |
+								//  fv*surf->d_zistepv | fu
+
+	flds	st_d_zistepu(%esi)	// surf2->d_zistepu |
+								//  fu*surf->d_zistepu + surf->d_ziorigin |
+								//  fv*surf->d_zistepv | fu
+	fmul	%st(3),%st(0)		// fu*surf2->d_zistepu |
+								//  fu*surf->d_zistepu + surf->d_ziorigin |
+								//  fv*surf->d_zistepv | fu
+	fxch	%st(1)				// fu*surf->d_zistepu + surf->d_ziorigin |
+								//  fu*surf2->d_zistepu |
+								//  fv*surf->d_zistepv | fu
+	faddp	%st(0),%st(2)		// fu*surf2->d_zistepu | newzi | fu
+
+	flds	C(fv)				// fv | fu*surf2->d_zistepu | newzi | fu
+	fmuls	st_d_zistepv(%esi)	// fv*surf2->d_zistepv |
+								//  fu*surf2->d_zistepu | newzi | fu
+	fld		%st(2)				// newzi | fv*surf2->d_zistepv |
+								//  fu*surf2->d_zistepu | newzi | fu
+	fmuls	float_point_999		// newzibottom | fv*surf2->d_zistepv |
+								//  fu*surf2->d_zistepu | newzi | fu
+
+	fxch	%st(2)				// fu*surf2->d_zistepu | fv*surf2->d_zistepv |
+								//  newzibottom | newzi | fu
+	fadds	st_d_ziorigin(%esi)	// fu*surf2->d_zistepu + surf2->d_ziorigin |
+								//  fv*surf2->d_zistepv | newzibottom | newzi |
+								//  fu
+	faddp	%st(0),%st(1)		// testzi | newzibottom | newzi | fu
+	fxch	%st(1)				// newzibottom | testzi | newzi | fu
+
+// if (newzibottom >= testzi)
+//     goto newtop;
+
+	fcomp	%st(1)				// testzi | newzi | fu
+
+	fxch	%st(1)				// newzi | testzi | fu
+	fmuls	float_1_point_001	// newzitop | testzi | fu
+	fxch	%st(1)				// testzi | newzitop | fu
+
+	fnstsw	%ax
+	testb	$0x01,%ah
+	jz		Lnewtop_fpop3
+
+// if (newzitop >= testzi)
+// {
+
+	fcomp	%st(1)				// newzitop | fu
+	fnstsw	%ax
+	testb	$0x45,%ah
+	jz		Lsortloop_fpop2
+
+// if (surf->d_zistepu >= surf2->d_zistepu)
+//     goto newtop;
+
+	flds	st_d_zistepu(%edi)	// surf->d_zistepu | newzitop | fu
+	fcomps	st_d_zistepu(%esi)	// newzitop | fu
+	fnstsw	%ax
+	testb	$0x01,%ah
+	jz		Lnewtop_fpop2
+
+Lsortloop_fpop2:
+	fstp	%st(0)				// clear the FP stack
+	fstp	%st(0)
+	movl	st_key(%edi),%eax
+	jmp		Lsortloop
+
+
+.globl C(R_EdgeCodeEnd)
+C(R_EdgeCodeEnd):
+
+
+//----------------------------------------------------------------------
+// Surface array address code patching routine
+//----------------------------------------------------------------------
+
+	.align 4
+.globl C(R_SurfacePatch)
+C(R_SurfacePatch):
+
+	movl	C(surfaces),%eax
+	addl	$(st_size),%eax
+	movl	%eax,LPatch4-4
+
+	addl	$(st_next),%eax
+	movl	%eax,LPatch0-4
+	movl	%eax,LPatch2-4
+	movl	%eax,LPatch3-4
+
+	ret
+
+#endif	// id386
+
diff -ruN WinQuake/r_edgea.s sdlquake-1.0.9/r_edgea.s
--- WinQuake/r_edgea.s	Tue Dec 21 15:53:26 1999
+++ sdlquake-1.0.9/r_edgea.s	Wed Dec 31 16:00:00 1969
@@ -1,750 +0,0 @@
-/*
-Copyright (C) 1996-1997 Id Software, Inc.
-
-This program is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License
-as published by the Free Software Foundation; either version 2
-of the License, or (at your option) any later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
-
-See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-*/
-//
-// r_edgea.s
-// x86 assembly-language edge-processing code.
-//
-
-#include "asm_i386.h"
-#include "quakeasm.h"
-#include "asm_draw.h"
-
-#if	id386
-
-	.data
-Ltemp:					.long	0
-float_1_div_0100000h:	.long	0x35800000	// 1.0/(float)0x100000
-float_point_999:		.single	0.999
-float_1_point_001:		.single	1.001
-
-	.text
-
-//--------------------------------------------------------------------
-
-#define edgestoadd	4+8		// note odd stack offsets because of interleaving
-#define edgelist	8+12	// with pushes
-
-.globl C(R_EdgeCodeStart)
-C(R_EdgeCodeStart):
-
-.globl C(R_InsertNewEdges)
-C(R_InsertNewEdges):
-	pushl	%edi
-	pushl	%esi				// preserve register variables
-	movl	edgestoadd(%esp),%edx
-	pushl	%ebx
-	movl	edgelist(%esp),%ecx
-
-LDoNextEdge:
-	movl	et_u(%edx),%eax
-	movl	%edx,%edi
-
-LContinueSearch:
-	movl	et_u(%ecx),%ebx
-	movl	et_next(%ecx),%esi
-	cmpl	%ebx,%eax
-	jle		LAddedge
-	movl	et_u(%esi),%ebx
-	movl	et_next(%esi),%ecx
-	cmpl	%ebx,%eax
-	jle		LAddedge2
-	movl	et_u(%ecx),%ebx
-	movl	et_next(%ecx),%esi
-	cmpl	%ebx,%eax
-	jle		LAddedge
-	movl	et_u(%esi),%ebx
-	movl	et_next(%esi),%ecx
-	cmpl	%ebx,%eax
-	jg		LContinueSearch
-
-LAddedge2:
-	movl	et_next(%edx),%edx
-	movl	et_prev(%esi),%ebx
-	movl	%esi,et_next(%edi)
-	movl	%ebx,et_prev(%edi)
-	movl	%edi,et_next(%ebx)
-	movl	%edi,et_prev(%esi)
-	movl	%esi,%ecx
-
-	cmpl	$0,%edx
-	jnz		LDoNextEdge
-	jmp		LDone
-
-	.align 4
-LAddedge:
-	movl	et_next(%edx),%edx
-	movl	et_prev(%ecx),%ebx
-	movl	%ecx,et_next(%edi)
-	movl	%ebx,et_prev(%edi)
-	movl	%edi,et_next(%ebx)
-	movl	%edi,et_prev(%ecx)
-
-	cmpl	$0,%edx
-	jnz		LDoNextEdge
-
-LDone:
-	popl	%ebx				// restore register variables
-	popl	%esi
-	popl	%edi
-
-	ret
-
-//--------------------------------------------------------------------
-
-#define predge	4+4
-
-.globl C(R_RemoveEdges)
-C(R_RemoveEdges):
-	pushl	%ebx
-	movl	predge(%esp),%eax
-
-Lre_loop:
-	movl	et_next(%eax),%ecx
-	movl	et_nextremove(%eax),%ebx
-	movl	et_prev(%eax),%edx
-	testl	%ebx,%ebx
-	movl	%edx,et_prev(%ecx)
-	jz		Lre_done
-	movl	%ecx,et_next(%edx)
-
-	movl	et_next(%ebx),%ecx
-	movl	et_prev(%ebx),%edx
-	movl	et_nextremove(%ebx),%eax
-	movl	%edx,et_prev(%ecx)
-	testl	%eax,%eax
-	movl	%ecx,et_next(%edx)
-	jnz		Lre_loop
-
-	popl	%ebx
-	ret
-
-Lre_done:
-	movl	%ecx,et_next(%edx)
-	popl	%ebx
-
-	ret
-
-//--------------------------------------------------------------------
-
-#define pedgelist	4+4		// note odd stack offset because of interleaving
-							// with pushes
-
-.globl C(R_StepActiveU)
-C(R_StepActiveU):
-	pushl	%edi
-	movl	pedgelist(%esp),%edx
-	pushl	%esi				// preserve register variables
-	pushl	%ebx
-
-	movl	et_prev(%edx),%esi
-
-LNewEdge:
-	movl	et_u(%esi),%edi
-
-LNextEdge:
-	movl	et_u(%edx),%eax
-	movl	et_u_step(%edx),%ebx
-	addl	%ebx,%eax
-	movl	et_next(%edx),%esi
-	movl	%eax,et_u(%edx)
-	cmpl	%edi,%eax
-	jl		LPushBack
-
-	movl	et_u(%esi),%edi
-	movl	et_u_step(%esi),%ebx
-	addl	%ebx,%edi
-	movl	et_next(%esi),%edx
-	movl	%edi,et_u(%esi)
-	cmpl	%eax,%edi
-	jl		LPushBack2
-
-	movl	et_u(%edx),%eax
-	movl	et_u_step(%edx),%ebx
-	addl	%ebx,%eax
-	movl	et_next(%edx),%esi
-	movl	%eax,et_u(%edx)
-	cmpl	%edi,%eax
-	jl		LPushBack
-
-	movl	et_u(%esi),%edi
-	movl	et_u_step(%esi),%ebx
-	addl	%ebx,%edi
-	movl	et_next(%esi),%edx
-	movl	%edi,et_u(%esi)
-	cmpl	%eax,%edi
-	jnl		LNextEdge
-
-LPushBack2:
-	movl	%edx,%ebx
-	movl	%edi,%eax
-	movl	%esi,%edx
-	movl	%ebx,%esi
-
-LPushBack:
-// push it back to keep it sorted
-	movl	et_prev(%edx),%ecx
-	movl	et_next(%edx),%ebx
-
-// done if the -1 in edge_aftertail triggered this
-	cmpl	$(C(edge_aftertail)),%edx
-	jz		LUDone
-
-// pull the edge out of the edge list
-	movl	et_prev(%ecx),%edi
-	movl	%ecx,et_prev(%esi)
-	movl	%ebx,et_next(%ecx)
-
-// find out where the edge goes in the edge list
-LPushBackLoop:
-	movl	et_prev(%edi),%ecx
-	movl	et_u(%edi),%ebx
-	cmpl	%ebx,%eax
-	jnl		LPushBackFound
-
-	movl	et_prev(%ecx),%edi
-	movl	et_u(%ecx),%ebx
-	cmpl	%ebx,%eax
-	jl		LPushBackLoop
-
-	movl	%ecx,%edi
-
-// put the edge back into the edge list
-LPushBackFound:
-	movl	et_next(%edi),%ebx
-	movl	%edi,et_prev(%edx)
-	movl	%ebx,et_next(%edx)
-	movl	%edx,et_next(%edi)
-	movl	%edx,et_prev(%ebx)
-
-	movl	%esi,%edx
-	movl	et_prev(%esi),%esi
-
-	cmpl	$(C(edge_tail)),%edx
-	jnz		LNewEdge
-
-LUDone:
-	popl	%ebx				// restore register variables
-	popl	%esi
-	popl	%edi
-
-	ret
-
-//--------------------------------------------------------------------
-
-#define surf	4		// note this is loaded before any pushes
-
-	.align 4
-TrailingEdge:
-	movl	st_spanstate(%esi),%eax	// check for edge inversion
-	decl	%eax
-	jnz		LInverted
-
-	movl	%eax,st_spanstate(%esi)
-	movl	st_insubmodel(%esi),%ecx
-	movl	0x12345678,%edx		// surfaces[1].st_next
-LPatch0:
-	movl	C(r_bmodelactive),%eax
-	subl	%ecx,%eax
-	cmpl	%esi,%edx
-	movl	%eax,C(r_bmodelactive)
-	jnz		LNoEmit				// surface isn't on top, just remove
-
-// emit a span (current top going away)
-	movl	et_u(%ebx),%eax
-	shrl	$20,%eax				// iu = integral pixel u
-	movl	st_last_u(%esi),%edx
-	movl	st_next(%esi),%ecx
-	cmpl	%edx,%eax
-	jle		LNoEmit2				// iu <= surf->last_u, so nothing to emit
-
-	movl	%eax,st_last_u(%ecx)	// surf->next->last_u = iu;
-	subl	%edx,%eax
-	movl	%edx,espan_t_u(%ebp)		// span->u = surf->last_u;
-
-	movl	%eax,espan_t_count(%ebp)	// span->count = iu - span->u;
-	movl	C(current_iv),%eax
-	movl	%eax,espan_t_v(%ebp)		// span->v = current_iv;
-	movl	st_spans(%esi),%eax
-	movl	%eax,espan_t_pnext(%ebp)	// span->pnext = surf->spans;
-	movl	%ebp,st_spans(%esi)			// surf->spans = span;
-	addl	$(espan_t_size),%ebp
-
-	movl	st_next(%esi),%edx		// remove the surface from the surface
-	movl	st_prev(%esi),%esi		// stack
-
-	movl	%edx,st_next(%esi)
-	movl	%esi,st_prev(%edx)
-	ret
-
-LNoEmit2:
-	movl	%eax,st_last_u(%ecx)	// surf->next->last_u = iu;
-	movl	st_next(%esi),%edx		// remove the surface from the surface
-	movl	st_prev(%esi),%esi		// stack
-
-	movl	%edx,st_next(%esi)
-	movl	%esi,st_prev(%edx)
-	ret
-
-LNoEmit:
-	movl	st_next(%esi),%edx		// remove the surface from the surface
-	movl	st_prev(%esi),%esi		// stack
-
-	movl	%edx,st_next(%esi)
-	movl	%esi,st_prev(%edx)
-	ret
-
-LInverted:
-	movl	%eax,st_spanstate(%esi)
-	ret
-
-//--------------------------------------------------------------------
-
-// trailing edge only
-Lgs_trailing:
-	pushl	$Lgs_nextedge
-	jmp		TrailingEdge
-
-
-.globl C(R_GenerateSpans)
-C(R_GenerateSpans):
-	pushl	%ebp				// preserve caller's stack frame
-	pushl	%edi
-	pushl	%esi				// preserve register variables
-	pushl	%ebx
-
-// clear active surfaces to just the background surface
-	movl	C(surfaces),%eax
-	movl	C(edge_head_u_shift20),%edx
-	addl	$(st_size),%eax
-// %ebp = span_p throughout
-	movl	C(span_p),%ebp
-
-	movl	$0,C(r_bmodelactive)
-
-	movl	%eax,st_next(%eax)
-	movl	%eax,st_prev(%eax)
-	movl	%edx,st_last_u(%eax)
-	movl	C(edge_head)+et_next,%ebx		// edge=edge_head.next
-
-// generate spans
-	cmpl	$(C(edge_tail)),%ebx		// done if empty list
-	jz		Lgs_lastspan
-
-Lgs_edgeloop:
-
-	movl	et_surfs(%ebx),%edi
-	movl	C(surfaces),%eax
-	movl	%edi,%esi
-	andl	$0xFFFF0000,%edi
-	andl	$0xFFFF,%esi
-	jz		Lgs_leading		// not a trailing edge
-
-// it has a left surface, so a surface is going away for this span
-	shll	$(SURF_T_SHIFT),%esi
-	addl	%eax,%esi
-	testl	%edi,%edi
-	jz		Lgs_trailing
-
-// both leading and trailing
-	call	TrailingEdge
-	movl	C(surfaces),%eax
-
-// ---------------------------------------------------------------
-// handle a leading edge
-// ---------------------------------------------------------------
-
-Lgs_leading:
-	shrl	$16-SURF_T_SHIFT,%edi
-	movl	C(surfaces),%eax
-	addl	%eax,%edi
-	movl	0x12345678,%esi		// surf2 = surfaces[1].next;
-LPatch2:
-	movl	st_spanstate(%edi),%edx
-	movl	st_insubmodel(%edi),%eax
-	testl	%eax,%eax
-	jnz		Lbmodel_leading
-
-// handle a leading non-bmodel edge
-
-// don't start a span if this is an inverted span, with the end edge preceding
-// the start edge (that is, we've already seen the end edge)
-	testl	%edx,%edx
-	jnz		Lxl_done
-
-
-// if (surf->key < surf2->key)
-//		goto newtop;
-	incl	%edx
-	movl	st_key(%edi),%eax
-	movl	%edx,st_spanstate(%edi)
-	movl	st_key(%esi),%ecx
-	cmpl	%ecx,%eax
-	jl		Lnewtop
-
-// main sorting loop to search through surface stack until insertion point
-// found. Always terminates because background surface is sentinel
-// do
-// {
-// 		surf2 = surf2->next;
-// } while (surf->key >= surf2->key);
-Lsortloopnb:
-	movl	st_next(%esi),%esi
-	movl	st_key(%esi),%ecx
-	cmpl	%ecx,%eax
-	jge		Lsortloopnb
-
-	jmp		LInsertAndExit
-
-
-// handle a leading bmodel edge
-	.align	4
-Lbmodel_leading:
-
-// don't start a span if this is an inverted span, with the end edge preceding
-// the start edge (that is, we've already seen the end edge)
-	testl	%edx,%edx
-	jnz		Lxl_done
-
-	movl	C(r_bmodelactive),%ecx
-	incl	%edx
-	incl	%ecx
-	movl	%edx,st_spanstate(%edi)
-	movl	%ecx,C(r_bmodelactive)
-
-// if (surf->key < surf2->key)
-//		goto newtop;
-	movl	st_key(%edi),%eax
-	movl	st_key(%esi),%ecx
-	cmpl	%ecx,%eax
-	jl		Lnewtop
-
-// if ((surf->key == surf2->key) && surf->insubmodel)
-// {
-	jz		Lzcheck_for_newtop
-
-// main sorting loop to search through surface stack until insertion point
-// found. Always terminates because background surface is sentinel
-// do
-// {
-// 		surf2 = surf2->next;
-// } while (surf->key > surf2->key);
-Lsortloop:
-	movl	st_next(%esi),%esi
-	movl	st_key(%esi),%ecx
-	cmpl	%ecx,%eax
-	jg		Lsortloop
-
-	jne		LInsertAndExit
-
-// Do 1/z sorting to see if we've arrived in the right position
-	movl	et_u(%ebx),%eax
-	subl	$0xFFFFF,%eax
-	movl	%eax,Ltemp
-	fildl	Ltemp
-
-	fmuls	float_1_div_0100000h // fu = (float)(edge->u - 0xFFFFF) *
-								//      (1.0 / 0x100000);
-
-	fld		%st(0)				// fu | fu
-	fmuls	st_d_zistepu(%edi)	// fu*surf->d_zistepu | fu
-	flds	C(fv)					// fv | fu*surf->d_zistepu | fu
-	fmuls	st_d_zistepv(%edi)	// fv*surf->d_zistepv | fu*surf->d_zistepu | fu
-	fxch	%st(1)				// fu*surf->d_zistepu | fv*surf->d_zistepv | fu
-	fadds	st_d_ziorigin(%edi)	// fu*surf->d_zistepu + surf->d_ziorigin |
-								//  fv*surf->d_zistepv | fu
-
-	flds	st_d_zistepu(%esi)	// surf2->d_zistepu |
-								//  fu*surf->d_zistepu + surf->d_ziorigin |
-								//  fv*surf->d_zistepv | fu
-	fmul	%st(3),%st(0)		// fu*surf2->d_zistepu |
-								//  fu*surf->d_zistepu + surf->d_ziorigin |
-								//  fv*surf->d_zistepv | fu
-	fxch	%st(1)				// fu*surf->d_zistepu + surf->d_ziorigin |
-								//  fu*surf2->d_zistepu |
-								//  fv*surf->d_zistepv | fu
-	faddp	%st(0),%st(2)		// fu*surf2->d_zistepu | newzi | fu
-
-	flds	C(fv)					// fv | fu*surf2->d_zistepu | newzi | fu
-	fmuls	st_d_zistepv(%esi)	// fv*surf2->d_zistepv |
-								//  fu*surf2->d_zistepu | newzi | fu
-	fld		%st(2)				// newzi | fv*surf2->d_zistepv |
-								//  fu*surf2->d_zistepu | newzi | fu
-	fmuls	float_point_999		// newzibottom | fv*surf2->d_zistepv |
-								//  fu*surf2->d_zistepu | newzi | fu
-
-	fxch	%st(2)				// fu*surf2->d_zistepu | fv*surf2->d_zistepv |
-								//  newzibottom | newzi | fu
-	fadds	st_d_ziorigin(%esi)	// fu*surf2->d_zistepu + surf2->d_ziorigin |
-								//  fv*surf2->d_zistepv | newzibottom | newzi |
-								//  fu
-	faddp	%st(0),%st(1)		// testzi | newzibottom | newzi | fu
-	fxch	%st(1)				// newzibottom | testzi | newzi | fu
-
-// if (newzibottom >= testzi)
-//     goto Lgotposition;
-
-	fcomp	%st(1)				// testzi | newzi | fu
-
-	fxch	%st(1)				// newzi | testzi | fu
-	fmuls	float_1_point_001	// newzitop | testzi | fu
-	fxch	%st(1)				// testzi | newzitop | fu
-
-	fnstsw	%ax
-	testb	$0x01,%ah
-	jz		Lgotposition_fpop3
-
-// if (newzitop >= testzi)
-// {
-
-	fcomp	%st(1)				// newzitop | fu
-	fnstsw	%ax
-	testb	$0x45,%ah
-	jz		Lsortloop_fpop2
-
-// if (surf->d_zistepu >= surf2->d_zistepu)
-//     goto newtop;
-
-	flds	st_d_zistepu(%edi)	// surf->d_zistepu | newzitop| fu
-	fcomps	st_d_zistepu(%esi)	// newzitop | fu
-	fnstsw	%ax
-	testb	$0x01,%ah
-	jz		Lgotposition_fpop2
-
-	fstp	%st(0)				// clear the FPstack
-	fstp	%st(0)
-	movl	st_key(%edi),%eax
-	jmp		Lsortloop
-
-
-Lgotposition_fpop3:
-	fstp	%st(0)
-Lgotposition_fpop2:
-	fstp	%st(0)
-	fstp	%st(0)
-	jmp		LInsertAndExit
-
-
-// emit a span (obscures current top)
-
-Lnewtop_fpop3:
-	fstp	%st(0)
-Lnewtop_fpop2:
-	fstp	%st(0)
-	fstp	%st(0)
-	movl	st_key(%edi),%eax		// reload the sorting key
-
-Lnewtop:
-	movl	et_u(%ebx),%eax
-	movl	st_last_u(%esi),%edx
-	shrl	$20,%eax				// iu = integral pixel u
-	movl	%eax,st_last_u(%edi)	// surf->last_u = iu;
-	cmpl	%edx,%eax
-	jle		LInsertAndExit			// iu <= surf->last_u, so nothing to emit
-
-	subl	%edx,%eax
-	movl	%edx,espan_t_u(%ebp)		// span->u = surf->last_u;
-
-	movl	%eax,espan_t_count(%ebp)	// span->count = iu - span->u;
-	movl	C(current_iv),%eax
-	movl	%eax,espan_t_v(%ebp)		// span->v = current_iv;
-	movl	st_spans(%esi),%eax
-	movl	%eax,espan_t_pnext(%ebp)	// span->pnext = surf->spans;
-	movl	%ebp,st_spans(%esi)			// surf->spans = span;
-	addl	$(espan_t_size),%ebp
-
-LInsertAndExit:
-// insert before surf2
-	movl	%esi,st_next(%edi)		// surf->next = surf2;
-	movl	st_prev(%esi),%eax
-	movl	%eax,st_prev(%edi)		// surf->prev = surf2->prev;
-	movl	%edi,st_prev(%esi)		// surf2->prev = surf;
-	movl	%edi,st_next(%eax)		// surf2->prev->next = surf;
-
-// ---------------------------------------------------------------
-// leading edge done
-// ---------------------------------------------------------------
-
-// ---------------------------------------------------------------
-// see if there are any more edges
-// ---------------------------------------------------------------
-
-Lgs_nextedge:
-	movl	et_next(%ebx),%ebx
-	cmpl	$(C(edge_tail)),%ebx
-	jnz		Lgs_edgeloop
-
-// clean up at the right edge
-Lgs_lastspan:
-
-// now that we've reached the right edge of the screen, we're done with any
-// unfinished surfaces, so emit a span for whatever's on top
-	movl	0x12345678,%esi		// surfaces[1].st_next
-LPatch3:
-	movl	C(edge_tail_u_shift20),%eax
-	xorl	%ecx,%ecx
-	movl	st_last_u(%esi),%edx
-	subl	%edx,%eax
-	jle		Lgs_resetspanstate
-
-	movl	%edx,espan_t_u(%ebp)
-	movl	%eax,espan_t_count(%ebp)
-	movl	C(current_iv),%eax
-	movl	%eax,espan_t_v(%ebp)
-	movl	st_spans(%esi),%eax
-	movl	%eax,espan_t_pnext(%ebp)
-	movl	%ebp,st_spans(%esi)
-	addl	$(espan_t_size),%ebp
-
-// reset spanstate for all surfaces in the surface stack
-Lgs_resetspanstate:
-	movl	%ecx,st_spanstate(%esi)
-	movl	st_next(%esi),%esi
-	cmpl	$0x12345678,%esi		// &surfaces[1]
-LPatch4:
-	jnz		Lgs_resetspanstate
-
-// store the final span_p
-	movl	%ebp,C(span_p)
-
-	popl	%ebx				// restore register variables
-	popl	%esi
-	popl	%edi
-	popl	%ebp				// restore the caller's stack frame
-	ret
-
-
-// ---------------------------------------------------------------
-// 1/z sorting for bmodels in the same leaf
-// ---------------------------------------------------------------
-	.align	4
-Lxl_done:
-	incl	%edx
-	movl	%edx,st_spanstate(%edi)
-
-	jmp		Lgs_nextedge
-
-
-	.align	4
-Lzcheck_for_newtop:
-	movl	et_u(%ebx),%eax
-	subl	$0xFFFFF,%eax
-	movl	%eax,Ltemp
-	fildl	Ltemp
-
-	fmuls	float_1_div_0100000h // fu = (float)(edge->u - 0xFFFFF) *
-								//      (1.0 / 0x100000);
-
-	fld		%st(0)				// fu | fu
-	fmuls	st_d_zistepu(%edi)	// fu*surf->d_zistepu | fu
-	flds	C(fv)				// fv | fu*surf->d_zistepu | fu
-	fmuls	st_d_zistepv(%edi)	// fv*surf->d_zistepv | fu*surf->d_zistepu | fu
-	fxch	%st(1)				// fu*surf->d_zistepu | fv*surf->d_zistepv | fu
-	fadds	st_d_ziorigin(%edi)	// fu*surf->d_zistepu + surf->d_ziorigin |
-								//  fv*surf->d_zistepv | fu
-
-	flds	st_d_zistepu(%esi)	// surf2->d_zistepu |
-								//  fu*surf->d_zistepu + surf->d_ziorigin |
-								//  fv*surf->d_zistepv | fu
-	fmul	%st(3),%st(0)		// fu*surf2->d_zistepu |
-								//  fu*surf->d_zistepu + surf->d_ziorigin |
-								//  fv*surf->d_zistepv | fu
-	fxch	%st(1)				// fu*surf->d_zistepu + surf->d_ziorigin |
-								//  fu*surf2->d_zistepu |
-								//  fv*surf->d_zistepv | fu
-	faddp	%st(0),%st(2)		// fu*surf2->d_zistepu | newzi | fu
-
-	flds	C(fv)				// fv | fu*surf2->d_zistepu | newzi | fu
-	fmuls	st_d_zistepv(%esi)	// fv*surf2->d_zistepv |
-								//  fu*surf2->d_zistepu | newzi | fu
-	fld		%st(2)				// newzi | fv*surf2->d_zistepv |
-								//  fu*surf2->d_zistepu | newzi | fu
-	fmuls	float_point_999		// newzibottom | fv*surf2->d_zistepv |
-								//  fu*surf2->d_zistepu | newzi | fu
-
-	fxch	%st(2)				// fu*surf2->d_zistepu | fv*surf2->d_zistepv |
-								//  newzibottom | newzi | fu
-	fadds	st_d_ziorigin(%esi)	// fu*surf2->d_zistepu + surf2->d_ziorigin |
-								//  fv*surf2->d_zistepv | newzibottom | newzi |
-								//  fu
-	faddp	%st(0),%st(1)		// testzi | newzibottom | newzi | fu
-	fxch	%st(1)				// newzibottom | testzi | newzi | fu
-
-// if (newzibottom >= testzi)
-//     goto newtop;
-
-	fcomp	%st(1)				// testzi | newzi | fu
-
-	fxch	%st(1)				// newzi | testzi | fu
-	fmuls	float_1_point_001	// newzitop | testzi | fu
-	fxch	%st(1)				// testzi | newzitop | fu
-
-	fnstsw	%ax
-	testb	$0x01,%ah
-	jz		Lnewtop_fpop3
-
-// if (newzitop >= testzi)
-// {
-
-	fcomp	%st(1)				// newzitop | fu
-	fnstsw	%ax
-	testb	$0x45,%ah
-	jz		Lsortloop_fpop2
-
-// if (surf->d_zistepu >= surf2->d_zistepu)
-//     goto newtop;
-
-	flds	st_d_zistepu(%edi)	// surf->d_zistepu | newzitop | fu
-	fcomps	st_d_zistepu(%esi)	// newzitop | fu
-	fnstsw	%ax
-	testb	$0x01,%ah
-	jz		Lnewtop_fpop2
-
-Lsortloop_fpop2:
-	fstp	%st(0)				// clear the FP stack
-	fstp	%st(0)
-	movl	st_key(%edi),%eax
-	jmp		Lsortloop
-
-
-.globl C(R_EdgeCodeEnd)
-C(R_EdgeCodeEnd):
-
-
-//----------------------------------------------------------------------
-// Surface array address code patching routine
-//----------------------------------------------------------------------
-
-	.align 4
-.globl C(R_SurfacePatch)
-C(R_SurfacePatch):
-
-	movl	C(surfaces),%eax
-	addl	$(st_size),%eax
-	movl	%eax,LPatch4-4
-
-	addl	$(st_next),%eax
-	movl	%eax,LPatch0-4
-	movl	%eax,LPatch2-4
-	movl	%eax,LPatch3-4
-
-	ret
-
-#endif	// id386
-
diff -ruN WinQuake/r_varsa.S sdlquake-1.0.9/r_varsa.S
--- WinQuake/r_varsa.S	Wed Dec 31 16:00:00 1969
+++ sdlquake-1.0.9/r_varsa.S	Sat Dec 25 03:38:03 1999
@@ -0,0 +1,64 @@
+/*
+Copyright (C) 1996-1997 Id Software, Inc.
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation; either version 2
+of the License, or (at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
+
+See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+//
+// r_varsa.s
+//
+
+#include "asm_i386.h"
+#include "quakeasm.h"
+#include "asm_draw.h"
+#include "d_ifacea.h"
+
+#if id386
+
+	.data
+
+//-------------------------------------------------------
+// ASM-only variables
+//-------------------------------------------------------
+.globl	float_1, float_particle_z_clip, float_point5
+.globl	float_minus_1, float_0
+float_0:		.single	0.0
+float_1:		.single	1.0
+float_minus_1:	.single	-1.0
+float_particle_z_clip:	.single	PARTICLE_Z_CLIP
+float_point5:	.single	0.5
+
+.globl	fp_16, fp_64k, fp_1m, fp_64kx64k
+.globl	fp_1m_minus_1
+.globl	fp_8 
+fp_1m:			.single	1048576.0
+fp_1m_minus_1:	.single	1048575.0
+fp_64k:			.single	65536.0
+fp_8:			.single	8.0
+fp_16:			.single	16.0
+fp_64kx64k:		.long	0x4f000000	// (float)0x8000*0x10000
+
+
+.globl	FloatZero, Float2ToThe31nd, FloatMinus2ToThe31nd
+FloatZero:				.long	0
+Float2ToThe31nd:		.long	0x4f000000
+FloatMinus2ToThe31nd:	.long	0xcf000000
+
+.globl	C(r_bmodelactive)
+C(r_bmodelactive):	.long	0
+
+#endif	// id386
+
diff -ruN WinQuake/r_varsa.s sdlquake-1.0.9/r_varsa.s
--- WinQuake/r_varsa.s	Tue Dec 21 15:53:26 1999
+++ sdlquake-1.0.9/r_varsa.s	Wed Dec 31 16:00:00 1969
@@ -1,64 +0,0 @@
-/*
-Copyright (C) 1996-1997 Id Software, Inc.
-
-This program is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License
-as published by the Free Software Foundation; either version 2
-of the License, or (at your option) any later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
-
-See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-*/
-//
-// r_varsa.s
-//
-
-#include "asm_i386.h"
-#include "quakeasm.h"
-#include "asm_draw.h"
-#include "d_ifacea.h"
-
-#if id386
-
-	.data
-
-//-------------------------------------------------------
-// ASM-only variables
-//-------------------------------------------------------
-.globl	float_1, float_particle_z_clip, float_point5
-.globl	float_minus_1, float_0
-float_0:		.single	0.0
-float_1:		.single	1.0
-float_minus_1:	.single	-1.0
-float_particle_z_clip:	.single	PARTICLE_Z_CLIP
-float_point5:	.single	0.5
-
-.globl	fp_16, fp_64k, fp_1m, fp_64kx64k
-.globl	fp_1m_minus_1
-.globl	fp_8 
-fp_1m:			.single	1048576.0
-fp_1m_minus_1:	.single	1048575.0
-fp_64k:			.single	65536.0
-fp_8:			.single	8.0
-fp_16:			.single	16.0
-fp_64kx64k:		.long	0x4f000000	// (float)0x8000*0x10000
-
-
-.globl	FloatZero, Float2ToThe31nd, FloatMinus2ToThe31nd
-FloatZero:				.long	0
-Float2ToThe31nd:		.long	0x4f000000
-FloatMinus2ToThe31nd:	.long	0xcf000000
-
-.globl	C(r_bmodelactive)
-C(r_bmodelactive):	.long	0
-
-#endif	// id386
-
diff -ruN WinQuake/snd_dma.c sdlquake-1.0.9/snd_dma.c
--- WinQuake/snd_dma.c	Tue Dec 21 15:53:26 1999
+++ sdlquake-1.0.9/snd_dma.c	Tue Dec 28 11:15:23 1999
@@ -227,7 +227,9 @@
 		shm->buffer = Hunk_AllocName(1<<16, "shmbuf");
 	}
 
-	Con_Printf ("Sound sampling rate: %i\n", shm->speed);
+	if ( shm ) {
+		Con_Printf ("Sound sampling rate: %i\n", shm->speed);
+	}
 
 	// provides a tick sound until washed clean
 
@@ -855,6 +857,8 @@
 
 void S_Update_(void)
 {
+#ifndef SDL
+
 	unsigned        endtime;
 	int				samps;
 	
@@ -899,6 +903,7 @@
 	S_PaintChannels (endtime);
 
 	SNDDMA_Submit ();
+#endif /* ! SDL */
 }
 
 /*
diff -ruN WinQuake/snd_mixa.S sdlquake-1.0.9/snd_mixa.S
--- WinQuake/snd_mixa.S	Wed Dec 31 16:00:00 1969
+++ sdlquake-1.0.9/snd_mixa.S	Sat Dec 25 03:38:03 1999
@@ -0,0 +1,218 @@
+/*
+Copyright (C) 1996-1997 Id Software, Inc.
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation; either version 2
+of the License, or (at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
+
+See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+//
+// snd_mixa.s
+// x86 assembly-language sound code
+//
+
+#include "asm_i386.h"
+#include "quakeasm.h"
+
+#if	id386
+
+	.text
+
+//----------------------------------------------------------------------
+// 8-bit sound-mixing code
+//----------------------------------------------------------------------
+
+#define ch		4+16
+#define sc		8+16
+#define count	12+16
+
+.globl C(SND_PaintChannelFrom8)
+C(SND_PaintChannelFrom8):
+	pushl	%esi				// preserve register variables
+	pushl	%edi
+	pushl	%ebx
+	pushl	%ebp
+
+//	int 	data;
+//	short	*lscale, *rscale;
+//	unsigned char *sfx;
+//	int		i;
+
+	movl	ch(%esp),%ebx
+	movl	sc(%esp),%esi
+
+//	if (ch->leftvol > 255)
+//		ch->leftvol = 255;
+//	if (ch->rightvol > 255)
+//		ch->rightvol = 255;
+	movl	ch_leftvol(%ebx),%eax
+	movl	ch_rightvol(%ebx),%edx
+	cmpl	$255,%eax
+	jna		LLeftSet
+	movl	$255,%eax
+LLeftSet:
+	cmpl	$255,%edx
+	jna		LRightSet
+	movl	$255,%edx
+LRightSet:
+
+//	lscale = snd_scaletable[ch->leftvol >> 3];
+//	rscale = snd_scaletable[ch->rightvol >> 3];
+//	sfx = (signed char *)sc->data + ch->pos;
+//	ch->pos += count;
+	andl	$0xF8,%eax
+	addl	$(sfxc_data),%esi
+	andl	$0xF8,%edx
+	movl	ch_pos(%ebx),%edi
+	movl	count(%esp),%ecx
+	addl	%edi,%esi
+	shll	$7,%eax
+	addl	%ecx,%edi
+	shll	$7,%edx
+	movl	%edi,ch_pos(%ebx)
+	addl	$(C(snd_scaletable)),%eax
+	addl	$(C(snd_scaletable)),%edx
+	subl	%ebx,%ebx
+	movb	-1(%esi,%ecx,1),%bl
+
+	testl	$1,%ecx
+	jz		LMix8Loop
+
+	movl	(%eax,%ebx,4),%edi
+	movl	(%edx,%ebx,4),%ebp
+	addl	C(paintbuffer)+psp_left-psp_size(,%ecx,psp_size),%edi
+	addl	C(paintbuffer)+psp_right-psp_size(,%ecx,psp_size),%ebp
+	movl	%edi,C(paintbuffer)+psp_left-psp_size(,%ecx,psp_size)
+	movl	%ebp,C(paintbuffer)+psp_right-psp_size(,%ecx,psp_size)
+	movb	-2(%esi,%ecx,1),%bl
+
+	decl	%ecx
+	jz		LDone
+
+//	for (i=0 ; i<count ; i++)
+//	{
+LMix8Loop:
+
+//		data = sfx[i];
+//		paintbuffer[i].left += lscale[data];
+//		paintbuffer[i].right += rscale[data];
+	movl	(%eax,%ebx,4),%edi
+	movl	(%edx,%ebx,4),%ebp
+	addl	C(paintbuffer)+psp_left-psp_size(,%ecx,psp_size),%edi
+	addl	C(paintbuffer)+psp_right-psp_size(,%ecx,psp_size),%ebp
+	movb	-2(%esi,%ecx,1),%bl
+	movl	%edi,C(paintbuffer)+psp_left-psp_size(,%ecx,psp_size)
+	movl	%ebp,C(paintbuffer)+psp_right-psp_size(,%ecx,psp_size)
+
+	movl	(%eax,%ebx,4),%edi
+	movl	(%edx,%ebx,4),%ebp
+	movb	-3(%esi,%ecx,1),%bl
+	addl	C(paintbuffer)+psp_left-psp_size*2(,%ecx,psp_size),%edi
+	addl	C(paintbuffer)+psp_right-psp_size*2(,%ecx,psp_size),%ebp
+	movl	%edi,C(paintbuffer)+psp_left-psp_size*2(,%ecx,psp_size)
+	movl	%ebp,C(paintbuffer)+psp_right-psp_size*2(,%ecx,psp_size)
+
+//	}
+	subl	$2,%ecx
+	jnz		LMix8Loop
+
+LDone:
+	popl	%ebp
+	popl	%ebx
+	popl	%edi
+	popl	%esi
+
+	ret
+
+
+//----------------------------------------------------------------------
+// Transfer of stereo buffer to 16-bit DMA buffer code
+//----------------------------------------------------------------------
+
+.globl C(Snd_WriteLinearBlastStereo16)
+C(Snd_WriteLinearBlastStereo16):
+	pushl	%esi				// preserve register variables
+	pushl	%edi
+	pushl	%ebx
+
+//	int		i;
+//	int		val;
+	movl	C(snd_linear_count),%ecx
+	movl	C(snd_p),%ebx
+	movl	C(snd_vol),%esi
+	movl	C(snd_out),%edi
+
+//	for (i=0 ; i<snd_linear_count ; i+=2)
+//	{
+LWLBLoopTop:
+
+//		val = (snd_p[i]*snd_vol)>>8;
+//		if (val > 0x7fff)
+//			snd_out[i] = 0x7fff;
+//		else if (val < (short)0x8000)
+//			snd_out[i] = (short)0x8000;
+//		else
+//			snd_out[i] = val;
+	movl	-8(%ebx,%ecx,4),%eax
+	imull	%esi,%eax
+	sarl	$8,%eax
+	cmpl	$0x7FFF,%eax
+	jg		LClampHigh
+	cmpl	$0xFFFF8000,%eax
+	jnl		LClampDone
+	movl	$0xFFFF8000,%eax
+	jmp		LClampDone
+LClampHigh:
+	movl	$0x7FFF,%eax
+LClampDone:
+
+//		val = (snd_p[i+1]*snd_vol)>>8;
+//		if (val > 0x7fff)
+//			snd_out[i+1] = 0x7fff;
+//		else if (val < (short)0x8000)
+//			snd_out[i+1] = (short)0x8000;
+//		else
+//			snd_out[i+1] = val;
+	movl	-4(%ebx,%ecx,4),%edx
+	imull	%esi,%edx
+	sarl	$8,%edx
+	cmpl	$0x7FFF,%edx
+	jg		LClampHigh2
+	cmpl	$0xFFFF8000,%edx
+	jnl		LClampDone2
+	movl	$0xFFFF8000,%edx
+	jmp		LClampDone2
+LClampHigh2:
+	movl	$0x7FFF,%edx
+LClampDone2:
+	shll	$16,%edx
+	andl	$0xFFFF,%eax
+	orl		%eax,%edx
+	movl	%edx,-4(%edi,%ecx,2)
+
+//	}
+	subl	$2,%ecx
+	jnz		LWLBLoopTop
+
+//	snd_p += snd_linear_count;
+
+	popl	%ebx
+	popl	%edi
+	popl	%esi
+
+	ret
+
+
+#endif	// id386
+
diff -ruN WinQuake/snd_mixa.s sdlquake-1.0.9/snd_mixa.s
--- WinQuake/snd_mixa.s	Tue Dec 21 15:53:26 1999
+++ sdlquake-1.0.9/snd_mixa.s	Wed Dec 31 16:00:00 1969
@@ -1,218 +0,0 @@
-/*
-Copyright (C) 1996-1997 Id Software, Inc.
-
-This program is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License
-as published by the Free Software Foundation; either version 2
-of the License, or (at your option) any later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
-
-See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-*/
-//
-// snd_mixa.s
-// x86 assembly-language sound code
-//
-
-#include "asm_i386.h"
-#include "quakeasm.h"
-
-#if	id386
-
-	.text
-
-//----------------------------------------------------------------------
-// 8-bit sound-mixing code
-//----------------------------------------------------------------------
-
-#define ch		4+16
-#define sc		8+16
-#define count	12+16
-
-.globl C(SND_PaintChannelFrom8)
-C(SND_PaintChannelFrom8):
-	pushl	%esi				// preserve register variables
-	pushl	%edi
-	pushl	%ebx
-	pushl	%ebp
-
-//	int 	data;
-//	short	*lscale, *rscale;
-//	unsigned char *sfx;
-//	int		i;
-
-	movl	ch(%esp),%ebx
-	movl	sc(%esp),%esi
-
-//	if (ch->leftvol > 255)
-//		ch->leftvol = 255;
-//	if (ch->rightvol > 255)
-//		ch->rightvol = 255;
-	movl	ch_leftvol(%ebx),%eax
-	movl	ch_rightvol(%ebx),%edx
-	cmpl	$255,%eax
-	jna		LLeftSet
-	movl	$255,%eax
-LLeftSet:
-	cmpl	$255,%edx
-	jna		LRightSet
-	movl	$255,%edx
-LRightSet:
-
-//	lscale = snd_scaletable[ch->leftvol >> 3];
-//	rscale = snd_scaletable[ch->rightvol >> 3];
-//	sfx = (signed char *)sc->data + ch->pos;
-//	ch->pos += count;
-	andl	$0xF8,%eax
-	addl	$(sfxc_data),%esi
-	andl	$0xF8,%edx
-	movl	ch_pos(%ebx),%edi
-	movl	count(%esp),%ecx
-	addl	%edi,%esi
-	shll	$7,%eax
-	addl	%ecx,%edi
-	shll	$7,%edx
-	movl	%edi,ch_pos(%ebx)
-	addl	$(C(snd_scaletable)),%eax
-	addl	$(C(snd_scaletable)),%edx
-	subl	%ebx,%ebx
-	movb	-1(%esi,%ecx,1),%bl
-
-	testl	$1,%ecx
-	jz		LMix8Loop
-
-	movl	(%eax,%ebx,4),%edi
-	movl	(%edx,%ebx,4),%ebp
-	addl	C(paintbuffer)+psp_left-psp_size(,%ecx,psp_size),%edi
-	addl	C(paintbuffer)+psp_right-psp_size(,%ecx,psp_size),%ebp
-	movl	%edi,C(paintbuffer)+psp_left-psp_size(,%ecx,psp_size)
-	movl	%ebp,C(paintbuffer)+psp_right-psp_size(,%ecx,psp_size)
-	movb	-2(%esi,%ecx,1),%bl
-
-	decl	%ecx
-	jz		LDone
-
-//	for (i=0 ; i<count ; i++)
-//	{
-LMix8Loop:
-
-//		data = sfx[i];
-//		paintbuffer[i].left += lscale[data];
-//		paintbuffer[i].right += rscale[data];
-	movl	(%eax,%ebx,4),%edi
-	movl	(%edx,%ebx,4),%ebp
-	addl	C(paintbuffer)+psp_left-psp_size(,%ecx,psp_size),%edi
-	addl	C(paintbuffer)+psp_right-psp_size(,%ecx,psp_size),%ebp
-	movb	-2(%esi,%ecx,1),%bl
-	movl	%edi,C(paintbuffer)+psp_left-psp_size(,%ecx,psp_size)
-	movl	%ebp,C(paintbuffer)+psp_right-psp_size(,%ecx,psp_size)
-
-	movl	(%eax,%ebx,4),%edi
-	movl	(%edx,%ebx,4),%ebp
-	movb	-3(%esi,%ecx,1),%bl
-	addl	C(paintbuffer)+psp_left-psp_size*2(,%ecx,psp_size),%edi
-	addl	C(paintbuffer)+psp_right-psp_size*2(,%ecx,psp_size),%ebp
-	movl	%edi,C(paintbuffer)+psp_left-psp_size*2(,%ecx,psp_size)
-	movl	%ebp,C(paintbuffer)+psp_right-psp_size*2(,%ecx,psp_size)
-
-//	}
-	subl	$2,%ecx
-	jnz		LMix8Loop
-
-LDone:
-	popl	%ebp
-	popl	%ebx
-	popl	%edi
-	popl	%esi
-
-	ret
-
-
-//----------------------------------------------------------------------
-// Transfer of stereo buffer to 16-bit DMA buffer code
-//----------------------------------------------------------------------
-
-.globl C(Snd_WriteLinearBlastStereo16)
-C(Snd_WriteLinearBlastStereo16):
-	pushl	%esi				// preserve register variables
-	pushl	%edi
-	pushl	%ebx
-
-//	int		i;
-//	int		val;
-	movl	C(snd_linear_count),%ecx
-	movl	C(snd_p),%ebx
-	movl	C(snd_vol),%esi
-	movl	C(snd_out),%edi
-
-//	for (i=0 ; i<snd_linear_count ; i+=2)
-//	{
-LWLBLoopTop:
-
-//		val = (snd_p[i]*snd_vol)>>8;
-//		if (val > 0x7fff)
-//			snd_out[i] = 0x7fff;
-//		else if (val < (short)0x8000)
-//			snd_out[i] = (short)0x8000;
-//		else
-//			snd_out[i] = val;
-	movl	-8(%ebx,%ecx,4),%eax
-	imull	%esi,%eax
-	sarl	$8,%eax
-	cmpl	$0x7FFF,%eax
-	jg		LClampHigh
-	cmpl	$0xFFFF8000,%eax
-	jnl		LClampDone
-	movl	$0xFFFF8000,%eax
-	jmp		LClampDone
-LClampHigh:
-	movl	$0x7FFF,%eax
-LClampDone:
-
-//		val = (snd_p[i+1]*snd_vol)>>8;
-//		if (val > 0x7fff)
-//			snd_out[i+1] = 0x7fff;
-//		else if (val < (short)0x8000)
-//			snd_out[i+1] = (short)0x8000;
-//		else
-//			snd_out[i+1] = val;
-	movl	-4(%ebx,%ecx,4),%edx
-	imull	%esi,%edx
-	sarl	$8,%edx
-	cmpl	$0x7FFF,%edx
-	jg		LClampHigh2
-	cmpl	$0xFFFF8000,%edx
-	jnl		LClampDone2
-	movl	$0xFFFF8000,%edx
-	jmp		LClampDone2
-LClampHigh2:
-	movl	$0x7FFF,%edx
-LClampDone2:
-	shll	$16,%edx
-	andl	$0xFFFF,%eax
-	orl		%eax,%edx
-	movl	%edx,-4(%edi,%ecx,2)
-
-//	}
-	subl	$2,%ecx
-	jnz		LWLBLoopTop
-
-//	snd_p += snd_linear_count;
-
-	popl	%ebx
-	popl	%edi
-	popl	%esi
-
-	ret
-
-
-#endif	// id386
-
diff -ruN WinQuake/snd_sdl.c sdlquake-1.0.9/snd_sdl.c
--- WinQuake/snd_sdl.c	Wed Dec 31 16:00:00 1969
+++ sdlquake-1.0.9/snd_sdl.c	Tue Dec 28 11:16:36 1999
@@ -0,0 +1,112 @@
+
+#include <stdio.h>
+#include "SDL_audio.h"
+#include "SDL_byteorder.h"
+#include "quakedef.h"
+
+static dma_t the_shm;
+static int snd_inited;
+
+extern int desired_speed;
+extern int desired_bits;
+
+static void paint_audio(void *unused, Uint8 *stream, int len)
+{
+	if ( shm ) {
+		shm->buffer = stream;
+		shm->samplepos += len/(shm->samplebits/8)/2;
+		// Check for samplepos overflow?
+		S_PaintChannels (shm->samplepos);
+	}
+}
+
+qboolean SNDDMA_Init(void)
+{
+	SDL_AudioSpec desired, obtained;
+
+	snd_inited = 0;
+
+	/* Set up the desired format */
+	desired.freq = desired_speed;
+	switch (desired_bits) {
+		case 8:
+			desired.format = AUDIO_U8;
+			break;
+		case 16:
+			if ( SDL_BYTEORDER == SDL_BIG_ENDIAN )
+				desired.format = AUDIO_S16MSB;
+			else
+				desired.format = AUDIO_S16LSB;
+			break;
+		default:
+        		Con_Printf("Unknown number of audio bits: %d\n",
+								desired_bits);
+			return 0;
+	}
+	desired.channels = 2;
+	desired.samples = 512;
+	desired.callback = paint_audio;
+
+	/* Open the audio device */
+	if ( SDL_OpenAudio(&desired, &obtained) < 0 ) {
+        	Con_Printf("Couldn't open SDL audio: %s\n", SDL_GetError());
+		return 0;
+	}
+
+	/* Make sure we can support the audio format */
+	switch (obtained.format) {
+		case AUDIO_U8:
+			/* Supported */
+			break;
+		case AUDIO_S16LSB:
+		case AUDIO_S16MSB:
+			if ( ((obtained.format == AUDIO_S16LSB) &&
+			     (SDL_BYTEORDER == SDL_LIL_ENDIAN)) ||
+			     ((obtained.format == AUDIO_S16MSB) &&
+			     (SDL_BYTEORDER == SDL_BIG_ENDIAN)) ) {
+				/* Supported */
+				break;
+			}
+			/* Unsupported, fall through */;
+		default:
+			/* Not supported -- force SDL to do our bidding */
+			SDL_CloseAudio();
+			if ( SDL_OpenAudio(&desired, NULL) < 0 ) {
+        			Con_Printf("Couldn't open SDL audio: %s\n",
+							SDL_GetError());
+				return 0;
+			}
+			memcpy(&obtained, &desired, sizeof(desired));
+			break;
+	}
+	SDL_PauseAudio(0);
+
+	/* Fill the audio DMA information block */
+	shm = &the_shm;
+	shm->splitbuffer = 0;
+	shm->samplebits = (obtained.format & 0xFF);
+	shm->speed = obtained.freq;
+	shm->channels = obtained.channels;
+	shm->samples = obtained.samples*shm->channels;
+	shm->samplepos = 0;
+	shm->submission_chunk = 1;
+	shm->buffer = NULL;
+
+	snd_inited = 1;
+	return 1;
+}
+
+int SNDDMA_GetDMAPos(void)
+{
+	return shm->samplepos;
+}
+
+void SNDDMA_Shutdown(void)
+{
+	if (snd_inited)
+	{
+		SDL_CloseAudio();
+		snd_inited = 0;
+	}
+}
+
diff -ruN WinQuake/surf16.S sdlquake-1.0.9/surf16.S
--- WinQuake/surf16.S	Wed Dec 31 16:00:00 1969
+++ sdlquake-1.0.9/surf16.S	Sat Dec 25 03:38:03 1999
@@ -0,0 +1,172 @@
+/*
+Copyright (C) 1996-1997 Id Software, Inc.
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation; either version 2
+of the License, or (at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
+
+See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+//
+// surf16.s
+// x86 assembly-language 16 bpp surface block drawing code.
+//
+
+#include "asm_i386.h"
+#include "quakeasm.h"
+#include "asm_draw.h"
+
+#if id386
+
+//----------------------------------------------------------------------
+// Surface block drawer
+//----------------------------------------------------------------------
+
+	.data
+
+k:			.long	0
+loopentry:	.long	0
+
+	.align	4
+blockjumptable16:
+	.long	LEnter2_16
+	.long	LEnter4_16
+	.long	0, LEnter8_16
+	.long	0, 0, 0, LEnter16_16
+
+
+	.text
+
+	.align 4
+.globl C(R_Surf16Start)
+C(R_Surf16Start):
+
+	.align 4
+.globl C(R_DrawSurfaceBlock16)
+C(R_DrawSurfaceBlock16):
+	pushl	%ebp				// preserve caller's stack frame
+	pushl	%edi
+	pushl	%esi				// preserve register variables
+	pushl	%ebx
+
+	movl	C(blocksize),%eax
+	movl	C(prowdestbase),%edi
+	movl	C(pbasesource),%esi
+	movl	C(sourcesstep),%ebx
+	movl	blockjumptable16-4(,%eax,2),%ecx
+	movl	%eax,k
+	movl	%ecx,loopentry
+	movl	C(lightleft),%edx
+	movl	C(lightright),%ebp
+
+Lblockloop16:
+
+	subl	%edx,%ebp
+	movb	C(blockdivshift),%cl
+	sarl	%cl,%ebp
+	jns		Lp1_16
+	testl	C(blockdivmask),%ebp
+	jz		Lp1_16
+	incl	%ebp
+Lp1_16:
+
+	subl	%eax,%eax
+	subl	%ecx,%ecx	// high words must be 0 in loop for addressing
+
+	jmp		*loopentry
+
+	.align	4
+
+#include "block16.h"
+
+	movl	C(pbasesource),%esi
+	movl	C(lightleft),%edx
+	movl	C(lightright),%ebp
+	movl	C(sourcetstep),%eax
+	movl	C(lightrightstep),%ecx
+	movl	C(prowdestbase),%edi
+
+	addl	%eax,%esi
+	addl	%ecx,%ebp
+
+	movl	C(lightleftstep),%eax
+	movl	C(surfrowbytes),%ecx
+
+	addl	%eax,%edx
+	addl	%ecx,%edi
+
+	movl	%esi,C(pbasesource)
+	movl	%ebp,C(lightright)
+	movl	k,%eax
+	movl	%edx,C(lightleft)
+	decl	%eax
+	movl	%edi,C(prowdestbase)
+	movl	%eax,k
+	jnz		Lblockloop16
+
+	popl	%ebx				// restore register variables
+	popl	%esi
+	popl	%edi
+	popl	%ebp				// restore the caller's stack frame
+	ret
+
+.globl C(R_Surf16End)
+C(R_Surf16End):
+
+//----------------------------------------------------------------------
+// Code patching routines
+//----------------------------------------------------------------------
+	.data
+
+	.align 4
+LPatchTable16:
+	.long	LBPatch0-4
+	.long	LBPatch1-4
+	.long	LBPatch2-4
+	.long	LBPatch3-4
+	.long	LBPatch4-4
+	.long	LBPatch5-4
+	.long	LBPatch6-4
+	.long	LBPatch7-4
+	.long	LBPatch8-4
+	.long	LBPatch9-4
+	.long	LBPatch10-4
+	.long	LBPatch11-4
+	.long	LBPatch12-4
+	.long	LBPatch13-4
+	.long	LBPatch14-4
+	.long	LBPatch15-4
+
+	.text
+
+	.align 4
+.globl C(R_Surf16Patch)
+C(R_Surf16Patch):
+	pushl	%ebx
+
+	movl	C(colormap),%eax
+	movl	$LPatchTable16,%ebx
+	movl	$16,%ecx
+LPatchLoop16:
+	movl	(%ebx),%edx
+	addl	$4,%ebx
+	movl	%eax,(%edx)
+	decl	%ecx
+	jnz		LPatchLoop16
+
+	popl	%ebx
+
+	ret
+
+
+#endif	// id386
diff -ruN WinQuake/surf16.s sdlquake-1.0.9/surf16.s
--- WinQuake/surf16.s	Tue Dec 21 15:53:26 1999
+++ sdlquake-1.0.9/surf16.s	Wed Dec 31 16:00:00 1969
@@ -1,172 +0,0 @@
-/*
-Copyright (C) 1996-1997 Id Software, Inc.
-
-This program is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License
-as published by the Free Software Foundation; either version 2
-of the License, or (at your option) any later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
-
-See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-*/
-//
-// surf16.s
-// x86 assembly-language 16 bpp surface block drawing code.
-//
-
-#include "asm_i386.h"
-#include "quakeasm.h"
-#include "asm_draw.h"
-
-#if id386
-
-//----------------------------------------------------------------------
-// Surface block drawer
-//----------------------------------------------------------------------
-
-	.data
-
-k:			.long	0
-loopentry:	.long	0
-
-	.align	4
-blockjumptable16:
-	.long	LEnter2_16
-	.long	LEnter4_16
-	.long	0, LEnter8_16
-	.long	0, 0, 0, LEnter16_16
-
-
-	.text
-
-	.align 4
-.globl C(R_Surf16Start)
-C(R_Surf16Start):
-
-	.align 4
-.globl C(R_DrawSurfaceBlock16)
-C(R_DrawSurfaceBlock16):
-	pushl	%ebp				// preserve caller's stack frame
-	pushl	%edi
-	pushl	%esi				// preserve register variables
-	pushl	%ebx
-
-	movl	C(blocksize),%eax
-	movl	C(prowdestbase),%edi
-	movl	C(pbasesource),%esi
-	movl	C(sourcesstep),%ebx
-	movl	blockjumptable16-4(,%eax,2),%ecx
-	movl	%eax,k
-	movl	%ecx,loopentry
-	movl	C(lightleft),%edx
-	movl	C(lightright),%ebp
-
-Lblockloop16:
-
-	subl	%edx,%ebp
-	movb	C(blockdivshift),%cl
-	sarl	%cl,%ebp
-	jns		Lp1_16
-	testl	C(blockdivmask),%ebp
-	jz		Lp1_16
-	incl	%ebp
-Lp1_16:
-
-	subl	%eax,%eax
-	subl	%ecx,%ecx	// high words must be 0 in loop for addressing
-
-	jmp		*loopentry
-
-	.align	4
-
-#include "block16.h"
-
-	movl	C(pbasesource),%esi
-	movl	C(lightleft),%edx
-	movl	C(lightright),%ebp
-	movl	C(sourcetstep),%eax
-	movl	C(lightrightstep),%ecx
-	movl	C(prowdestbase),%edi
-
-	addl	%eax,%esi
-	addl	%ecx,%ebp
-
-	movl	C(lightleftstep),%eax
-	movl	C(surfrowbytes),%ecx
-
-	addl	%eax,%edx
-	addl	%ecx,%edi
-
-	movl	%esi,C(pbasesource)
-	movl	%ebp,C(lightright)
-	movl	k,%eax
-	movl	%edx,C(lightleft)
-	decl	%eax
-	movl	%edi,C(prowdestbase)
-	movl	%eax,k
-	jnz		Lblockloop16
-
-	popl	%ebx				// restore register variables
-	popl	%esi
-	popl	%edi
-	popl	%ebp				// restore the caller's stack frame
-	ret
-
-.globl C(R_Surf16End)
-C(R_Surf16End):
-
-//----------------------------------------------------------------------
-// Code patching routines
-//----------------------------------------------------------------------
-	.data
-
-	.align 4
-LPatchTable16:
-	.long	LBPatch0-4
-	.long	LBPatch1-4
-	.long	LBPatch2-4
-	.long	LBPatch3-4
-	.long	LBPatch4-4
-	.long	LBPatch5-4
-	.long	LBPatch6-4
-	.long	LBPatch7-4
-	.long	LBPatch8-4
-	.long	LBPatch9-4
-	.long	LBPatch10-4
-	.long	LBPatch11-4
-	.long	LBPatch12-4
-	.long	LBPatch13-4
-	.long	LBPatch14-4
-	.long	LBPatch15-4
-
-	.text
-
-	.align 4
-.globl C(R_Surf16Patch)
-C(R_Surf16Patch):
-	pushl	%ebx
-
-	movl	C(colormap),%eax
-	movl	$LPatchTable16,%ebx
-	movl	$16,%ecx
-LPatchLoop16:
-	movl	(%ebx),%edx
-	addl	$4,%ebx
-	movl	%eax,(%edx)
-	decl	%ecx
-	jnz		LPatchLoop16
-
-	popl	%ebx
-
-	ret
-
-
-#endif	// id386
diff -ruN WinQuake/surf8.S sdlquake-1.0.9/surf8.S
--- WinQuake/surf8.S	Wed Dec 31 16:00:00 1969
+++ sdlquake-1.0.9/surf8.S	Sat Dec 25 03:38:03 1999
@@ -0,0 +1,783 @@
+/*
+Copyright (C) 1996-1997 Id Software, Inc.
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation; either version 2
+of the License, or (at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
+
+See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+//
+// surf8.s
+// x86 assembly-language 8 bpp surface block drawing code.
+//
+
+#include "asm_i386.h"
+#include "quakeasm.h"
+#include "asm_draw.h"
+
+#if	id386
+
+	.data
+
+sb_v:		.long	0
+
+	.text
+
+	.align 4
+.globl C(R_Surf8Start)
+C(R_Surf8Start):
+
+//----------------------------------------------------------------------
+// Surface block drawer for mip level 0
+//----------------------------------------------------------------------
+
+	.align 4
+.globl C(R_DrawSurfaceBlock8_mip0)
+C(R_DrawSurfaceBlock8_mip0):
+	pushl	%ebp				// preserve caller's stack frame
+	pushl	%edi
+	pushl	%esi				// preserve register variables
+	pushl	%ebx
+
+//		for (v=0 ; v<numvblocks ; v++)
+//		{
+	movl	C(r_lightptr),%ebx
+	movl	C(r_numvblocks),%eax
+
+	movl	%eax,sb_v
+	movl	C(prowdestbase),%edi
+
+	movl	C(pbasesource),%esi
+
+Lv_loop_mip0:
+
+//			lightleft = lightptr[0];
+//			lightright = lightptr[1];
+//			lightdelta = (lightleft - lightright) & 0xFFFFF;
+	movl	(%ebx),%eax			// lightleft
+	movl	4(%ebx),%edx		// lightright
+
+	movl	%eax,%ebp
+	movl	C(r_lightwidth),%ecx
+
+	movl	%edx,C(lightright)
+	subl	%edx,%ebp
+
+	andl	$0xFFFFF,%ebp
+	leal	(%ebx,%ecx,4),%ebx
+
+//			lightptr += lightwidth;
+	movl	%ebx,C(r_lightptr)
+
+//			lightleftstep = (lightptr[0] - lightleft) >> blockdivshift;
+//			lightrightstep = (lightptr[1] - lightright) >> blockdivshift;
+//			lightdeltastep = ((lightleftstep - lightrightstep) & 0xFFFFF) |
+//					0xF0000000;
+	movl	4(%ebx),%ecx	// lightptr[1]
+	movl	(%ebx),%ebx		// lightptr[0]
+
+	subl	%eax,%ebx
+	subl	%edx,%ecx
+
+	sarl	$4,%ecx
+	orl		$0xF0000000,%ebp
+
+	sarl	$4,%ebx
+	movl	%ecx,C(lightrightstep)
+
+	subl	%ecx,%ebx
+	andl	$0xFFFFF,%ebx
+
+	orl		$0xF0000000,%ebx
+	subl	%ecx,%ecx	// high word must be 0 in loop for addressing
+
+	movl	%ebx,C(lightdeltastep)
+	subl	%ebx,%ebx	// high word must be 0 in loop for addressing
+
+Lblockloop8_mip0:
+	movl	%ebp,C(lightdelta)
+	movb	14(%esi),%cl
+
+	sarl	$4,%ebp
+	movb	%dh,%bh
+
+	movb	15(%esi),%bl
+	addl	%ebp,%edx
+
+	movb	%dh,%ch
+	addl	%ebp,%edx
+
+	movb	0x12345678(%ebx),%ah
+LBPatch0:
+	movb	13(%esi),%bl
+
+	movb	0x12345678(%ecx),%al
+LBPatch1:
+	movb	12(%esi),%cl
+
+	movb	%dh,%bh
+	addl	%ebp,%edx
+
+	rorl	$16,%eax
+	movb	%dh,%ch
+
+	addl	%ebp,%edx
+	movb	0x12345678(%ebx),%ah
+LBPatch2:
+
+	movb	11(%esi),%bl
+	movb	0x12345678(%ecx),%al
+LBPatch3:
+
+	movb	10(%esi),%cl
+	movl	%eax,12(%edi)
+
+	movb	%dh,%bh
+	addl	%ebp,%edx
+
+	movb	%dh,%ch
+	addl	%ebp,%edx
+
+	movb	0x12345678(%ebx),%ah
+LBPatch4:
+	movb	9(%esi),%bl
+
+	movb	0x12345678(%ecx),%al
+LBPatch5:
+	movb	8(%esi),%cl
+
+	movb	%dh,%bh
+	addl	%ebp,%edx
+
+	rorl	$16,%eax
+	movb	%dh,%ch
+
+	addl	%ebp,%edx
+	movb	0x12345678(%ebx),%ah
+LBPatch6:
+
+	movb	7(%esi),%bl
+	movb	0x12345678(%ecx),%al
+LBPatch7:
+
+	movb	6(%esi),%cl
+	movl	%eax,8(%edi)
+
+	movb	%dh,%bh
+	addl	%ebp,%edx
+
+	movb	%dh,%ch
+	addl	%ebp,%edx
+
+	movb	0x12345678(%ebx),%ah
+LBPatch8:
+	movb	5(%esi),%bl
+
+	movb	0x12345678(%ecx),%al
+LBPatch9:
+	movb	4(%esi),%cl
+
+	movb	%dh,%bh
+	addl	%ebp,%edx
+
+	rorl	$16,%eax
+	movb	%dh,%ch
+
+	addl	%ebp,%edx
+	movb	0x12345678(%ebx),%ah
+LBPatch10:
+
+	movb	3(%esi),%bl
+	movb	0x12345678(%ecx),%al
+LBPatch11:
+
+	movb	2(%esi),%cl
+	movl	%eax,4(%edi)
+
+	movb	%dh,%bh
+	addl	%ebp,%edx
+
+	movb	%dh,%ch
+	addl	%ebp,%edx
+
+	movb	0x12345678(%ebx),%ah
+LBPatch12:
+	movb	1(%esi),%bl
+
+	movb	0x12345678(%ecx),%al
+LBPatch13:
+	movb	(%esi),%cl
+
+	movb	%dh,%bh
+	addl	%ebp,%edx
+
+	rorl	$16,%eax
+	movb	%dh,%ch
+
+	movb	0x12345678(%ebx),%ah
+LBPatch14:
+	movl	C(lightright),%edx
+
+	movb	0x12345678(%ecx),%al
+LBPatch15:
+	movl	C(lightdelta),%ebp
+
+	movl	%eax,(%edi)
+
+	addl	C(sourcetstep),%esi
+	addl	C(surfrowbytes),%edi
+
+	addl	C(lightrightstep),%edx
+	addl	C(lightdeltastep),%ebp
+
+	movl	%edx,C(lightright)
+	jc		Lblockloop8_mip0
+
+//			if (pbasesource >= r_sourcemax)
+//				pbasesource -= stepback;
+
+	cmpl	C(r_sourcemax),%esi
+	jb		LSkip_mip0
+	subl	C(r_stepback),%esi
+LSkip_mip0:
+
+	movl	C(r_lightptr),%ebx
+	decl	sb_v
+
+	jnz		Lv_loop_mip0
+
+	popl	%ebx				// restore register variables
+	popl	%esi
+	popl	%edi
+	popl	%ebp				// restore the caller's stack frame
+	ret
+
+
+//----------------------------------------------------------------------
+// Surface block drawer for mip level 1
+//----------------------------------------------------------------------
+
+	.align 4
+.globl C(R_DrawSurfaceBlock8_mip1)
+C(R_DrawSurfaceBlock8_mip1):
+	pushl	%ebp				// preserve caller's stack frame
+	pushl	%edi
+	pushl	%esi				// preserve register variables
+	pushl	%ebx
+
+//		for (v=0 ; v<numvblocks ; v++)
+//		{
+	movl	C(r_lightptr),%ebx
+	movl	C(r_numvblocks),%eax
+
+	movl	%eax,sb_v
+	movl	C(prowdestbase),%edi
+
+	movl	C(pbasesource),%esi
+
+Lv_loop_mip1:
+
+//			lightleft = lightptr[0];
+//			lightright = lightptr[1];
+//			lightdelta = (lightleft - lightright) & 0xFFFFF;
+	movl	(%ebx),%eax			// lightleft
+	movl	4(%ebx),%edx		// lightright
+
+	movl	%eax,%ebp
+	movl	C(r_lightwidth),%ecx
+
+	movl	%edx,C(lightright)
+	subl	%edx,%ebp
+
+	andl	$0xFFFFF,%ebp
+	leal	(%ebx,%ecx,4),%ebx
+
+//			lightptr += lightwidth;
+	movl	%ebx,C(r_lightptr)
+
+//			lightleftstep = (lightptr[0] - lightleft) >> blockdivshift;
+//			lightrightstep = (lightptr[1] - lightright) >> blockdivshift;
+//			lightdeltastep = ((lightleftstep - lightrightstep) & 0xFFFFF) |
+//					0xF0000000;
+	movl	4(%ebx),%ecx	// lightptr[1]
+	movl	(%ebx),%ebx		// lightptr[0]
+
+	subl	%eax,%ebx
+	subl	%edx,%ecx
+
+	sarl	$3,%ecx
+	orl		$0x70000000,%ebp
+
+	sarl	$3,%ebx
+	movl	%ecx,C(lightrightstep)
+
+	subl	%ecx,%ebx
+	andl	$0xFFFFF,%ebx
+
+	orl		$0xF0000000,%ebx
+	subl	%ecx,%ecx	// high word must be 0 in loop for addressing
+
+	movl	%ebx,C(lightdeltastep)
+	subl	%ebx,%ebx	// high word must be 0 in loop for addressing
+
+Lblockloop8_mip1:
+	movl	%ebp,C(lightdelta)
+	movb	6(%esi),%cl
+
+	sarl	$3,%ebp
+	movb	%dh,%bh
+
+	movb	7(%esi),%bl
+	addl	%ebp,%edx
+
+	movb	%dh,%ch
+	addl	%ebp,%edx
+
+	movb	0x12345678(%ebx),%ah
+LBPatch22:
+	movb	5(%esi),%bl
+
+	movb	0x12345678(%ecx),%al
+LBPatch23:
+	movb	4(%esi),%cl
+
+	movb	%dh,%bh
+	addl	%ebp,%edx
+
+	rorl	$16,%eax
+	movb	%dh,%ch
+
+	addl	%ebp,%edx
+	movb	0x12345678(%ebx),%ah
+LBPatch24:
+
+	movb	3(%esi),%bl
+	movb	0x12345678(%ecx),%al
+LBPatch25:
+
+	movb	2(%esi),%cl
+	movl	%eax,4(%edi)
+
+	movb	%dh,%bh
+	addl	%ebp,%edx
+
+	movb	%dh,%ch
+	addl	%ebp,%edx
+
+	movb	0x12345678(%ebx),%ah
+LBPatch26:
+	movb	1(%esi),%bl
+
+	movb	0x12345678(%ecx),%al
+LBPatch27:
+	movb	(%esi),%cl
+
+	movb	%dh,%bh
+	addl	%ebp,%edx
+
+	rorl	$16,%eax
+	movb	%dh,%ch
+
+	movb	0x12345678(%ebx),%ah
+LBPatch28:
+	movl	C(lightright),%edx
+
+	movb	0x12345678(%ecx),%al
+LBPatch29:
+	movl	C(lightdelta),%ebp
+
+	movl	%eax,(%edi)
+	movl	C(sourcetstep),%eax
+
+	addl	%eax,%esi
+	movl	C(surfrowbytes),%eax
+
+	addl	%eax,%edi
+	movl	C(lightrightstep),%eax
+
+	addl	%eax,%edx
+	movl	C(lightdeltastep),%eax
+
+	addl	%eax,%ebp
+	movl	%edx,C(lightright)
+
+	jc		Lblockloop8_mip1
+
+//			if (pbasesource >= r_sourcemax)
+//				pbasesource -= stepback;
+
+	cmpl	C(r_sourcemax),%esi
+	jb		LSkip_mip1
+	subl	C(r_stepback),%esi
+LSkip_mip1:
+
+	movl	C(r_lightptr),%ebx
+	decl	sb_v
+
+	jnz		Lv_loop_mip1
+
+	popl	%ebx				// restore register variables
+	popl	%esi
+	popl	%edi
+	popl	%ebp				// restore the caller's stack frame
+	ret
+
+
+//----------------------------------------------------------------------
+// Surface block drawer for mip level 2
+//----------------------------------------------------------------------
+
+	.align 4
+.globl C(R_DrawSurfaceBlock8_mip2)
+C(R_DrawSurfaceBlock8_mip2):
+	pushl	%ebp				// preserve caller's stack frame
+	pushl	%edi
+	pushl	%esi				// preserve register variables
+	pushl	%ebx
+
+//		for (v=0 ; v<numvblocks ; v++)
+//		{
+	movl	C(r_lightptr),%ebx
+	movl	C(r_numvblocks),%eax
+
+	movl	%eax,sb_v
+	movl	C(prowdestbase),%edi
+
+	movl	C(pbasesource),%esi
+
+Lv_loop_mip2:
+
+//			lightleft = lightptr[0];
+//			lightright = lightptr[1];
+//			lightdelta = (lightleft - lightright) & 0xFFFFF;
+	movl	(%ebx),%eax			// lightleft
+	movl	4(%ebx),%edx		// lightright
+
+	movl	%eax,%ebp
+	movl	C(r_lightwidth),%ecx
+
+	movl	%edx,C(lightright)
+	subl	%edx,%ebp
+
+	andl	$0xFFFFF,%ebp
+	leal	(%ebx,%ecx,4),%ebx
+
+//			lightptr += lightwidth;
+	movl	%ebx,C(r_lightptr)
+
+//			lightleftstep = (lightptr[0] - lightleft) >> blockdivshift;
+//			lightrightstep = (lightptr[1] - lightright) >> blockdivshift;
+//			lightdeltastep = ((lightleftstep - lightrightstep) & 0xFFFFF) |
+//					0xF0000000;
+	movl	4(%ebx),%ecx	// lightptr[1]
+	movl	(%ebx),%ebx		// lightptr[0]
+
+	subl	%eax,%ebx
+	subl	%edx,%ecx
+
+	sarl	$2,%ecx
+	orl		$0x30000000,%ebp
+
+	sarl	$2,%ebx
+	movl	%ecx,C(lightrightstep)
+
+	subl	%ecx,%ebx
+
+	andl	$0xFFFFF,%ebx
+
+	orl		$0xF0000000,%ebx
+	subl	%ecx,%ecx	// high word must be 0 in loop for addressing
+
+	movl	%ebx,C(lightdeltastep)
+	subl	%ebx,%ebx	// high word must be 0 in loop for addressing
+
+Lblockloop8_mip2:
+	movl	%ebp,C(lightdelta)
+	movb	2(%esi),%cl
+
+	sarl	$2,%ebp
+	movb	%dh,%bh
+
+	movb	3(%esi),%bl
+	addl	%ebp,%edx
+
+	movb	%dh,%ch
+	addl	%ebp,%edx
+
+	movb	0x12345678(%ebx),%ah
+LBPatch18:
+	movb	1(%esi),%bl
+
+	movb	0x12345678(%ecx),%al
+LBPatch19:
+	movb	(%esi),%cl
+
+	movb	%dh,%bh
+	addl	%ebp,%edx
+
+	rorl	$16,%eax
+	movb	%dh,%ch
+
+	movb	0x12345678(%ebx),%ah
+LBPatch20:
+	movl	C(lightright),%edx
+
+	movb	0x12345678(%ecx),%al
+LBPatch21:
+	movl	C(lightdelta),%ebp
+
+	movl	%eax,(%edi)
+	movl	C(sourcetstep),%eax
+
+	addl	%eax,%esi
+	movl	C(surfrowbytes),%eax
+
+	addl	%eax,%edi
+	movl	C(lightrightstep),%eax
+
+	addl	%eax,%edx
+	movl	C(lightdeltastep),%eax
+
+	addl	%eax,%ebp
+	movl	%edx,C(lightright)
+
+	jc		Lblockloop8_mip2
+
+//			if (pbasesource >= r_sourcemax)
+//				pbasesource -= stepback;
+
+	cmpl	C(r_sourcemax),%esi
+	jb		LSkip_mip2
+	subl	C(r_stepback),%esi
+LSkip_mip2:
+
+	movl	C(r_lightptr),%ebx
+	decl	sb_v
+
+	jnz		Lv_loop_mip2
+
+	popl	%ebx				// restore register variables
+	popl	%esi
+	popl	%edi
+	popl	%ebp				// restore the caller's stack frame
+	ret
+
+
+//----------------------------------------------------------------------
+// Surface block drawer for mip level 3
+//----------------------------------------------------------------------
+
+	.align 4
+.globl C(R_DrawSurfaceBlock8_mip3)
+C(R_DrawSurfaceBlock8_mip3):
+	pushl	%ebp				// preserve caller's stack frame
+	pushl	%edi
+	pushl	%esi				// preserve register variables
+	pushl	%ebx
+
+//		for (v=0 ; v<numvblocks ; v++)
+//		{
+	movl	C(r_lightptr),%ebx
+	movl	C(r_numvblocks),%eax
+
+	movl	%eax,sb_v
+	movl	C(prowdestbase),%edi
+
+	movl	C(pbasesource),%esi
+
+Lv_loop_mip3:
+
+//			lightleft = lightptr[0];
+//			lightright = lightptr[1];
+//			lightdelta = (lightleft - lightright) & 0xFFFFF;
+	movl	(%ebx),%eax			// lightleft
+	movl	4(%ebx),%edx		// lightright
+
+	movl	%eax,%ebp
+	movl	C(r_lightwidth),%ecx
+
+	movl	%edx,C(lightright)
+	subl	%edx,%ebp
+
+	andl	$0xFFFFF,%ebp
+	leal	(%ebx,%ecx,4),%ebx
+
+	movl	%ebp,C(lightdelta)
+//			lightptr += lightwidth;
+	movl	%ebx,C(r_lightptr)
+
+//			lightleftstep = (lightptr[0] - lightleft) >> blockdivshift;
+//			lightrightstep = (lightptr[1] - lightright) >> blockdivshift;
+//			lightdeltastep = ((lightleftstep - lightrightstep) & 0xFFFFF) |
+//					0xF0000000;
+	movl	4(%ebx),%ecx	// lightptr[1]
+	movl	(%ebx),%ebx		// lightptr[0]
+
+	subl	%eax,%ebx
+	subl	%edx,%ecx
+
+	sarl	$1,%ecx
+
+	sarl	$1,%ebx
+	movl	%ecx,C(lightrightstep)
+
+	subl	%ecx,%ebx
+	andl	$0xFFFFF,%ebx
+
+	sarl	$1,%ebp
+	orl		$0xF0000000,%ebx
+
+	movl	%ebx,C(lightdeltastep)
+	subl	%ebx,%ebx	// high word must be 0 in loop for addressing
+
+	movb	1(%esi),%bl
+	subl	%ecx,%ecx	// high word must be 0 in loop for addressing
+
+	movb	%dh,%bh
+	movb	(%esi),%cl
+
+	addl	%ebp,%edx
+	movb	%dh,%ch
+
+	movb	0x12345678(%ebx),%al
+LBPatch16:
+	movl	C(lightright),%edx
+
+	movb	%al,1(%edi)
+	movb	0x12345678(%ecx),%al
+LBPatch17:
+
+	movb	%al,(%edi)
+	movl	C(sourcetstep),%eax
+
+	addl	%eax,%esi
+	movl	C(surfrowbytes),%eax
+
+	addl	%eax,%edi
+	movl	C(lightdeltastep),%eax
+
+	movl	C(lightdelta),%ebp
+	movb	(%esi),%cl
+
+	addl	%eax,%ebp
+	movl	C(lightrightstep),%eax
+
+	sarl	$1,%ebp
+	addl	%eax,%edx
+
+	movb	%dh,%bh
+	movb	1(%esi),%bl
+
+	addl	%ebp,%edx
+	movb	%dh,%ch
+
+	movb	0x12345678(%ebx),%al
+LBPatch30:
+	movl	C(sourcetstep),%edx
+
+	movb	%al,1(%edi)
+	movb	0x12345678(%ecx),%al
+LBPatch31:
+
+	movb	%al,(%edi)
+	movl	C(surfrowbytes),%ebp
+
+	addl	%edx,%esi
+	addl	%ebp,%edi
+
+//			if (pbasesource >= r_sourcemax)
+//				pbasesource -= stepback;
+
+	cmpl	C(r_sourcemax),%esi
+	jb		LSkip_mip3
+	subl	C(r_stepback),%esi
+LSkip_mip3:
+
+	movl	C(r_lightptr),%ebx
+	decl	sb_v
+
+	jnz		Lv_loop_mip3
+
+	popl	%ebx				// restore register variables
+	popl	%esi
+	popl	%edi
+	popl	%ebp				// restore the caller's stack frame
+	ret
+
+
+.globl C(R_Surf8End)
+C(R_Surf8End):
+
+//----------------------------------------------------------------------
+// Code patching routines
+//----------------------------------------------------------------------
+	.data
+
+	.align 4
+LPatchTable8:
+	.long	LBPatch0-4
+	.long	LBPatch1-4
+	.long	LBPatch2-4
+	.long	LBPatch3-4
+	.long	LBPatch4-4
+	.long	LBPatch5-4
+	.long	LBPatch6-4
+	.long	LBPatch7-4
+	.long	LBPatch8-4
+	.long	LBPatch9-4
+	.long	LBPatch10-4
+	.long	LBPatch11-4
+	.long	LBPatch12-4
+	.long	LBPatch13-4
+	.long	LBPatch14-4
+	.long	LBPatch15-4
+	.long	LBPatch16-4
+	.long	LBPatch17-4
+	.long	LBPatch18-4
+	.long	LBPatch19-4
+	.long	LBPatch20-4
+	.long	LBPatch21-4
+	.long	LBPatch22-4
+	.long	LBPatch23-4
+	.long	LBPatch24-4
+	.long	LBPatch25-4
+	.long	LBPatch26-4
+	.long	LBPatch27-4
+	.long	LBPatch28-4
+	.long	LBPatch29-4
+	.long	LBPatch30-4
+	.long	LBPatch31-4
+
+	.text
+
+	.align 4
+.globl C(R_Surf8Patch)
+C(R_Surf8Patch):
+	pushl	%ebx
+
+	movl	C(colormap),%eax
+	movl	$LPatchTable8,%ebx
+	movl	$32,%ecx
+LPatchLoop8:
+	movl	(%ebx),%edx
+	addl	$4,%ebx
+	movl	%eax,(%edx)
+	decl	%ecx
+	jnz		LPatchLoop8
+
+	popl	%ebx
+
+	ret
+
+#endif	// id386
diff -ruN WinQuake/surf8.s sdlquake-1.0.9/surf8.s
--- WinQuake/surf8.s	Tue Dec 21 15:53:26 1999
+++ sdlquake-1.0.9/surf8.s	Wed Dec 31 16:00:00 1969
@@ -1,783 +0,0 @@
-/*
-Copyright (C) 1996-1997 Id Software, Inc.
-
-This program is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License
-as published by the Free Software Foundation; either version 2
-of the License, or (at your option) any later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
-
-See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-*/
-//
-// surf8.s
-// x86 assembly-language 8 bpp surface block drawing code.
-//
-
-#include "asm_i386.h"
-#include "quakeasm.h"
-#include "asm_draw.h"
-
-#if	id386
-
-	.data
-
-sb_v:		.long	0
-
-	.text
-
-	.align 4
-.globl C(R_Surf8Start)
-C(R_Surf8Start):
-
-//----------------------------------------------------------------------
-// Surface block drawer for mip level 0
-//----------------------------------------------------------------------
-
-	.align 4
-.globl C(R_DrawSurfaceBlock8_mip0)
-C(R_DrawSurfaceBlock8_mip0):
-	pushl	%ebp				// preserve caller's stack frame
-	pushl	%edi
-	pushl	%esi				// preserve register variables
-	pushl	%ebx
-
-//		for (v=0 ; v<numvblocks ; v++)
-//		{
-	movl	C(r_lightptr),%ebx
-	movl	C(r_numvblocks),%eax
-
-	movl	%eax,sb_v
-	movl	C(prowdestbase),%edi
-
-	movl	C(pbasesource),%esi
-
-Lv_loop_mip0:
-
-//			lightleft = lightptr[0];
-//			lightright = lightptr[1];
-//			lightdelta = (lightleft - lightright) & 0xFFFFF;
-	movl	(%ebx),%eax			// lightleft
-	movl	4(%ebx),%edx		// lightright
-
-	movl	%eax,%ebp
-	movl	C(r_lightwidth),%ecx
-
-	movl	%edx,C(lightright)
-	subl	%edx,%ebp
-
-	andl	$0xFFFFF,%ebp
-	leal	(%ebx,%ecx,4),%ebx
-
-//			lightptr += lightwidth;
-	movl	%ebx,C(r_lightptr)
-
-//			lightleftstep = (lightptr[0] - lightleft) >> blockdivshift;
-//			lightrightstep = (lightptr[1] - lightright) >> blockdivshift;
-//			lightdeltastep = ((lightleftstep - lightrightstep) & 0xFFFFF) |
-//					0xF0000000;
-	movl	4(%ebx),%ecx	// lightptr[1]
-	movl	(%ebx),%ebx		// lightptr[0]
-
-	subl	%eax,%ebx
-	subl	%edx,%ecx
-
-	sarl	$4,%ecx
-	orl		$0xF0000000,%ebp
-
-	sarl	$4,%ebx
-	movl	%ecx,C(lightrightstep)
-
-	subl	%ecx,%ebx
-	andl	$0xFFFFF,%ebx
-
-	orl		$0xF0000000,%ebx
-	subl	%ecx,%ecx	// high word must be 0 in loop for addressing
-
-	movl	%ebx,C(lightdeltastep)
-	subl	%ebx,%ebx	// high word must be 0 in loop for addressing
-
-Lblockloop8_mip0:
-	movl	%ebp,C(lightdelta)
-	movb	14(%esi),%cl
-
-	sarl	$4,%ebp
-	movb	%dh,%bh
-
-	movb	15(%esi),%bl
-	addl	%ebp,%edx
-
-	movb	%dh,%ch
-	addl	%ebp,%edx
-
-	movb	0x12345678(%ebx),%ah
-LBPatch0:
-	movb	13(%esi),%bl
-
-	movb	0x12345678(%ecx),%al
-LBPatch1:
-	movb	12(%esi),%cl
-
-	movb	%dh,%bh
-	addl	%ebp,%edx
-
-	rorl	$16,%eax
-	movb	%dh,%ch
-
-	addl	%ebp,%edx
-	movb	0x12345678(%ebx),%ah
-LBPatch2:
-
-	movb	11(%esi),%bl
-	movb	0x12345678(%ecx),%al
-LBPatch3:
-
-	movb	10(%esi),%cl
-	movl	%eax,12(%edi)
-
-	movb	%dh,%bh
-	addl	%ebp,%edx
-
-	movb	%dh,%ch
-	addl	%ebp,%edx
-
-	movb	0x12345678(%ebx),%ah
-LBPatch4:
-	movb	9(%esi),%bl
-
-	movb	0x12345678(%ecx),%al
-LBPatch5:
-	movb	8(%esi),%cl
-
-	movb	%dh,%bh
-	addl	%ebp,%edx
-
-	rorl	$16,%eax
-	movb	%dh,%ch
-
-	addl	%ebp,%edx
-	movb	0x12345678(%ebx),%ah
-LBPatch6:
-
-	movb	7(%esi),%bl
-	movb	0x12345678(%ecx),%al
-LBPatch7:
-
-	movb	6(%esi),%cl
-	movl	%eax,8(%edi)
-
-	movb	%dh,%bh
-	addl	%ebp,%edx
-
-	movb	%dh,%ch
-	addl	%ebp,%edx
-
-	movb	0x12345678(%ebx),%ah
-LBPatch8:
-	movb	5(%esi),%bl
-
-	movb	0x12345678(%ecx),%al
-LBPatch9:
-	movb	4(%esi),%cl
-
-	movb	%dh,%bh
-	addl	%ebp,%edx
-
-	rorl	$16,%eax
-	movb	%dh,%ch
-
-	addl	%ebp,%edx
-	movb	0x12345678(%ebx),%ah
-LBPatch10:
-
-	movb	3(%esi),%bl
-	movb	0x12345678(%ecx),%al
-LBPatch11:
-
-	movb	2(%esi),%cl
-	movl	%eax,4(%edi)
-
-	movb	%dh,%bh
-	addl	%ebp,%edx
-
-	movb	%dh,%ch
-	addl	%ebp,%edx
-
-	movb	0x12345678(%ebx),%ah
-LBPatch12:
-	movb	1(%esi),%bl
-
-	movb	0x12345678(%ecx),%al
-LBPatch13:
-	movb	(%esi),%cl
-
-	movb	%dh,%bh
-	addl	%ebp,%edx
-
-	rorl	$16,%eax
-	movb	%dh,%ch
-
-	movb	0x12345678(%ebx),%ah
-LBPatch14:
-	movl	C(lightright),%edx
-
-	movb	0x12345678(%ecx),%al
-LBPatch15:
-	movl	C(lightdelta),%ebp
-
-	movl	%eax,(%edi)
-
-	addl	C(sourcetstep),%esi
-	addl	C(surfrowbytes),%edi
-
-	addl	C(lightrightstep),%edx
-	addl	C(lightdeltastep),%ebp
-
-	movl	%edx,C(lightright)
-	jc		Lblockloop8_mip0
-
-//			if (pbasesource >= r_sourcemax)
-//				pbasesource -= stepback;
-
-	cmpl	C(r_sourcemax),%esi
-	jb		LSkip_mip0
-	subl	C(r_stepback),%esi
-LSkip_mip0:
-
-	movl	C(r_lightptr),%ebx
-	decl	sb_v
-
-	jnz		Lv_loop_mip0
-
-	popl	%ebx				// restore register variables
-	popl	%esi
-	popl	%edi
-	popl	%ebp				// restore the caller's stack frame
-	ret
-
-
-//----------------------------------------------------------------------
-// Surface block drawer for mip level 1
-//----------------------------------------------------------------------
-
-	.align 4
-.globl C(R_DrawSurfaceBlock8_mip1)
-C(R_DrawSurfaceBlock8_mip1):
-	pushl	%ebp				// preserve caller's stack frame
-	pushl	%edi
-	pushl	%esi				// preserve register variables
-	pushl	%ebx
-
-//		for (v=0 ; v<numvblocks ; v++)
-//		{
-	movl	C(r_lightptr),%ebx
-	movl	C(r_numvblocks),%eax
-
-	movl	%eax,sb_v
-	movl	C(prowdestbase),%edi
-
-	movl	C(pbasesource),%esi
-
-Lv_loop_mip1:
-
-//			lightleft = lightptr[0];
-//			lightright = lightptr[1];
-//			lightdelta = (lightleft - lightright) & 0xFFFFF;
-	movl	(%ebx),%eax			// lightleft
-	movl	4(%ebx),%edx		// lightright
-
-	movl	%eax,%ebp
-	movl	C(r_lightwidth),%ecx
-
-	movl	%edx,C(lightright)
-	subl	%edx,%ebp
-
-	andl	$0xFFFFF,%ebp
-	leal	(%ebx,%ecx,4),%ebx
-
-//			lightptr += lightwidth;
-	movl	%ebx,C(r_lightptr)
-
-//			lightleftstep = (lightptr[0] - lightleft) >> blockdivshift;
-//			lightrightstep = (lightptr[1] - lightright) >> blockdivshift;
-//			lightdeltastep = ((lightleftstep - lightrightstep) & 0xFFFFF) |
-//					0xF0000000;
-	movl	4(%ebx),%ecx	// lightptr[1]
-	movl	(%ebx),%ebx		// lightptr[0]
-
-	subl	%eax,%ebx
-	subl	%edx,%ecx
-
-	sarl	$3,%ecx
-	orl		$0x70000000,%ebp
-
-	sarl	$3,%ebx
-	movl	%ecx,C(lightrightstep)
-
-	subl	%ecx,%ebx
-	andl	$0xFFFFF,%ebx
-
-	orl		$0xF0000000,%ebx
-	subl	%ecx,%ecx	// high word must be 0 in loop for addressing
-
-	movl	%ebx,C(lightdeltastep)
-	subl	%ebx,%ebx	// high word must be 0 in loop for addressing
-
-Lblockloop8_mip1:
-	movl	%ebp,C(lightdelta)
-	movb	6(%esi),%cl
-
-	sarl	$3,%ebp
-	movb	%dh,%bh
-
-	movb	7(%esi),%bl
-	addl	%ebp,%edx
-
-	movb	%dh,%ch
-	addl	%ebp,%edx
-
-	movb	0x12345678(%ebx),%ah
-LBPatch22:
-	movb	5(%esi),%bl
-
-	movb	0x12345678(%ecx),%al
-LBPatch23:
-	movb	4(%esi),%cl
-
-	movb	%dh,%bh
-	addl	%ebp,%edx
-
-	rorl	$16,%eax
-	movb	%dh,%ch
-
-	addl	%ebp,%edx
-	movb	0x12345678(%ebx),%ah
-LBPatch24:
-
-	movb	3(%esi),%bl
-	movb	0x12345678(%ecx),%al
-LBPatch25:
-
-	movb	2(%esi),%cl
-	movl	%eax,4(%edi)
-
-	movb	%dh,%bh
-	addl	%ebp,%edx
-
-	movb	%dh,%ch
-	addl	%ebp,%edx
-
-	movb	0x12345678(%ebx),%ah
-LBPatch26:
-	movb	1(%esi),%bl
-
-	movb	0x12345678(%ecx),%al
-LBPatch27:
-	movb	(%esi),%cl
-
-	movb	%dh,%bh
-	addl	%ebp,%edx
-
-	rorl	$16,%eax
-	movb	%dh,%ch
-
-	movb	0x12345678(%ebx),%ah
-LBPatch28:
-	movl	C(lightright),%edx
-
-	movb	0x12345678(%ecx),%al
-LBPatch29:
-	movl	C(lightdelta),%ebp
-
-	movl	%eax,(%edi)
-	movl	C(sourcetstep),%eax
-
-	addl	%eax,%esi
-	movl	C(surfrowbytes),%eax
-
-	addl	%eax,%edi
-	movl	C(lightrightstep),%eax
-
-	addl	%eax,%edx
-	movl	C(lightdeltastep),%eax
-
-	addl	%eax,%ebp
-	movl	%edx,C(lightright)
-
-	jc		Lblockloop8_mip1
-
-//			if (pbasesource >= r_sourcemax)
-//				pbasesource -= stepback;
-
-	cmpl	C(r_sourcemax),%esi
-	jb		LSkip_mip1
-	subl	C(r_stepback),%esi
-LSkip_mip1:
-
-	movl	C(r_lightptr),%ebx
-	decl	sb_v
-
-	jnz		Lv_loop_mip1
-
-	popl	%ebx				// restore register variables
-	popl	%esi
-	popl	%edi
-	popl	%ebp				// restore the caller's stack frame
-	ret
-
-
-//----------------------------------------------------------------------
-// Surface block drawer for mip level 2
-//----------------------------------------------------------------------
-
-	.align 4
-.globl C(R_DrawSurfaceBlock8_mip2)
-C(R_DrawSurfaceBlock8_mip2):
-	pushl	%ebp				// preserve caller's stack frame
-	pushl	%edi
-	pushl	%esi				// preserve register variables
-	pushl	%ebx
-
-//		for (v=0 ; v<numvblocks ; v++)
-//		{
-	movl	C(r_lightptr),%ebx
-	movl	C(r_numvblocks),%eax
-
-	movl	%eax,sb_v
-	movl	C(prowdestbase),%edi
-
-	movl	C(pbasesource),%esi
-
-Lv_loop_mip2:
-
-//			lightleft = lightptr[0];
-//			lightright = lightptr[1];
-//			lightdelta = (lightleft - lightright) & 0xFFFFF;
-	movl	(%ebx),%eax			// lightleft
-	movl	4(%ebx),%edx		// lightright
-
-	movl	%eax,%ebp
-	movl	C(r_lightwidth),%ecx
-
-	movl	%edx,C(lightright)
-	subl	%edx,%ebp
-
-	andl	$0xFFFFF,%ebp
-	leal	(%ebx,%ecx,4),%ebx
-
-//			lightptr += lightwidth;
-	movl	%ebx,C(r_lightptr)
-
-//			lightleftstep = (lightptr[0] - lightleft) >> blockdivshift;
-//			lightrightstep = (lightptr[1] - lightright) >> blockdivshift;
-//			lightdeltastep = ((lightleftstep - lightrightstep) & 0xFFFFF) |
-//					0xF0000000;
-	movl	4(%ebx),%ecx	// lightptr[1]
-	movl	(%ebx),%ebx		// lightptr[0]
-
-	subl	%eax,%ebx
-	subl	%edx,%ecx
-
-	sarl	$2,%ecx
-	orl		$0x30000000,%ebp
-
-	sarl	$2,%ebx
-	movl	%ecx,C(lightrightstep)
-
-	subl	%ecx,%ebx
-
-	andl	$0xFFFFF,%ebx
-
-	orl		$0xF0000000,%ebx
-	subl	%ecx,%ecx	// high word must be 0 in loop for addressing
-
-	movl	%ebx,C(lightdeltastep)
-	subl	%ebx,%ebx	// high word must be 0 in loop for addressing
-
-Lblockloop8_mip2:
-	movl	%ebp,C(lightdelta)
-	movb	2(%esi),%cl
-
-	sarl	$2,%ebp
-	movb	%dh,%bh
-
-	movb	3(%esi),%bl
-	addl	%ebp,%edx
-
-	movb	%dh,%ch
-	addl	%ebp,%edx
-
-	movb	0x12345678(%ebx),%ah
-LBPatch18:
-	movb	1(%esi),%bl
-
-	movb	0x12345678(%ecx),%al
-LBPatch19:
-	movb	(%esi),%cl
-
-	movb	%dh,%bh
-	addl	%ebp,%edx
-
-	rorl	$16,%eax
-	movb	%dh,%ch
-
-	movb	0x12345678(%ebx),%ah
-LBPatch20:
-	movl	C(lightright),%edx
-
-	movb	0x12345678(%ecx),%al
-LBPatch21:
-	movl	C(lightdelta),%ebp
-
-	movl	%eax,(%edi)
-	movl	C(sourcetstep),%eax
-
-	addl	%eax,%esi
-	movl	C(surfrowbytes),%eax
-
-	addl	%eax,%edi
-	movl	C(lightrightstep),%eax
-
-	addl	%eax,%edx
-	movl	C(lightdeltastep),%eax
-
-	addl	%eax,%ebp
-	movl	%edx,C(lightright)
-
-	jc		Lblockloop8_mip2
-
-//			if (pbasesource >= r_sourcemax)
-//				pbasesource -= stepback;
-
-	cmpl	C(r_sourcemax),%esi
-	jb		LSkip_mip2
-	subl	C(r_stepback),%esi
-LSkip_mip2:
-
-	movl	C(r_lightptr),%ebx
-	decl	sb_v
-
-	jnz		Lv_loop_mip2
-
-	popl	%ebx				// restore register variables
-	popl	%esi
-	popl	%edi
-	popl	%ebp				// restore the caller's stack frame
-	ret
-
-
-//----------------------------------------------------------------------
-// Surface block drawer for mip level 3
-//----------------------------------------------------------------------
-
-	.align 4
-.globl C(R_DrawSurfaceBlock8_mip3)
-C(R_DrawSurfaceBlock8_mip3):
-	pushl	%ebp				// preserve caller's stack frame
-	pushl	%edi
-	pushl	%esi				// preserve register variables
-	pushl	%ebx
-
-//		for (v=0 ; v<numvblocks ; v++)
-//		{
-	movl	C(r_lightptr),%ebx
-	movl	C(r_numvblocks),%eax
-
-	movl	%eax,sb_v
-	movl	C(prowdestbase),%edi
-
-	movl	C(pbasesource),%esi
-
-Lv_loop_mip3:
-
-//			lightleft = lightptr[0];
-//			lightright = lightptr[1];
-//			lightdelta = (lightleft - lightright) & 0xFFFFF;
-	movl	(%ebx),%eax			// lightleft
-	movl	4(%ebx),%edx		// lightright
-
-	movl	%eax,%ebp
-	movl	C(r_lightwidth),%ecx
-
-	movl	%edx,C(lightright)
-	subl	%edx,%ebp
-
-	andl	$0xFFFFF,%ebp
-	leal	(%ebx,%ecx,4),%ebx
-
-	movl	%ebp,C(lightdelta)
-//			lightptr += lightwidth;
-	movl	%ebx,C(r_lightptr)
-
-//			lightleftstep = (lightptr[0] - lightleft) >> blockdivshift;
-//			lightrightstep = (lightptr[1] - lightright) >> blockdivshift;
-//			lightdeltastep = ((lightleftstep - lightrightstep) & 0xFFFFF) |
-//					0xF0000000;
-	movl	4(%ebx),%ecx	// lightptr[1]
-	movl	(%ebx),%ebx		// lightptr[0]
-
-	subl	%eax,%ebx
-	subl	%edx,%ecx
-
-	sarl	$1,%ecx
-
-	sarl	$1,%ebx
-	movl	%ecx,C(lightrightstep)
-
-	subl	%ecx,%ebx
-	andl	$0xFFFFF,%ebx
-
-	sarl	$1,%ebp
-	orl		$0xF0000000,%ebx
-
-	movl	%ebx,C(lightdeltastep)
-	subl	%ebx,%ebx	// high word must be 0 in loop for addressing
-
-	movb	1(%esi),%bl
-	subl	%ecx,%ecx	// high word must be 0 in loop for addressing
-
-	movb	%dh,%bh
-	movb	(%esi),%cl
-
-	addl	%ebp,%edx
-	movb	%dh,%ch
-
-	movb	0x12345678(%ebx),%al
-LBPatch16:
-	movl	C(lightright),%edx
-
-	movb	%al,1(%edi)
-	movb	0x12345678(%ecx),%al
-LBPatch17:
-
-	movb	%al,(%edi)
-	movl	C(sourcetstep),%eax
-
-	addl	%eax,%esi
-	movl	C(surfrowbytes),%eax
-
-	addl	%eax,%edi
-	movl	C(lightdeltastep),%eax
-
-	movl	C(lightdelta),%ebp
-	movb	(%esi),%cl
-
-	addl	%eax,%ebp
-	movl	C(lightrightstep),%eax
-
-	sarl	$1,%ebp
-	addl	%eax,%edx
-
-	movb	%dh,%bh
-	movb	1(%esi),%bl
-
-	addl	%ebp,%edx
-	movb	%dh,%ch
-
-	movb	0x12345678(%ebx),%al
-LBPatch30:
-	movl	C(sourcetstep),%edx
-
-	movb	%al,1(%edi)
-	movb	0x12345678(%ecx),%al
-LBPatch31:
-
-	movb	%al,(%edi)
-	movl	C(surfrowbytes),%ebp
-
-	addl	%edx,%esi
-	addl	%ebp,%edi
-
-//			if (pbasesource >= r_sourcemax)
-//				pbasesource -= stepback;
-
-	cmpl	C(r_sourcemax),%esi
-	jb		LSkip_mip3
-	subl	C(r_stepback),%esi
-LSkip_mip3:
-
-	movl	C(r_lightptr),%ebx
-	decl	sb_v
-
-	jnz		Lv_loop_mip3
-
-	popl	%ebx				// restore register variables
-	popl	%esi
-	popl	%edi
-	popl	%ebp				// restore the caller's stack frame
-	ret
-
-
-.globl C(R_Surf8End)
-C(R_Surf8End):
-
-//----------------------------------------------------------------------
-// Code patching routines
-//----------------------------------------------------------------------
-	.data
-
-	.align 4
-LPatchTable8:
-	.long	LBPatch0-4
-	.long	LBPatch1-4
-	.long	LBPatch2-4
-	.long	LBPatch3-4
-	.long	LBPatch4-4
-	.long	LBPatch5-4
-	.long	LBPatch6-4
-	.long	LBPatch7-4
-	.long	LBPatch8-4
-	.long	LBPatch9-4
-	.long	LBPatch10-4
-	.long	LBPatch11-4
-	.long	LBPatch12-4
-	.long	LBPatch13-4
-	.long	LBPatch14-4
-	.long	LBPatch15-4
-	.long	LBPatch16-4
-	.long	LBPatch17-4
-	.long	LBPatch18-4
-	.long	LBPatch19-4
-	.long	LBPatch20-4
-	.long	LBPatch21-4
-	.long	LBPatch22-4
-	.long	LBPatch23-4
-	.long	LBPatch24-4
-	.long	LBPatch25-4
-	.long	LBPatch26-4
-	.long	LBPatch27-4
-	.long	LBPatch28-4
-	.long	LBPatch29-4
-	.long	LBPatch30-4
-	.long	LBPatch31-4
-
-	.text
-
-	.align 4
-.globl C(R_Surf8Patch)
-C(R_Surf8Patch):
-	pushl	%ebx
-
-	movl	C(colormap),%eax
-	movl	$LPatchTable8,%ebx
-	movl	$32,%ecx
-LPatchLoop8:
-	movl	(%ebx),%edx
-	addl	$4,%ebx
-	movl	%eax,(%edx)
-	decl	%ecx
-	jnz		LPatchLoop8
-
-	popl	%ebx
-
-	ret
-
-#endif	// id386
diff -ruN WinQuake/sys_dosa.S sdlquake-1.0.9/sys_dosa.S
--- WinQuake/sys_dosa.S	Wed Dec 31 16:00:00 1969
+++ sdlquake-1.0.9/sys_dosa.S	Tue Dec 28 11:10:34 1999
@@ -0,0 +1,98 @@
+//
+// sys_dosa.s
+// x86 assembly-language DOS-dependent routines.
+
+#include "asm_i386.h"
+#include "quakeasm.h"
+
+
+#if id386
+
+	.data
+
+	.align	4
+fpenv:
+	.long	0, 0, 0, 0, 0, 0, 0, 0
+
+	.text
+
+.globl C(MaskExceptions)
+C(MaskExceptions):
+	fnstenv	fpenv
+	orl		$0x3F,fpenv
+	fldenv	fpenv
+
+	ret
+
+#if 0
+.globl C(unmaskexceptions)
+C(unmaskexceptions):
+	fnstenv	fpenv
+	andl		$0xFFFFFFE0,fpenv
+	fldenv	fpenv
+
+	ret
+#endif
+
+	.data
+
+	.align	4
+.globl	ceil_cw, single_cw, full_cw, cw, pushed_cw
+ceil_cw:	.long	0
+single_cw:	.long	0
+full_cw:	.long	0
+cw:			.long	0
+pushed_cw:	.long	0
+
+	.text
+
+.globl C(Sys_LowFPPrecision)
+C(Sys_LowFPPrecision):
+	fldcw	single_cw
+
+	ret
+
+.globl C(Sys_HighFPPrecision)
+C(Sys_HighFPPrecision):
+	fldcw	full_cw
+
+	ret
+
+.globl C(Sys_PushFPCW_SetHigh)
+C(Sys_PushFPCW_SetHigh):
+	fnstcw	pushed_cw
+	fldcw	full_cw
+
+	ret
+
+.globl C(Sys_PopFPCW)
+C(Sys_PopFPCW):
+	fldcw	pushed_cw
+
+	ret
+
+.globl C(Sys_SetFPCW)
+C(Sys_SetFPCW):
+	fnstcw	cw
+	movl	cw,%eax
+#if	id386
+	andb	$0xF0,%ah
+	orb		$0x03,%ah	// round mode, 64-bit precision
+#endif
+	movl	%eax,full_cw
+
+#if	id386
+	andb	$0xF0,%ah
+	orb		$0x0C,%ah	// chop mode, single precision
+#endif
+	movl	%eax,single_cw
+
+#if	id386
+	andb	$0xF0,%ah
+	orb		$0x08,%ah	// ceil mode, single precision
+#endif
+	movl	%eax,ceil_cw
+
+	ret
+
+#endif
diff -ruN WinQuake/sys_dosa.s sdlquake-1.0.9/sys_dosa.s
--- WinQuake/sys_dosa.s	Wed Aug 12 12:45:38 1998
+++ sdlquake-1.0.9/sys_dosa.s	Wed Dec 31 16:00:00 1969
@@ -1,95 +0,0 @@
-//
-// sys_dosa.s
-// x86 assembly-language DOS-dependent routines.
-
-#include "asm_i386.h"
-#include "quakeasm.h"
-
-
-	.data
-
-	.align	4
-fpenv:
-	.long	0, 0, 0, 0, 0, 0, 0, 0
-
-	.text
-
-.globl C(MaskExceptions)
-C(MaskExceptions):
-	fnstenv	fpenv
-	orl		$0x3F,fpenv
-	fldenv	fpenv
-
-	ret
-
-#if 0
-.globl C(unmaskexceptions)
-C(unmaskexceptions):
-	fnstenv	fpenv
-	andl		$0xFFFFFFE0,fpenv
-	fldenv	fpenv
-
-	ret
-#endif
-
-	.data
-
-	.align	4
-.globl	ceil_cw, single_cw, full_cw, cw, pushed_cw
-ceil_cw:	.long	0
-single_cw:	.long	0
-full_cw:	.long	0
-cw:			.long	0
-pushed_cw:	.long	0
-
-	.text
-
-.globl C(Sys_LowFPPrecision)
-C(Sys_LowFPPrecision):
-	fldcw	single_cw
-
-	ret
-
-.globl C(Sys_HighFPPrecision)
-C(Sys_HighFPPrecision):
-	fldcw	full_cw
-
-	ret
-
-.globl C(Sys_PushFPCW_SetHigh)
-C(Sys_PushFPCW_SetHigh):
-	fnstcw	pushed_cw
-	fldcw	full_cw
-
-	ret
-
-.globl C(Sys_PopFPCW)
-C(Sys_PopFPCW):
-	fldcw	pushed_cw
-
-	ret
-
-.globl C(Sys_SetFPCW)
-C(Sys_SetFPCW):
-	fnstcw	cw
-	movl	cw,%eax
-#if	id386
-	andb	$0xF0,%ah
-	orb		$0x03,%ah	// round mode, 64-bit precision
-#endif
-	movl	%eax,full_cw
-
-#if	id386
-	andb	$0xF0,%ah
-	orb		$0x0C,%ah	// chop mode, single precision
-#endif
-	movl	%eax,single_cw
-
-#if	id386
-	andb	$0xF0,%ah
-	orb		$0x08,%ah	// ceil mode, single precision
-#endif
-	movl	%eax,ceil_cw
-
-	ret
-
diff -ruN WinQuake/sys_sdl.c sdlquake-1.0.9/sys_sdl.c
--- WinQuake/sys_sdl.c	Wed Dec 31 16:00:00 1969
+++ sdlquake-1.0.9/sys_sdl.c	Sat Dec 25 04:14:37 1999
@@ -0,0 +1,454 @@
+#include <unistd.h>
+#include <signal.h>
+#include <stdlib.h>
+#include <limits.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include <errno.h>
+#ifndef __WIN32__
+#include <sys/ipc.h>
+#include <sys/shm.h>
+#include <sys/stat.h>
+#include <sys/wait.h>
+#include <sys/mman.h>
+#endif
+
+#include "quakedef.h"
+
+qboolean			isDedicated;
+
+int noconinput = 0;
+
+char *basedir = ".";
+char *cachedir = "/tmp";
+
+cvar_t  sys_linerefresh = {"sys_linerefresh","0"};// set for entity display
+cvar_t  sys_nostdout = {"sys_nostdout","0"};
+
+// =======================================================================
+// General routines
+// =======================================================================
+
+void Sys_DebugNumber(int y, int val)
+{
+}
+
+void Sys_Printf (char *fmt, ...)
+{
+	va_list		argptr;
+	char		text[1024];
+	
+	va_start (argptr,fmt);
+	vsprintf (text,fmt,argptr);
+	va_end (argptr);
+	fprintf(stderr, "%s", text);
+	
+	//Con_Print (text);
+}
+
+void Sys_Quit (void)
+{
+	Host_Shutdown();
+	exit(0);
+}
+
+void Sys_Init(void)
+{
+#if id386
+	Sys_SetFPCW();
+#endif
+}
+
+#if !id386
+
+/*
+================
+Sys_LowFPPrecision
+================
+*/
+void Sys_LowFPPrecision (void)
+{
+// causes weird problems on Nextstep
+}
+
+
+/*
+================
+Sys_HighFPPrecision
+================
+*/
+void Sys_HighFPPrecision (void)
+{
+// causes weird problems on Nextstep
+}
+
+#endif	// !id386
+
+
+void Sys_Error (char *error, ...)
+{ 
+    va_list     argptr;
+    char        string[1024];
+
+    va_start (argptr,error);
+    vsprintf (string,error,argptr);
+    va_end (argptr);
+	fprintf(stderr, "Error: %s\n", string);
+
+	Host_Shutdown ();
+	exit (1);
+
+} 
+
+void Sys_Warn (char *warning, ...)
+{ 
+    va_list     argptr;
+    char        string[1024];
+    
+    va_start (argptr,warning);
+    vsprintf (string,warning,argptr);
+    va_end (argptr);
+	fprintf(stderr, "Warning: %s", string);
+} 
+
+/*
+===============================================================================
+
+FILE IO
+
+===============================================================================
+*/
+
+#define	MAX_HANDLES		10
+FILE	*sys_handles[MAX_HANDLES];
+
+int		findhandle (void)
+{
+	int		i;
+	
+	for (i=1 ; i<MAX_HANDLES ; i++)
+		if (!sys_handles[i])
+			return i;
+	Sys_Error ("out of handles");
+	return -1;
+}
+
+/*
+================
+Qfilelength
+================
+*/
+static int Qfilelength (FILE *f)
+{
+	int		pos;
+	int		end;
+
+	pos = ftell (f);
+	fseek (f, 0, SEEK_END);
+	end = ftell (f);
+	fseek (f, pos, SEEK_SET);
+
+	return end;
+}
+
+int Sys_FileOpenRead (char *path, int *hndl)
+{
+	FILE	*f;
+	int		i;
+	
+	i = findhandle ();
+
+	f = fopen(path, "rb");
+	if (!f)
+	{
+		*hndl = -1;
+		return -1;
+	}
+	sys_handles[i] = f;
+	*hndl = i;
+	
+	return Qfilelength(f);
+}
+
+int Sys_FileOpenWrite (char *path)
+{
+	FILE	*f;
+	int		i;
+	
+	i = findhandle ();
+
+	f = fopen(path, "wb");
+	if (!f)
+		Sys_Error ("Error opening %s: %s", path,strerror(errno));
+	sys_handles[i] = f;
+	
+	return i;
+}
+
+void Sys_FileClose (int handle)
+{
+	if ( handle >= 0 ) {
+		fclose (sys_handles[handle]);
+		sys_handles[handle] = NULL;
+	}
+}
+
+void Sys_FileSeek (int handle, int position)
+{
+	if ( handle >= 0 ) {
+		fseek (sys_handles[handle], position, SEEK_SET);
+	}
+}
+
+int Sys_FileRead (int handle, void *dst, int count)
+{
+	char *data;
+	int size, done;
+
+	size = 0;
+	if ( handle >= 0 ) {
+		data = dst;
+		while ( count > 0 ) {
+			done = fread (data, 1, count, sys_handles[handle]);
+			if ( done == 0 ) {
+				break;
+			}
+			data += done;
+			count -= done;
+			size += done;
+		}
+	}
+	return size;
+		
+}
+
+int Sys_FileWrite (int handle, void *src, int count)
+{
+	char *data;
+	int size, done;
+
+	size = 0;
+	if ( handle >= 0 ) {
+		data = src;
+		while ( count > 0 ) {
+			done = fread (data, 1, count, sys_handles[handle]);
+			if ( done == 0 ) {
+				break;
+			}
+			data += done;
+			count -= done;
+			size += done;
+		}
+	}
+	return size;
+}
+
+int	Sys_FileTime (char *path)
+{
+	FILE	*f;
+	
+	f = fopen(path, "rb");
+	if (f)
+	{
+		fclose(f);
+		return 1;
+	}
+	
+	return -1;
+}
+
+void Sys_mkdir (char *path)
+{
+#ifdef __WIN32__
+    mkdir (path);
+#else
+    mkdir (path, 0777);
+#endif
+}
+
+void Sys_DebugLog(char *file, char *fmt, ...)
+{
+    va_list argptr; 
+    static char data[1024];
+    FILE *fp;
+    
+    va_start(argptr, fmt);
+    vsprintf(data, fmt, argptr);
+    va_end(argptr);
+    fp = fopen(file, "a");
+    fwrite(data, strlen(data), 1, fp);
+    fclose(fp);
+}
+
+double Sys_FloatTime (void)
+{
+#ifdef __WIN32__
+
+	static int starttime = 0;
+
+	if ( ! starttime )
+		starttime = clock();
+
+	return (clock()-starttime)*1.0/1024;
+
+#else
+
+    struct timeval tp;
+    struct timezone tzp; 
+    static int      secbase; 
+    
+    gettimeofday(&tp, &tzp);  
+
+    if (!secbase)
+    {
+        secbase = tp.tv_sec;
+        return tp.tv_usec/1000000.0;
+    }
+
+    return (tp.tv_sec - secbase) + tp.tv_usec/1000000.0;
+
+#endif
+}
+
+// =======================================================================
+// Sleeps for microseconds
+// =======================================================================
+
+static volatile int oktogo;
+
+void alarm_handler(int x)
+{
+	oktogo=1;
+}
+
+byte *Sys_ZoneBase (int *size)
+{
+
+	char *QUAKEOPT = getenv("QUAKEOPT");
+
+	*size = 0xc00000;
+	if (QUAKEOPT)
+	{
+		while (*QUAKEOPT)
+			if (tolower(*QUAKEOPT++) == 'm')
+			{
+				*size = atof(QUAKEOPT) * 1024*1024;
+				break;
+			}
+	}
+	return malloc (*size);
+
+}
+
+void Sys_LineRefresh(void)
+{
+}
+
+void Sys_Sleep(void)
+{
+	SDL_Delay(1);
+}
+
+void floating_point_exception_handler(int whatever)
+{
+//	Sys_Warn("floating point exception\n");
+	signal(SIGFPE, floating_point_exception_handler);
+}
+
+void moncontrol(int x)
+{
+}
+
+int main (int c, char **v)
+{
+
+	double		time, oldtime, newtime;
+	quakeparms_t parms;
+	extern int vcrFile;
+	extern int recording;
+	static int frame;
+
+	moncontrol(0);
+
+//	signal(SIGFPE, floating_point_exception_handler);
+	signal(SIGFPE, SIG_IGN);
+
+	parms.memsize = 8*1024*1024;
+	parms.membase = malloc (parms.memsize);
+	parms.basedir = basedir;
+	parms.cachedir = cachedir;
+
+	COM_InitArgv(c, v);
+	parms.argc = com_argc;
+	parms.argv = com_argv;
+
+	Sys_Init();
+
+    Host_Init(&parms);
+
+	Cvar_RegisterVariable (&sys_nostdout);
+
+    oldtime = Sys_FloatTime () - 0.1;
+    while (1)
+    {
+// find time spent rendering last frame
+        newtime = Sys_FloatTime ();
+        time = newtime - oldtime;
+
+        if (cls.state == ca_dedicated)
+        {   // play vcrfiles at max speed
+            if (time < sys_ticrate.value && (vcrFile == -1 || recording) )
+            {
+                SDL_Delay (1);
+                continue;       // not time to run a server only tic yet
+            }
+            time = sys_ticrate.value;
+        }
+
+        if (time > sys_ticrate.value*2)
+            oldtime = newtime;
+        else
+            oldtime += time;
+
+        if (++frame > 10)
+            moncontrol(1);      // profile only while we do each Quake frame
+        Host_Frame (time);
+        moncontrol(0);
+
+// graphic debugging aids
+        if (sys_linerefresh.value)
+            Sys_LineRefresh ();
+    }
+
+}
+
+
+/*
+================
+Sys_MakeCodeWriteable
+================
+*/
+void Sys_MakeCodeWriteable (unsigned long startaddr, unsigned long length)
+{
+
+	int r;
+	unsigned long addr;
+	int psize = getpagesize();
+
+	fprintf(stderr, "writable code %lx-%lx\n", startaddr, startaddr+length);
+
+	addr = startaddr & ~(psize-1);
+
+	r = mprotect((char*)addr, length + startaddr - addr, 7);
+
+	if (r < 0)
+    		Sys_Error("Protection change failed\n");
+
+}
+
diff -ruN WinQuake/sys_wina.S sdlquake-1.0.9/sys_wina.S
--- WinQuake/sys_wina.S	Wed Dec 31 16:00:00 1969
+++ sdlquake-1.0.9/sys_wina.S	Sat Dec 25 03:38:03 1999
@@ -0,0 +1,116 @@
+/*
+Copyright (C) 1996-1997 Id Software, Inc.
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation; either version 2
+of the License, or (at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
+
+See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+//
+// sys_wina.s
+// x86 assembly-language Win-dependent routines.
+
+#define GLQUAKE	1	// don't include unneeded defs
+#include "asm_i386.h"
+#include "quakeasm.h"
+
+// LATER should be id386-dependent, and have an equivalent C path
+
+	.data
+
+	.align	4
+fpenv:
+	.long	0, 0, 0, 0, 0, 0, 0, 0
+
+	.text
+
+.globl C(MaskExceptions)
+C(MaskExceptions):
+	fnstenv	fpenv
+	orl		$0x3F,fpenv
+	fldenv	fpenv
+
+	ret
+
+#if 0
+.globl C(unmaskexceptions)
+C(unmaskexceptions):
+	fnstenv	fpenv
+	andl		$0xFFFFFFE0,fpenv
+	fldenv	fpenv
+
+	ret
+#endif
+
+	.data
+
+	.align	4
+.globl	ceil_cw, single_cw, full_cw, cw, pushed_cw
+ceil_cw:	.long	0
+single_cw:	.long	0
+full_cw:	.long	0
+cw:			.long	0
+pushed_cw:	.long	0
+
+	.text
+
+.globl C(Sys_LowFPPrecision)
+C(Sys_LowFPPrecision):
+	fldcw	single_cw
+
+	ret
+
+.globl C(Sys_HighFPPrecision)
+C(Sys_HighFPPrecision):
+	fldcw	full_cw
+
+	ret
+
+.globl C(Sys_PushFPCW_SetHigh)
+C(Sys_PushFPCW_SetHigh):
+	fnstcw	pushed_cw
+	fldcw	full_cw
+
+	ret
+
+.globl C(Sys_PopFPCW)
+C(Sys_PopFPCW):
+	fldcw	pushed_cw
+
+	ret
+
+.globl C(Sys_SetFPCW)
+C(Sys_SetFPCW):
+	fnstcw	cw
+	movl	cw,%eax
+#if	id386
+	andb	$0xF0,%ah
+	orb		$0x03,%ah	// round mode, 64-bit precision
+#endif
+	movl	%eax,full_cw
+
+#if	id386
+	andb	$0xF0,%ah
+	orb		$0x0C,%ah	// chop mode, single precision
+#endif
+	movl	%eax,single_cw
+
+#if	id386
+	andb	$0xF0,%ah
+	orb		$0x08,%ah	// ceil mode, single precision
+#endif
+	movl	%eax,ceil_cw
+
+	ret
+
diff -ruN WinQuake/sys_wina.s sdlquake-1.0.9/sys_wina.s
--- WinQuake/sys_wina.s	Tue Dec 21 15:53:26 1999
+++ sdlquake-1.0.9/sys_wina.s	Wed Dec 31 16:00:00 1969
@@ -1,116 +0,0 @@
-/*
-Copyright (C) 1996-1997 Id Software, Inc.
-
-This program is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License
-as published by the Free Software Foundation; either version 2
-of the License, or (at your option) any later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
-
-See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-*/
-//
-// sys_wina.s
-// x86 assembly-language Win-dependent routines.
-
-#define GLQUAKE	1	// don't include unneeded defs
-#include "asm_i386.h"
-#include "quakeasm.h"
-
-// LATER should be id386-dependent, and have an equivalent C path
-
-	.data
-
-	.align	4
-fpenv:
-	.long	0, 0, 0, 0, 0, 0, 0, 0
-
-	.text
-
-.globl C(MaskExceptions)
-C(MaskExceptions):
-	fnstenv	fpenv
-	orl		$0x3F,fpenv
-	fldenv	fpenv
-
-	ret
-
-#if 0
-.globl C(unmaskexceptions)
-C(unmaskexceptions):
-	fnstenv	fpenv
-	andl		$0xFFFFFFE0,fpenv
-	fldenv	fpenv
-
-	ret
-#endif
-
-	.data
-
-	.align	4
-.globl	ceil_cw, single_cw, full_cw, cw, pushed_cw
-ceil_cw:	.long	0
-single_cw:	.long	0
-full_cw:	.long	0
-cw:			.long	0
-pushed_cw:	.long	0
-
-	.text
-
-.globl C(Sys_LowFPPrecision)
-C(Sys_LowFPPrecision):
-	fldcw	single_cw
-
-	ret
-
-.globl C(Sys_HighFPPrecision)
-C(Sys_HighFPPrecision):
-	fldcw	full_cw
-
-	ret
-
-.globl C(Sys_PushFPCW_SetHigh)
-C(Sys_PushFPCW_SetHigh):
-	fnstcw	pushed_cw
-	fldcw	full_cw
-
-	ret
-
-.globl C(Sys_PopFPCW)
-C(Sys_PopFPCW):
-	fldcw	pushed_cw
-
-	ret
-
-.globl C(Sys_SetFPCW)
-C(Sys_SetFPCW):
-	fnstcw	cw
-	movl	cw,%eax
-#if	id386
-	andb	$0xF0,%ah
-	orb		$0x03,%ah	// round mode, 64-bit precision
-#endif
-	movl	%eax,full_cw
-
-#if	id386
-	andb	$0xF0,%ah
-	orb		$0x0C,%ah	// chop mode, single precision
-#endif
-	movl	%eax,single_cw
-
-#if	id386
-	andb	$0xF0,%ah
-	orb		$0x08,%ah	// ceil mode, single precision
-#endif
-	movl	%eax,ceil_cw
-
-	ret
-
diff -ruN WinQuake/vid_sdl.c sdlquake-1.0.9/vid_sdl.c
--- WinQuake/vid_sdl.c	Wed Dec 31 16:00:00 1969
+++ sdlquake-1.0.9/vid_sdl.c	Tue Dec 28 10:43:11 1999
@@ -0,0 +1,389 @@
+// vid_sdl.h -- sdl video driver 
+
+#include "SDL.h"
+#include "quakedef.h"
+#include "d_local.h"
+
+viddef_t    vid;                // global video state
+unsigned short  d_8to16table[256];
+
+// The original defaults
+//#define    BASEWIDTH    320
+//#define    BASEHEIGHT   200
+// Much better for high resolution displays
+#define    BASEWIDTH    (320*2)
+#define    BASEHEIGHT   (200*2)
+
+int    VGA_width, VGA_height, VGA_rowbytes, VGA_bufferrowbytes = 0;
+byte    *VGA_pagebase;
+
+static SDL_Surface *screen = NULL;
+
+static qboolean mouse_avail;
+static float   mouse_x, mouse_y;
+static int mouse_oldbuttonstate = 0;
+
+// No support for option menus
+void (*vid_menudrawfn)(void) = NULL;
+void (*vid_menukeyfn)(int key) = NULL;
+
+void    VID_SetPalette (unsigned char *palette)
+{
+    int i;
+    SDL_Color colors[256];
+
+    for ( i=0; i<256; ++i )
+    {
+        colors[i].r = *palette++;
+        colors[i].g = *palette++;
+        colors[i].b = *palette++;
+    }
+    SDL_SetColors(screen, colors, 0, 256);
+}
+
+void    VID_ShiftPalette (unsigned char *palette)
+{
+    VID_SetPalette(palette);
+}
+
+void    VID_Init (unsigned char *palette)
+{
+    int pnum, chunk;
+    byte *cache;
+    int cachesize;
+    Uint8 video_bpp;
+    Uint16 video_w, video_h;
+    Uint32 flags;
+
+    // Load the SDL library
+    if (SDL_Init(SDL_INIT_VIDEO|SDL_INIT_AUDIO|SDL_INIT_CDROM) < 0)
+        Sys_Error("VID: Couldn't load SDL: %s", SDL_GetError());
+
+    // Set up display mode (width and height)
+    vid.width = BASEWIDTH;
+    vid.height = BASEHEIGHT;
+    vid.maxwarpwidth = WARP_WIDTH;
+    vid.maxwarpheight = WARP_HEIGHT;
+    if ((pnum=COM_CheckParm("-winsize")))
+    {
+        if (pnum >= com_argc-2)
+            Sys_Error("VID: -winsize <width> <height>\n");
+        vid.width = Q_atoi(com_argv[pnum+1]);
+        vid.height = Q_atoi(com_argv[pnum+2]);
+        if (!vid.width || !vid.height)
+            Sys_Error("VID: Bad window width/height\n");
+    }
+
+    // Set video width, height and flags
+    flags = (SDL_SWSURFACE|SDL_HWPALETTE);
+    if ( COM_CheckParm ("-fullscreen") )
+        flags |= SDL_FULLSCREEN;
+
+    // Initialize display 
+    if (!(screen = SDL_SetVideoMode(vid.width, vid.height, 8, flags)))
+        Sys_Error("VID: Couldn't set video mode: %s\n", SDL_GetError());
+    VID_SetPalette(palette);
+    SDL_WM_SetCaption("sdlquake","sdlquake");
+    // now know everything we need to know about the buffer
+    VGA_width = vid.conwidth = vid.width;
+    VGA_height = vid.conheight = vid.height;
+    vid.aspect = ((float)vid.height / (float)vid.width) * (320.0 / 240.0);
+    vid.numpages = 1;
+    vid.colormap = host_colormap;
+    vid.fullbright = 256 - LittleLong (*((int *)vid.colormap + 2048));
+    VGA_pagebase = vid.buffer = screen->pixels;
+    VGA_rowbytes = vid.rowbytes = screen->pitch;
+    vid.conbuffer = vid.buffer;
+    vid.conrowbytes = vid.rowbytes;
+    vid.direct = 0;
+    
+    // allocate z buffer and surface cache
+    chunk = vid.width * vid.height * sizeof (*d_pzbuffer);
+    cachesize = D_SurfaceCacheForRes (vid.width, vid.height);
+    chunk += cachesize;
+    d_pzbuffer = Hunk_HighAllocName(chunk, "video");
+    if (d_pzbuffer == NULL)
+        Sys_Error ("Not enough memory for video mode\n");
+
+    // initialize the cache memory 
+        cache = (byte *) d_pzbuffer
+                + vid.width * vid.height * sizeof (*d_pzbuffer);
+    D_InitCaches (cache, cachesize);
+
+    // initialize the mouse
+    SDL_ShowCursor(0);
+}
+
+void    VID_Shutdown (void)
+{
+    SDL_Quit();
+}
+
+void    VID_Update (vrect_t *rects)
+{
+    SDL_Rect *sdlrects;
+    int n, i;
+    vrect_t *rect;
+
+    // Two-pass system, since Quake doesn't do it the SDL way...
+
+    // First, count the number of rectangles
+    n = 0;
+    for (rect = rects; rect; rect = rect->pnext)
+        ++n;
+
+    // Second, copy them to SDL rectangles and update
+    if (!(sdlrects = (SDL_Rect *)alloca(n*sizeof(*sdlrects))))
+        Sys_Error("Out of memory");
+    i = 0;
+    for (rect = rects; rect; rect = rect->pnext)
+    {
+        sdlrects[i].x = rect->x;
+        sdlrects[i].y = rect->y;
+        sdlrects[i].w = rect->width;
+        sdlrects[i].h = rect->height;
+        ++i;
+    }
+    SDL_UpdateRects(screen, n, sdlrects);
+}
+
+/*
+================
+D_BeginDirectRect
+================
+*/
+void D_BeginDirectRect (int x, int y, byte *pbitmap, int width, int height)
+{
+    Uint8 *offset;
+
+
+    if (!screen) return;
+    if ( x < 0 ) x = screen->w+x-1;
+    offset = (Uint8 *)screen->pixels + y*screen->pitch + x;
+    while ( height-- )
+    {
+        memcpy(offset, pbitmap, width);
+        offset += screen->pitch;
+        pbitmap += width;
+    }
+}
+
+
+/*
+================
+D_EndDirectRect
+================
+*/
+void D_EndDirectRect (int x, int y, int width, int height)
+{
+    if (!screen) return;
+    if (x < 0) x = screen->w+x-1;
+    SDL_UpdateRect(screen, x, y, width, height);
+}
+
+
+/*
+================
+Sys_SendKeyEvents
+================
+*/
+
+void Sys_SendKeyEvents(void)
+{
+    SDL_Event event;
+    int sym, state;
+     int modstate;
+
+    while (SDL_PollEvent(&event))
+    {
+        switch (event.type) {
+
+            case SDL_KEYDOWN:
+            case SDL_KEYUP:
+                sym = event.key.keysym.sym;
+                state = event.key.state;
+                modstate = SDL_GetModState();
+                switch(sym)
+                {
+                   case SDLK_DELETE: sym = K_DEL; break;
+                   case SDLK_BACKSPACE: sym = K_BACKSPACE; break;
+                   case SDLK_F1: sym = K_F1; break;
+                   case SDLK_F2: sym = K_F2; break;
+                   case SDLK_F3: sym = K_F3; break;
+                   case SDLK_F4: sym = K_F4; break;
+                   case SDLK_F5: sym = K_F5; break;
+                   case SDLK_F6: sym = K_F6; break;
+                   case SDLK_F7: sym = K_F7; break;
+                   case SDLK_F8: sym = K_F8; break;
+                   case SDLK_F9: sym = K_F9; break;
+                   case SDLK_F10: sym = K_F10; break;
+                   case SDLK_F11: sym = K_F11; break;
+                   case SDLK_F12: sym = K_F12; break;
+                   case SDLK_BREAK:
+                   case SDLK_PAUSE: sym = K_PAUSE; break;
+                   case SDLK_UP: sym = K_UPARROW; break;
+                   case SDLK_DOWN: sym = K_DOWNARROW; break;
+                   case SDLK_RIGHT: sym = K_RIGHTARROW; break;
+                   case SDLK_LEFT: sym = K_LEFTARROW; break;
+                   case SDLK_INSERT: sym = K_INS; break;
+                   case SDLK_HOME: sym = K_HOME; break;
+                   case SDLK_END: sym = K_END; break;
+                   case SDLK_PAGEUP: sym = K_PGUP; break;
+                   case SDLK_PAGEDOWN: sym = K_PGDN; break;
+                   case SDLK_RSHIFT:
+                   case SDLK_LSHIFT: sym = K_SHIFT; break;
+                   case SDLK_RCTRL:
+                   case SDLK_LCTRL: sym = K_CTRL; break;
+                   case SDLK_RALT:
+                   case SDLK_LALT: sym = K_ALT; break;
+                   case SDLK_KP0: 
+                       if(modstate & KMOD_NUM) sym = K_INS; 
+                       else sym = SDLK_0;
+                       break;
+                   case SDLK_KP1:
+                       if(modstate & KMOD_NUM) sym = K_END;
+                       else sym = SDLK_1;
+                       break;
+                   case SDLK_KP2:
+                       if(modstate & KMOD_NUM) sym = K_DOWNARROW;
+                       else sym = SDLK_2;
+                       break;
+                   case SDLK_KP3:
+                       if(modstate & KMOD_NUM) sym = K_PGDN;
+                       else sym = SDLK_3;
+                       break;
+                   case SDLK_KP4:
+                       if(modstate & KMOD_NUM) sym = K_LEFTARROW;
+                       else sym = SDLK_4;
+                       break;
+                   case SDLK_KP5: sym = SDLK_5; break;
+                   case SDLK_KP6:
+                       if(modstate & KMOD_NUM) sym = K_RIGHTARROW;
+                       else sym = SDLK_6;
+                       break;
+                   case SDLK_KP7:
+                       if(modstate & KMOD_NUM) sym = K_HOME;
+                       else sym = SDLK_7;
+                       break;
+                   case SDLK_KP8:
+                       if(modstate & KMOD_NUM) sym = K_UPARROW;
+                       else sym = SDLK_8;
+                       break;
+                   case SDLK_KP9:
+                       if(modstate & KMOD_NUM) sym = K_PGUP;
+                       else sym = SDLK_9;
+                       break;
+                   case SDLK_KP_PERIOD:
+                       if(modstate & KMOD_NUM) sym = K_DEL;
+                       else sym = SDLK_PERIOD;
+                       break;
+                   case SDLK_KP_DIVIDE: sym = SDLK_SLASH; break;
+                   case SDLK_KP_MULTIPLY: sym = SDLK_ASTERISK; break;
+                   case SDLK_KP_MINUS: sym = SDLK_MINUS; break;
+                   case SDLK_KP_PLUS: sym = SDLK_PLUS; break;
+                   case SDLK_KP_ENTER: sym = SDLK_RETURN; break;
+                   case SDLK_KP_EQUALS: sym = SDLK_EQUALS; break;
+                }
+                // If we're not directly handled and still above 255
+                // just force it to 0
+                if(sym > 255) sym = 0;
+                Key_Event(sym, state);
+                break;
+
+            case SDL_MOUSEMOTION:
+                if ( (event.motion.x != (vid.width/2)) ||
+                     (event.motion.y != (vid.height/2)) ) {
+                    mouse_x = event.motion.xrel*10;
+                    mouse_y = event.motion.yrel*10;
+                    if ( (event.motion.x < ((vid.width/2)-(vid.width/4))) ||
+                         (event.motion.x > ((vid.width/2)+(vid.width/4))) ||
+                         (event.motion.y < ((vid.height/2)-(vid.height/4))) ||
+                         (event.motion.y > ((vid.height/2)+(vid.height/4))) ) {
+                        SDL_WarpMouse(vid.width/2, vid.height/2);
+                    }
+                }
+                break;
+
+            case SDL_QUIT:
+                CL_Disconnect ();
+                Host_ShutdownServer(false);        
+                Sys_Quit ();
+                break;
+            default:
+                break;
+        }
+    }
+}
+
+void IN_Init (void)
+{
+    if ( COM_CheckParm ("-nomouse") )
+        return;
+    mouse_x = mouse_y = 0.0;
+    mouse_avail = 1;
+}
+
+void IN_Shutdown (void)
+{
+    mouse_avail = 0;
+}
+
+void IN_Commands (void)
+{
+    int i;
+    int mouse_buttonstate;
+   
+    if (!mouse_avail) return;
+   
+    i = SDL_GetMouseState(NULL, NULL);
+    /* Quake swaps the second and third buttons */
+    mouse_buttonstate = (i & ~0x06) | ((i & 0x02)<<1) | ((i & 0x04)>>1);
+    for (i=0 ; i<3 ; i++) {
+        if ( (mouse_buttonstate & (1<<i)) && !(mouse_oldbuttonstate & (1<<i)) )
+            Key_Event (K_MOUSE1 + i, true);
+
+        if ( !(mouse_buttonstate & (1<<i)) && (mouse_oldbuttonstate & (1<<i)) )
+            Key_Event (K_MOUSE1 + i, false);
+    }
+    mouse_oldbuttonstate = mouse_buttonstate;
+}
+
+void IN_Move (usercmd_t *cmd)
+{
+    if (!mouse_avail)
+        return;
+   
+    mouse_x *= sensitivity.value;
+    mouse_y *= sensitivity.value;
+   
+    if ( (in_strafe.state & 1) || (lookstrafe.value && (in_mlook.state & 1) ))
+        cmd->sidemove += m_side.value * mouse_x;
+    else
+        cl.viewangles[YAW] -= m_yaw.value * mouse_x;
+    if (in_mlook.state & 1)
+        V_StopPitchDrift ();
+   
+    if ( (in_mlook.state & 1) && !(in_strafe.state & 1)) {
+        cl.viewangles[PITCH] += m_pitch.value * mouse_y;
+        if (cl.viewangles[PITCH] > 80)
+            cl.viewangles[PITCH] = 80;
+        if (cl.viewangles[PITCH] < -70)
+            cl.viewangles[PITCH] = -70;
+    } else {
+        if ((in_strafe.state & 1) && noclip_anglehack)
+            cmd->upmove -= m_forward.value * mouse_y;
+        else
+            cmd->forwardmove -= m_forward.value * mouse_y;
+    }
+    mouse_x = mouse_y = 0.0;
+}
+
+/*
+================
+Sys_ConsoleInput
+================
+*/
+char *Sys_ConsoleInput (void)
+{
+    return 0;
+}
diff -ruN WinQuake/worlda.S sdlquake-1.0.9/worlda.S
--- WinQuake/worlda.S	Wed Dec 31 16:00:00 1969
+++ sdlquake-1.0.9/worlda.S	Sat Dec 25 03:38:03 1999
@@ -0,0 +1,144 @@
+/*
+Copyright (C) 1996-1997 Id Software, Inc.
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation; either version 2
+of the License, or (at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
+
+See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+//
+// worlda.s
+// x86 assembly-language server testing stuff
+//
+
+#define GLQUAKE	1	// don't include unneeded defs
+#include "asm_i386.h"
+#include "quakeasm.h"
+#include "d_ifacea.h"
+
+#if id386
+
+	.data
+
+Ltemp:	.long	0
+
+	.text
+
+//----------------------------------------------------------------------
+// hull-point test
+//----------------------------------------------------------------------
+
+#define hull	4+8				// because only partially pushed
+#define	num		8+4				// because only partially pushed
+#define p		12+12			// because only partially pushed
+
+	.align 4
+.globl C(SV_HullPointContents)
+C(SV_HullPointContents):
+	pushl	%edi				// preserve register variables
+	movl	num(%esp),%eax
+	testl	%eax,%eax
+	js		Lhquickout
+
+//	float		d;
+//	dclipnode_t	*node;
+//	mplane_t	*plane;
+
+	pushl	%ebx
+	movl	hull(%esp),%ebx
+
+	pushl	%ebp
+	movl	p(%esp),%edx
+
+	movl	hu_clipnodes(%ebx),%edi
+	movl	hu_planes(%ebx),%ebp
+
+	subl	%ebx,%ebx
+	pushl	%esi
+
+// %ebx: 0
+// %eax: num
+// %edx: p
+// %edi: hull->clipnodes
+// %ebp: hull->planes
+
+//	while (num >= 0)
+//	{
+
+Lhloop:
+
+//		node = hull->clipnodes + num;
+//		plane = hull->planes + node->planenum;
+// !!! if the size of dclipnode_t changes, the scaling of %eax needs to be
+//     changed !!!
+	movl	nd_planenum(%edi,%eax,8),%ecx
+	movl	nd_children(%edi,%eax,8),%eax
+	movl	%eax,%esi
+	rorl	$16,%eax
+	leal	(%ecx,%ecx,4),%ecx
+
+//		if (plane->type < 3)
+//			d = p[plane->type] - plane->dist;
+	movb	pl_type(%ebp,%ecx,4),%bl
+	cmpb	$3,%bl
+	jb		Lnodot
+
+//		else
+//			d = DotProduct (plane->normal, p) - plane->dist;
+	flds	pl_normal(%ebp,%ecx,4)
+	fmuls	0(%edx)
+	flds	pl_normal+4(%ebp,%ecx,4)
+	fmuls	4(%edx)
+	flds	pl_normal+8(%ebp,%ecx,4)
+	fmuls	8(%edx)
+	fxch	%st(1)
+	faddp	%st(0),%st(2)
+	faddp	%st(0),%st(1)
+	fsubs	pl_dist(%ebp,%ecx,4)
+	jmp		Lsub
+
+Lnodot:
+	flds	pl_dist(%ebp,%ecx,4)
+	fsubrs	(%edx,%ebx,4)
+
+Lsub:
+	sarl	$16,%eax
+	sarl	$16,%esi
+
+//		if (d < 0)
+//			num = node->children[1];
+//		else
+//			num = node->children[0];
+	fstps	Ltemp
+	movl	Ltemp,%ecx
+	sarl	$31,%ecx
+	andl	%ecx,%esi
+	xorl	$0xFFFFFFFF,%ecx
+	andl	%ecx,%eax
+	orl		%esi,%eax
+	jns		Lhloop
+
+//	return num;
+Lhdone:
+	popl	%esi
+	popl	%ebp
+	popl	%ebx				// restore register variables
+
+Lhquickout:
+	popl	%edi
+
+	ret
+
+#endif	// id386
+
diff -ruN WinQuake/worlda.s sdlquake-1.0.9/worlda.s
--- WinQuake/worlda.s	Tue Dec 21 15:53:26 1999
+++ sdlquake-1.0.9/worlda.s	Wed Dec 31 16:00:00 1969
@@ -1,144 +0,0 @@
-/*
-Copyright (C) 1996-1997 Id Software, Inc.
-
-This program is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License
-as published by the Free Software Foundation; either version 2
-of the License, or (at your option) any later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
-
-See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-*/
-//
-// worlda.s
-// x86 assembly-language server testing stuff
-//
-
-#define GLQUAKE	1	// don't include unneeded defs
-#include "asm_i386.h"
-#include "quakeasm.h"
-#include "d_ifacea.h"
-
-#if id386
-
-	.data
-
-Ltemp:	.long	0
-
-	.text
-
-//----------------------------------------------------------------------
-// hull-point test
-//----------------------------------------------------------------------
-
-#define hull	4+8				// because only partially pushed
-#define	num		8+4				// because only partially pushed
-#define p		12+12			// because only partially pushed
-
-	.align 4
-.globl C(SV_HullPointContents)
-C(SV_HullPointContents):
-	pushl	%edi				// preserve register variables
-	movl	num(%esp),%eax
-	testl	%eax,%eax
-	js		Lhquickout
-
-//	float		d;
-//	dclipnode_t	*node;
-//	mplane_t	*plane;
-
-	pushl	%ebx
-	movl	hull(%esp),%ebx
-
-	pushl	%ebp
-	movl	p(%esp),%edx
-
-	movl	hu_clipnodes(%ebx),%edi
-	movl	hu_planes(%ebx),%ebp
-
-	subl	%ebx,%ebx
-	pushl	%esi
-
-// %ebx: 0
-// %eax: num
-// %edx: p
-// %edi: hull->clipnodes
-// %ebp: hull->planes
-
-//	while (num >= 0)
-//	{
-
-Lhloop:
-
-//		node = hull->clipnodes + num;
-//		plane = hull->planes + node->planenum;
-// !!! if the size of dclipnode_t changes, the scaling of %eax needs to be
-//     changed !!!
-	movl	nd_planenum(%edi,%eax,8),%ecx
-	movl	nd_children(%edi,%eax,8),%eax
-	movl	%eax,%esi
-	rorl	$16,%eax
-	leal	(%ecx,%ecx,4),%ecx
-
-//		if (plane->type < 3)
-//			d = p[plane->type] - plane->dist;
-	movb	pl_type(%ebp,%ecx,4),%bl
-	cmpb	$3,%bl
-	jb		Lnodot
-
-//		else
-//			d = DotProduct (plane->normal, p) - plane->dist;
-	flds	pl_normal(%ebp,%ecx,4)
-	fmuls	0(%edx)
-	flds	pl_normal+4(%ebp,%ecx,4)
-	fmuls	4(%edx)
-	flds	pl_normal+8(%ebp,%ecx,4)
-	fmuls	8(%edx)
-	fxch	%st(1)
-	faddp	%st(0),%st(2)
-	faddp	%st(0),%st(1)
-	fsubs	pl_dist(%ebp,%ecx,4)
-	jmp		Lsub
-
-Lnodot:
-	flds	pl_dist(%ebp,%ecx,4)
-	fsubrs	(%edx,%ebx,4)
-
-Lsub:
-	sarl	$16,%eax
-	sarl	$16,%esi
-
-//		if (d < 0)
-//			num = node->children[1];
-//		else
-//			num = node->children[0];
-	fstps	Ltemp
-	movl	Ltemp,%ecx
-	sarl	$31,%ecx
-	andl	%ecx,%esi
-	xorl	$0xFFFFFFFF,%ecx
-	andl	%ecx,%eax
-	orl		%esi,%eax
-	jns		Lhloop
-
-//	return num;
-Lhdone:
-	popl	%esi
-	popl	%ebp
-	popl	%ebx				// restore register variables
-
-Lhquickout:
-	popl	%edi
-
-	ret
-
-#endif	// id386
-
